name: Build and Release Packages

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (without v prefix, e.g. 1.0.0)'
        required: true
      commit:
        description: 'Commit SHA to tag (optional - defaults to latest non-benchmark commit on triggering branch)'
        required: false
        default: ''

permissions:
  contents: write
  pages: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.resolve.outputs.version }}
      commit: ${{ steps.resolve.outputs.commit }}
      tag: ${{ steps.resolve.outputs.tag }}
      is_canary: ${{ steps.resolve.outputs.is_canary }}
      package_name: ${{ steps.resolve.outputs.package_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 50  # Fetch enough history to find non-benchmark commits

      - name: Resolve commit and create tag
        id: resolve
        run: |
          VERSION="${{ github.event.inputs.version }}"

          # Validate version format (no leading 'v', basic version like 1.2.3 or 1.2.3-beta.1)
          if [[ ! "$VERSION" =~ ^[0-9]+(\.[0-9]+)*([.-][0-9A-Za-z]+)*$ ]]; then
            echo "::error::Invalid version '${VERSION}'. Expected format like '1.0' or '1.2.3' without 'v' prefix."
            exit 1
          fi

          TAG="v${VERSION}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT

          # Detect canary release
          IS_CANARY=false
          PACKAGE_NAME="mkvdup"
          if [[ "$VERSION" == *-canary.* ]]; then
            IS_CANARY=true
            PACKAGE_NAME="mkvdup-canary"
          fi
          echo "is_canary=${IS_CANARY}" >> $GITHUB_OUTPUT
          echo "package_name=${PACKAGE_NAME}" >> $GITHUB_OUTPUT

          # Check if tag already exists
          if git rev-parse "${TAG}" >/dev/null 2>&1; then
            echo "::error::Tag ${TAG} already exists"
            exit 1
          fi

          # Determine which commit to tag
          if [[ -n "${{ github.event.inputs.commit }}" ]]; then
            COMMIT="${{ github.event.inputs.commit }}"
            echo "Using specified commit: ${COMMIT}"
          else
            # Find the latest commit on the triggering branch that isn't a benchmark commit
            BRANCH="${{ github.ref_name }}"
            echo "Finding latest non-benchmark commit on ${BRANCH}..."
            COMMIT=$(git log "origin/${BRANCH}" --oneline -50 | grep -v -iE '\[(skip ci|ci skip|no ci|skip actions|actions skip|benchmark)\]' | head -1 | awk '{print $1}')
            if [[ -z "${COMMIT}" ]]; then
              echo "::error::Could not find a non-benchmark commit in recent history"
              exit 1
            fi
            echo "Found non-benchmark commit: ${COMMIT}"
          fi

          # Resolve to full SHA
          FULL_SHA=$(git rev-parse "${COMMIT}")
          echo "commit=${FULL_SHA}" >> $GITHUB_OUTPUT
          echo "Resolved commit: ${FULL_SHA}"

          # Show what we're tagging
          echo "Will create tag ${TAG} on commit:"
          git log -1 --oneline "${FULL_SHA}"

      - name: Create and push tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "${{ steps.resolve.outputs.tag }}" "${{ steps.resolve.outputs.commit }}"
          git push origin "${{ steps.resolve.outputs.tag }}"

  build:
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.commit }}

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: '1.25'  # nfpm@latest requires Go >= 1.25

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          go build -ldflags="-s -w -X main.version=${{ needs.prepare.outputs.version }}" -o ${{ needs.prepare.outputs.package_name }} ./cmd/mkvdup

      - name: Expand man page variables
        env:
          PACKAGE_NAME: ${{ needs.prepare.outputs.package_name }}
        run: |
          UPPER=$(echo "$PACKAGE_NAME" | tr '[:lower:]' '[:upper:]')
          sed -i \
            -e "s/@PACKAGE_NAME_UPPER@/${UPPER}/g" \
            -e "s/@PACKAGE_NAME@/${PACKAGE_NAME}/g" \
            docs/mkvdup.1

      - name: Install nfpm
        if: matrix.goos == 'linux'
        run: go install github.com/goreleaser/nfpm/v2/cmd/nfpm@latest

      - name: Build deb package
        if: matrix.goos == 'linux'
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          GOARCH: ${{ matrix.goarch }}
          PACKAGE_NAME: ${{ needs.prepare.outputs.package_name }}
        run: |
          nfpm package --packager deb --target .

      - name: Build rpm package
        if: matrix.goos == 'linux'
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          GOARCH: ${{ matrix.goarch }}
          PACKAGE_NAME: ${{ needs.prepare.outputs.package_name }}
        run: |
          nfpm package --packager rpm --target .

      - name: Create Homebrew tarball
        env:
          PACKAGE_NAME: ${{ needs.prepare.outputs.package_name }}
          VERSION: ${{ needs.prepare.outputs.version }}
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          TARBALL_NAME="${PACKAGE_NAME}_${GOOS}_${GOARCH}.tar.gz"

          # Create staging directory
          mkdir -p staging

          # Copy binary (rename to mkvdup for consistency in tarball)
          cp "${PACKAGE_NAME}" staging/mkvdup

          # Copy man page
          cp docs/mkvdup.1 staging/

          # Copy documentation
          cp README.md DESIGN.md LICENSE staging/
          mkdir -p staging/docs
          cp docs/*.md staging/docs/

          # Copy shell completions
          cp scripts/mkvdup-completion.bash staging/
          cp scripts/mkvdup-completion.zsh staging/
          cp scripts/mkvdup.fish staging/

          # Create tarball
          tar -czvf "${TARBALL_NAME}" -C staging .

          echo "Created ${TARBALL_NAME}"
          ls -la "${TARBALL_NAME}"

      - name: List built packages
        run: |
          ls -la *.deb *.rpm *.tar.gz 2>/dev/null || true

      - name: Upload deb artifact
        if: matrix.goos == 'linux'
        uses: actions/upload-artifact@v6
        with:
          name: deb-package-${{ matrix.goarch }}
          path: "*.deb"

      - name: Upload rpm artifact
        if: matrix.goos == 'linux'
        uses: actions/upload-artifact@v6
        with:
          name: rpm-package-${{ matrix.goarch }}
          path: "*.rpm"

      - name: Upload tarball artifact
        uses: actions/upload-artifact@v6
        with:
          name: tarball-${{ matrix.goos }}-${{ matrix.goarch }}
          path: "*.tar.gz"

  release:
    needs: [prepare, build]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v7
        with:
          path: packages/
          merge-multiple: true

      - name: List packages
        run: ls -la packages/

      - name: Upload to Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare.outputs.tag }}
          files: packages/*
          generate_release_notes: true
          prerelease: ${{ needs.prepare.outputs.is_canary == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-homebrew:
    needs: [prepare, build, release]
    if: needs.prepare.outputs.is_canary == 'false'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download tarball artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: tarball-*
          path: tarballs/
          merge-multiple: true

      - name: Calculate SHA256 checksums
        id: checksums
        run: |
          cd tarballs

          PACKAGE_NAME="${{ needs.prepare.outputs.package_name }}"

          SHA_DARWIN_ARM64=$(sha256sum "${PACKAGE_NAME}_darwin_arm64.tar.gz" | awk '{print $1}')
          SHA_DARWIN_AMD64=$(sha256sum "${PACKAGE_NAME}_darwin_amd64.tar.gz" | awk '{print $1}')
          SHA_LINUX_ARM64=$(sha256sum "${PACKAGE_NAME}_linux_arm64.tar.gz" | awk '{print $1}')
          SHA_LINUX_AMD64=$(sha256sum "${PACKAGE_NAME}_linux_amd64.tar.gz" | awk '{print $1}')

          echo "sha_darwin_arm64=${SHA_DARWIN_ARM64}" >> $GITHUB_OUTPUT
          echo "sha_darwin_amd64=${SHA_DARWIN_AMD64}" >> $GITHUB_OUTPUT
          echo "sha_linux_arm64=${SHA_LINUX_ARM64}" >> $GITHUB_OUTPUT
          echo "sha_linux_amd64=${SHA_LINUX_AMD64}" >> $GITHUB_OUTPUT

          echo "SHA256 checksums:"
          echo "  darwin_arm64: ${SHA_DARWIN_ARM64}"
          echo "  darwin_amd64: ${SHA_DARWIN_AMD64}"
          echo "  linux_arm64: ${SHA_LINUX_ARM64}"
          echo "  linux_amd64: ${SHA_LINUX_AMD64}"

      - name: Update Homebrew formula
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          TAG: ${{ needs.prepare.outputs.tag }}
          SHA_DARWIN_ARM64: ${{ steps.checksums.outputs.sha_darwin_arm64 }}
          SHA_DARWIN_AMD64: ${{ steps.checksums.outputs.sha_darwin_amd64 }}
          SHA_LINUX_ARM64: ${{ steps.checksums.outputs.sha_linux_arm64 }}
          SHA_LINUX_AMD64: ${{ steps.checksums.outputs.sha_linux_amd64 }}
        run: |
          cat > HomebrewFormula/mkvdup.rb << EOF
          # typed: false
          # frozen_string_literal: true

          # Homebrew formula for mkvdup
          # This file is auto-updated by the release workflow.
          # To install: brew tap stuckj/mkvdup https://github.com/stuckj/mkvdup && brew install mkvdup

          class Mkvdup < Formula
            desc "Storage deduplication tool for MKV files and their source media"
            homepage "https://github.com/stuckj/mkvdup"
            license "MIT"
            version "${VERSION}"

            on_macos do
              on_arm do
                url "https://github.com/stuckj/mkvdup/releases/download/${TAG}/mkvdup_darwin_arm64.tar.gz"
                sha256 "${SHA_DARWIN_ARM64}"
              end
              on_intel do
                url "https://github.com/stuckj/mkvdup/releases/download/${TAG}/mkvdup_darwin_amd64.tar.gz"
                sha256 "${SHA_DARWIN_AMD64}"
              end
            end

            on_linux do
              on_arm do
                url "https://github.com/stuckj/mkvdup/releases/download/${TAG}/mkvdup_linux_arm64.tar.gz"
                sha256 "${SHA_LINUX_ARM64}"
              end
              on_intel do
                url "https://github.com/stuckj/mkvdup/releases/download/${TAG}/mkvdup_linux_amd64.tar.gz"
                sha256 "${SHA_LINUX_AMD64}"
              end
            end

            def install
              bin.install "mkvdup"
              man1.install "mkvdup.1"
              doc.install "README.md", "DESIGN.md", "LICENSE"
              doc.install Dir["docs/*"]
              bash_completion.install "mkvdup-completion.bash" => "mkvdup"
              zsh_completion.install "mkvdup-completion.zsh" => "_mkvdup"
              fish_completion.install "mkvdup.fish"
            end

            test do
              assert_match version.to_s, shell_output("#{bin}/mkvdup --version")
            end
          end
          EOF

      - name: Commit and push formula update
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add HomebrewFormula/mkvdup.rb
          git diff --staged --quiet || git commit -m "Update Homebrew formula for ${{ needs.prepare.outputs.tag }} [skip ci]"
          git push origin main
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish-repo:
    needs: [prepare, build]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout gh-pages branch
        id: checkout-gh-pages
        uses: actions/checkout@v6
        with:
          ref: gh-pages
          path: gh-pages
          fetch-depth: 0
        continue-on-error: true

      - name: Initialize gh-pages if needed
        if: steps.checkout-gh-pages.outcome == 'failure'
        run: |
          mkdir -p gh-pages
          cd gh-pages
          git init
          git remote add origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          git checkout -b gh-pages

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev createrepo-c gnupg

      - name: Import GPG key
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | awk '{print $2}' | cut -d'/' -f2)
          echo "GPG_KEY_ID=$KEY_ID" >> $GITHUB_ENV

          # Configure GPG for non-interactive use
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          echo "use-agent" >> ~/.gnupg/gpg.conf
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          gpgconf --kill gpg-agent

      - name: Download all deb packages
        uses: actions/download-artifact@v7
        with:
          pattern: deb-package-*
          path: packages/
          merge-multiple: true

      - name: Download all rpm packages
        uses: actions/download-artifact@v7
        with:
          pattern: rpm-package-*
          path: packages/
          merge-multiple: true

      - name: Setup APT repository structure
        env:
          IS_CANARY: ${{ needs.prepare.outputs.is_canary }}
        run: |
          cd gh-pages

          # Set paths based on release channel
          if [[ "$IS_CANARY" == "true" ]]; then
            POOL="pool/canary"
            DIST="dists/canary"
            SUITE="canary"
            LABEL="mkvdup-canary"
            DESC="mkvdup canary packages"
          else
            POOL="pool/main"
            DIST="dists/stable"
            SUITE="stable"
            LABEL="mkvdup"
            DESC="mkvdup packages"
          fi

          # Create directory structure
          mkdir -p "apt/${POOL}"
          mkdir -p "apt/${DIST}/main/binary-amd64"
          mkdir -p "apt/${DIST}/main/binary-arm64"

          # Copy deb packages to pool
          cp ../packages/*.deb "apt/${POOL}/"

          # Generate Packages files for each architecture
          cd apt
          dpkg-scanpackages --arch amd64 "${POOL}/" > "${DIST}/main/binary-amd64/Packages"
          gzip -k -f "${DIST}/main/binary-amd64/Packages"
          dpkg-scanpackages --arch arm64 "${POOL}/" > "${DIST}/main/binary-arm64/Packages"
          gzip -k -f "${DIST}/main/binary-arm64/Packages"

          # Create Release file
          cd "${DIST}"
          cat > Release << EOF
          Origin: ${LABEL}
          Label: ${LABEL}
          Suite: ${SUITE}
          Codename: ${SUITE}
          Architectures: amd64 arm64
          Components: main
          Description: ${DESC}
          Date: $(date -Ru)
          EOF

          # Add checksums to Release file
          echo "SHA256:" >> Release
          for f in main/binary-amd64/Packages main/binary-amd64/Packages.gz \
                   main/binary-arm64/Packages main/binary-arm64/Packages.gz; do
            if [[ -f "$f" ]]; then
              SIZE=$(stat -c%s "$f")
              SHA=$(sha256sum "$f" | awk '{print $1}')
              echo " $SHA $SIZE $f" >> Release
            fi
          done

          # Sign the Release file
          echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --armor --passphrase-fd 0 --detach-sign -o Release.gpg Release
          echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --armor --passphrase-fd 0 --clearsign -o InRelease Release

      - name: Setup YUM repository structure
        env:
          IS_CANARY: ${{ needs.prepare.outputs.is_canary }}
        run: |
          cd gh-pages

          # Set YUM directory based on release channel
          if [[ "$IS_CANARY" == "true" ]]; then
            YUM_DIR="yum-canary"
          else
            YUM_DIR="yum"
          fi

          # Create directory structure
          mkdir -p "${YUM_DIR}/packages"

          # Copy rpm packages
          cp ../packages/*.rpm "${YUM_DIR}/packages/"

          # Generate repository metadata
          cd "${YUM_DIR}"
          createrepo_c .

          # Sign the repository metadata
          echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --armor --passphrase-fd 0 --detach-sign -o repodata/repomd.xml.asc repodata/repomd.xml

      - name: Export GPG public key
        run: |
          cd gh-pages
          gpg --armor --export ${{ env.GPG_KEY_ID }} > gpg-key.asc
          # Copy to all repo directories that exist
          for dir in apt yum yum-canary; do
            if [[ -d "$dir" ]]; then cp gpg-key.asc "$dir/"; fi
          done

      - name: Create index page
        run: |
          cat > gh-pages/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
            <title>mkvdup - Package Repository</title>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; }
              pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
              code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }
              h1 { border-bottom: 2px solid #333; padding-bottom: 10px; }
              h2 { margin-top: 30px; }
            </style>
          </head>
          <body>
            <h1>mkvdup</h1>
            <p>MKV deduplication tool using FUSE. Store MKV files as small dedup files that reference original DVD/Blu-ray sources.</p>

            <h2>macOS / Linux (Homebrew)</h2>
            <pre>
          brew tap stuckj/mkvdup https://github.com/stuckj/mkvdup
          brew install mkvdup</pre>

            <h2>Debian/Ubuntu (APT)</h2>
            <pre>
          # Add the GPG key
          curl -fsSL https://stuckj.github.io/mkvdup/gpg-key.asc | sudo gpg --dearmor -o /usr/share/keyrings/mkvdup.gpg

          # Add the repository
          echo "deb [signed-by=/usr/share/keyrings/mkvdup.gpg arch=amd64,arm64] https://stuckj.github.io/mkvdup/apt stable main" | sudo tee /etc/apt/sources.list.d/mkvdup.list

          # Install
          sudo apt update
          sudo apt install mkvdup</pre>

            <h2>RHEL/CentOS/Fedora (YUM/DNF)</h2>
            <pre>
          # Add the repository
          sudo tee /etc/yum.repos.d/mkvdup.repo &lt;&lt; 'REPO'
          [mkvdup]
          name=mkvdup
          baseurl=https://stuckj.github.io/mkvdup/yum
          enabled=1
          gpgcheck=1
          gpgkey=https://stuckj.github.io/mkvdup/yum/gpg-key.asc
          REPO

          # Install
          sudo dnf install mkvdup</pre>

            <h2>Canary Channel (Pre-release)</h2>
            <p>The canary channel provides early access to new features. It installs as
            <code>mkvdup-canary</code> and can be installed alongside the stable version.</p>

            <h3>Debian/Ubuntu (APT) - Canary</h3>
            <pre>
          # Add the GPG key (same key as stable)
          curl -fsSL https://stuckj.github.io/mkvdup/gpg-key.asc | sudo gpg --dearmor -o /usr/share/keyrings/mkvdup.gpg

          # Add the canary repository
          echo "deb [signed-by=/usr/share/keyrings/mkvdup.gpg arch=amd64,arm64] https://stuckj.github.io/mkvdup/apt canary main" | sudo tee /etc/apt/sources.list.d/mkvdup-canary.list

          # Install
          sudo apt update
          sudo apt install mkvdup-canary</pre>

            <h3>RHEL/CentOS/Fedora (YUM/DNF) - Canary</h3>
            <pre>
          # Add the canary repository
          sudo tee /etc/yum.repos.d/mkvdup-canary.repo &lt;&lt; 'REPO'
          [mkvdup-canary]
          name=mkvdup-canary
          baseurl=https://stuckj.github.io/mkvdup/yum-canary
          enabled=1
          gpgcheck=1
          gpgkey=https://stuckj.github.io/mkvdup/yum-canary/gpg-key.asc
          REPO

          # Install
          sudo dnf install mkvdup-canary</pre>

            <h2>Links</h2>
            <ul>
              <li><a href="https://github.com/stuckj/mkvdup">GitHub Repository</a></li>
              <li><a href="https://github.com/stuckj/mkvdup/releases">Release Downloads</a></li>
            </ul>
          </body>
          </html>
          EOF

      - name: Commit and push to gh-pages
        run: |
          cd gh-pages
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git diff --staged --quiet || git commit -m "Update packages for ${{ needs.prepare.outputs.tag }}"
          git push origin gh-pages
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
