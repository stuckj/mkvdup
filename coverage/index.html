
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mkvdup: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/stuckj/mkvdup/cmd/mkvdup/commands.go (35.1%)</option>
				
				<option value="file1">github.com/stuckj/mkvdup/cmd/mkvdup/main.go (9.3%)</option>
				
				<option value="file2">github.com/stuckj/mkvdup/cmd/mkvdup/profile.go (33.3%)</option>
				
				<option value="file3">github.com/stuckj/mkvdup/internal/daemon/daemon.go (37.3%)</option>
				
				<option value="file4">github.com/stuckj/mkvdup/internal/dedup/config.go (94.4%)</option>
				
				<option value="file5">github.com/stuckj/mkvdup/internal/dedup/format.go (75.0%)</option>
				
				<option value="file6">github.com/stuckj/mkvdup/internal/dedup/reader.go (81.7%)</option>
				
				<option value="file7">github.com/stuckj/mkvdup/internal/dedup/writer.go (82.9%)</option>
				
				<option value="file8">github.com/stuckj/mkvdup/internal/fuse/adapters.go (60.6%)</option>
				
				<option value="file9">github.com/stuckj/mkvdup/internal/fuse/fs.go (80.0%)</option>
				
				<option value="file10">github.com/stuckj/mkvdup/internal/fuse/permissions.go (78.3%)</option>
				
				<option value="file11">github.com/stuckj/mkvdup/internal/fuse/tree.go (96.9%)</option>
				
				<option value="file12">github.com/stuckj/mkvdup/internal/matcher/matcher.go (91.4%)</option>
				
				<option value="file13">github.com/stuckj/mkvdup/internal/mkv/ebml.go (89.4%)</option>
				
				<option value="file14">github.com/stuckj/mkvdup/internal/mkv/parser.go (56.8%)</option>
				
				<option value="file15">github.com/stuckj/mkvdup/internal/mmap/mmap.go (93.5%)</option>
				
				<option value="file16">github.com/stuckj/mkvdup/internal/source/audio.go (85.2%)</option>
				
				<option value="file17">github.com/stuckj/mkvdup/internal/source/codec.go (72.9%)</option>
				
				<option value="file18">github.com/stuckj/mkvdup/internal/source/indexer.go (81.0%)</option>
				
				<option value="file19">github.com/stuckj/mkvdup/internal/source/mpegps.go (82.3%)</option>
				
				<option value="file20">github.com/stuckj/mkvdup/internal/source/source.go (77.5%)</option>
				
				<option value="file21">github.com/stuckj/mkvdup/internal/source/video.go (96.2%)</option>
				
				<option value="file22">github.com/stuckj/mkvdup/testdata/testdata.go (45.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bytes"
        "fmt"
        "io"
        "log"
        "log/syslog"
        "os"
        "os/signal"
        "path"
        "path/filepath"
        "slices"
        "sort"
        "strconv"
        "strings"
        "syscall"
        "time"

        "github.com/cespare/xxhash/v2"
        "github.com/hanwen/go-fuse/v2/fs"
        "github.com/hanwen/go-fuse/v2/fuse"
        "github.com/stuckj/mkvdup/internal/daemon"
        "github.com/stuckj/mkvdup/internal/dedup"
        mkvfuse "github.com/stuckj/mkvdup/internal/fuse"
        "github.com/stuckj/mkvdup/internal/matcher"
        "github.com/stuckj/mkvdup/internal/mkv"
        "github.com/stuckj/mkvdup/internal/source"
)

// formatInt formats an integer with thousands separators (e.g., 1234567 → "1,234,567").
func formatInt(n int64) string <span class="cov6" title="38">{
        s := strconv.FormatInt(n, 10)
        if len(s) &lt;= 3 </span><span class="cov6" title="24">{
                return s
        }</span>
        // Insert commas from the right
        <span class="cov5" title="14">var result []byte
        for i, c := range s </span><span class="cov8" title="92">{
                if i &gt; 0 &amp;&amp; (len(s)-i)%3 == 0 </span><span class="cov6" title="24">{
                        result = append(result, ',')
                }</span>
                <span class="cov8" title="92">result = append(result, byte(c))</span>
        }
        <span class="cov5" title="14">return string(result)</span>
}

// createResult holds per-file statistics from a create operation.
type createResult struct {
        MkvPath        string
        OutputPath     string
        VirtualName    string
        MkvSize        int64
        DedupSize      int64
        MatchedBytes   int64
        UnmatchedBytes int64
        MatchedPackets int
        TotalPackets   int
        IndexEntries   int
        Savings        float64
        Duration       time.Duration
        Err            error
}

// buildSourceIndex indexes a source directory and returns the indexer and index.
// This is the expensive step that should only happen once in batch mode.
func buildSourceIndex(sourceDir string) (*source.Indexer, *source.Index, error) <span class="cov2" title="2">{
        indexer, err := source.NewIndexer(sourceDir, source.DefaultWindowSize)
        if err != nil </span><span class="cov2" title="2">{
                return nil, nil, fmt.Errorf("create indexer: %w", err)
        }</span>

        <span class="cov0" title="0">start := time.Now()
        lastProgress := time.Now()
        err = indexer.Build(func(processed, total int64) </span><span class="cov0" title="0">{
                if time.Since(lastProgress) &gt; 500*time.Millisecond </span><span class="cov0" title="0">{
                        pct := float64(processed) / float64(total) * 100
                        fmt.Printf("\r  Progress: %.1f%%", pct)
                        lastProgress = time.Now()
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("build index: %w", err)
        }</span>
        <span class="cov0" title="0">index := indexer.Index()
        fmt.Printf("\r  Indexed %d hashes in %v                    \n", len(index.HashToLocations), time.Since(start))

        return indexer, index, nil</span>
}

// checkCodecCompatibility detects source codecs and compares them against MKV tracks.
// If mismatches are found, it prints a warning and either prompts the user (interactive)
// or continues automatically (non-interactive). Returns an error if the user declines.
func checkCodecCompatibility(tracks []mkv.Track, index *source.Index, nonInteractive bool) error <span class="cov0" title="0">{
        sourceCodecs, err := source.DetectSourceCodecs(index)
        if err != nil </span><span class="cov0" title="0">{
                // Detection failure is not fatal — just skip the check
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("  Note: could not detect source codecs: %v\n", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">mismatches := source.CheckCodecCompatibility(tracks, sourceCodecs)
        if len(mismatches) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Print warning
        <span class="cov0" title="0">fmt.Println()
        fmt.Println("  WARNING: Codec mismatch detected")
        for _, m := range mismatches </span><span class="cov0" title="0">{
                mkvName := source.CodecTypeName(m.MKVCodecType)
                var sourceNames []string
                for _, sc := range m.SourceCodecs </span><span class="cov0" title="0">{
                        sourceNames = append(sourceNames, source.CodecTypeName(sc))
                }</span>
                <span class="cov0" title="0">fmt.Printf("    MKV %s:    %s (%s)\n", m.TrackType, mkvName, m.MKVCodecID)
                fmt.Printf("    Source %s: %s\n", m.TrackType, strings.Join(sourceNames, ", "))</span>
        }
        <span class="cov0" title="0">fmt.Println()
        fmt.Println("  Deduplication may produce poor results if the MKV was transcoded.")

        // Determine if we should prompt
        if nonInteractive || !isTerminal() </span><span class="cov0" title="0">{
                fmt.Println("  Continuing (non-interactive mode)...")
                fmt.Println()
                return nil
        }</span>

        // Interactive prompt
        <span class="cov0" title="0">fmt.Print("\n  Continue anyway? [y/N]: ")
        var response string
        fmt.Scanln(&amp;response)
        response = strings.TrimSpace(strings.ToLower(response))
        if response != "y" &amp;&amp; response != "yes" </span><span class="cov0" title="0">{
                return fmt.Errorf("aborted due to codec mismatch")
        }</span>
        <span class="cov0" title="0">fmt.Println()
        return nil</span>
}

// isTerminal returns true if stdin is a terminal (not piped).
func isTerminal() bool <span class="cov0" title="0">{
        fi, err := os.Stdin.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return fi.Mode()&amp;os.ModeCharDevice != 0</span>
}

// createDedupWithIndex processes a single MKV using a pre-built source index.
// It handles parsing, matching, writing, and verification.
// If nonInteractive is true, codec mismatch warnings do not prompt the user.
func createDedupWithIndex(mkvPath, sourceDir, outputPath, virtualName string,
        indexer *source.Indexer, index *source.Index, nonInteractive bool) *createResult <span class="cov0" title="0">{
        start := time.Now()
        result := &amp;createResult{
                MkvPath:     mkvPath,
                OutputPath:  outputPath,
                VirtualName: virtualName,
        }

        // Parse MKV
        fmt.Println("  Parsing MKV file...")
        parser, err := mkv.NewParser(mkvPath)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("create parser: %w", err)
                return result
        }</span>
        <span class="cov0" title="0">defer parser.Close()

        parseStart := time.Now()
        if err := parser.Parse(nil); err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("parse MKV: %w", err)
                return result
        }</span>
        <span class="cov0" title="0">fmt.Printf("    Parsed %d packets in %v\n", parser.PacketCount(), time.Since(parseStart))

        // Check codec compatibility
        if err := checkCodecCompatibility(parser.Tracks(), index, nonInteractive); err != nil </span><span class="cov0" title="0">{
                result.Err = err
                return result
        }</span>

        // Calculate MKV checksum
        <span class="cov0" title="0">fmt.Print("    Calculating MKV checksum...")
        mkvChecksum, err := calculateFileChecksum(mkvPath)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("calculate MKV checksum: %w", err)
                return result
        }</span>
        <span class="cov0" title="0">fmt.Printf(" done\n")

        // Match packets
        fmt.Println("  Matching packets...")
        m, err := matcher.NewMatcher(index)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("create matcher: %w", err)
                return result
        }</span>
        <span class="cov0" title="0">defer m.Close()

        matchStart := time.Now()
        lastProgress := time.Now()
        matchResult, err := m.Match(mkvPath, parser.Packets(), parser.Tracks(), func(processed, total int) </span><span class="cov0" title="0">{
                if time.Since(lastProgress) &gt; 500*time.Millisecond </span><span class="cov0" title="0">{
                        pct := float64(processed) / float64(total) * 100
                        fmt.Printf("\r    Progress: %.1f%% (%d/%d packets)", pct, processed, total)
                        lastProgress = time.Now()
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("match: %w", err)
                return result
        }</span>
        <span class="cov0" title="0">fmt.Printf("\r    Matched in %v                              \n", time.Since(matchStart))

        // Write dedup file
        fmt.Println("  Writing dedup file...")
        writeStart := time.Now()

        writer, err := dedup.NewWriter(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("create dedup writer: %w", err)
                return result
        }</span>
        <span class="cov0" title="0">defer writer.Close()

        writer.SetHeader(parser.Size(), mkvChecksum, indexer.SourceType())
        writer.SetSourceFiles(index.Files)

        // Convert ES offsets to raw offsets if we have ES readers (DVD sources)
        var esConverters []source.ESRangeConverter
        if index.UsesESOffsets &amp;&amp; len(index.ESReaders) &gt; 0 </span><span class="cov0" title="0">{
                esConverters = make([]source.ESRangeConverter, len(index.ESReaders))
                for i, r := range index.ESReaders </span><span class="cov0" title="0">{
                        if converter, ok := r.(source.ESRangeConverter); ok </span><span class="cov0" title="0">{
                                esConverters[i] = converter
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := writer.SetMatchResult(matchResult, esConverters); err != nil </span><span class="cov0" title="0">{
                os.Remove(outputPath)
                result.Err = fmt.Errorf("set match result: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">lastProgress = time.Time{}
        if err := writer.WriteWithProgress(func(written, total int64) </span><span class="cov0" title="0">{
                if time.Since(lastProgress) &gt; 500*time.Millisecond </span><span class="cov0" title="0">{
                        pct := float64(written) / float64(total) * 100
                        fmt.Printf("\r    Progress: %.1f%% (%s/%s bytes)", pct, formatInt(written), formatInt(total))
                        lastProgress = time.Now()
                }</span>
        }); err != nil <span class="cov0" title="0">{
                os.Remove(outputPath)
                result.Err = fmt.Errorf("write dedup file: %w", err)
                return result
        }</span>
        <span class="cov0" title="0">fmt.Printf("\r    Written in %v                              \n", time.Since(writeStart))

        // Write config file
        configPath := outputPath + ".yaml"
        if err := dedup.WriteConfig(configPath, virtualName, outputPath, sourceDir); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("    Warning: failed to write config file: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("    Config: %s\n", configPath)
        }</span>

        // Verify reconstruction
        <span class="cov0" title="0">fmt.Println("  Verifying reconstruction...")
        verifyStart := time.Now()
        if err := verifyReconstruction(outputPath, sourceDir, mkvPath, index, verbose); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("    WARNING: Verification failed: %v\n", err)
                fmt.Printf("    Keeping files for debugging\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("    Verified in %v\n", time.Since(verifyStart))
        }</span>

        // Populate result
        <span class="cov0" title="0">result.MkvSize = parser.Size()
        result.MatchedBytes = matchResult.MatchedBytes
        result.UnmatchedBytes = matchResult.UnmatchedBytes
        result.MatchedPackets = matchResult.MatchedPackets
        result.TotalPackets = matchResult.TotalPackets
        result.IndexEntries = len(matchResult.Entries)

        dedupInfo, _ := os.Stat(outputPath)
        if dedupInfo != nil </span><span class="cov0" title="0">{
                result.DedupSize = dedupInfo.Size()
                result.Savings = float64(result.MkvSize-result.DedupSize) / float64(result.MkvSize) * 100
        }</span>
        <span class="cov0" title="0">result.Duration = time.Since(start)

        return result</span>
}

// createDedup creates a .mkvdup file from an MKV and source directory.
func createDedup(mkvPath, sourceDir, outputPath, virtualName string, warnThreshold float64, quiet bool, nonInteractive bool) error <span class="cov0" title="0">{
        totalStart := time.Now()

        // Default output path
        if outputPath == "" </span><span class="cov0" title="0">{
                outputPath = mkvPath + ".mkvdup"
        }</span>

        // Default virtual name
        <span class="cov0" title="0">if virtualName == "" </span><span class="cov0" title="0">{
                virtualName = filepath.Base(mkvPath)
        }</span>

        <span class="cov0" title="0">fmt.Println("Creating dedup file...")
        fmt.Printf("  MKV:     %s\n", mkvPath)
        fmt.Printf("  Source:  %s\n", sourceDir)
        fmt.Printf("  Output:  %s\n", outputPath)
        fmt.Println()

        // Phase 1: Index source
        fmt.Println("Indexing source...")
        indexer, index, err := buildSourceIndex(sourceDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer index.Close()

        // Phase 2-5: Process MKV
        fmt.Println()
        result := createDedupWithIndex(mkvPath, sourceDir, outputPath, virtualName, indexer, index, nonInteractive)
        if result.Err != nil </span><span class="cov0" title="0">{
                return result.Err
        }</span>

        // Summary
        <span class="cov0" title="0">fmt.Println()
        fmt.Println("=== Results ===")
        fmt.Printf("Total time: %v\n", time.Since(totalStart))
        fmt.Println()

        fmt.Printf("MKV file size:      %s bytes (%.2f MB)\n", formatInt(result.MkvSize), float64(result.MkvSize)/(1024*1024))
        fmt.Printf("Matched bytes:      %s bytes (%.2f MB, %.1f%%)\n",
                formatInt(result.MatchedBytes), float64(result.MatchedBytes)/(1024*1024),
                float64(result.MatchedBytes)/float64(result.MkvSize)*100)
        fmt.Printf("Delta (unmatched):  %s bytes (%.2f MB, %.1f%%)\n",
                formatInt(result.UnmatchedBytes), float64(result.UnmatchedBytes)/(1024*1024),
                float64(result.UnmatchedBytes)/float64(result.MkvSize)*100)
        fmt.Println()

        fmt.Printf("Dedup file size:    %s bytes (%.2f MB)\n", formatInt(result.DedupSize), float64(result.DedupSize)/(1024*1024))
        fmt.Printf("Space savings:      %.1f%%\n", result.Savings)
        fmt.Println()

        fmt.Printf("Packets matched:    %s / %s (%.1f%%)\n",
                formatInt(int64(result.MatchedPackets)), formatInt(int64(result.TotalPackets)),
                float64(result.MatchedPackets)/float64(result.TotalPackets)*100)
        fmt.Printf("Index entries:      %s\n", formatInt(int64(result.IndexEntries)))

        // Warning for low savings
        if !quiet &amp;&amp; result.Savings &lt; warnThreshold </span><span class="cov0" title="0">{
                fmt.Println()
                fmt.Printf("WARNING: Space savings (%.1f%%) below %.0f%%\n", result.Savings, warnThreshold)
                fmt.Println("  This may indicate wrong source or transcoded MKV.")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createBatch processes multiple MKVs from a batch manifest, indexing the source once.
func createBatch(manifestPath string, warnThreshold float64, quiet bool) error <span class="cov3" title="6">{
        totalStart := time.Now()

        manifest, err := dedup.ReadBatchManifest(manifestPath)
        if err != nil </span><span class="cov3" title="4">{
                return err
        }</span>

        <span class="cov2" title="2">fmt.Printf("Batch create: %d files from %s\n\n", len(manifest.Files), manifest.SourceDir)

        // Index source once
        fmt.Println("Indexing source directory...")
        indexer, index, err := buildSourceIndex(manifest.SourceDir)
        if err != nil </span><span class="cov2" title="2">{
                return err
        }</span>
        <span class="cov0" title="0">defer index.Close()
        indexDuration := time.Since(totalStart)

        // Process each file
        results := make([]*createResult, len(manifest.Files))
        for i, f := range manifest.Files </span><span class="cov0" title="0">{
                fmt.Printf("\n[%d/%d] %s\n", i+1, len(manifest.Files), filepath.Base(f.MKV))
                results[i] = createDedupWithIndex(f.MKV, manifest.SourceDir, f.Output, f.Name, indexer, index, true)
                if results[i].Err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  ERROR: %v\n", results[i].Err)
                        if i &lt; len(manifest.Files)-1 </span><span class="cov0" title="0">{
                                fmt.Println("  Continuing with remaining files...")
                        }</span>
                }
        }

        // Print summary
        <span class="cov0" title="0">printBatchSummary(results, indexDuration, totalStart, warnThreshold, quiet)

        // Return error if any file failed
        for _, r := range results </span><span class="cov0" title="0">{
                if r.Err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("batch create completed with errors")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// printBatchSummary prints the aggregate results of a batch create operation.
func printBatchSummary(results []*createResult, indexDuration time.Duration, totalStart time.Time, warnThreshold float64, quiet bool) <span class="cov4" title="10">{
        fmt.Println()
        fmt.Println("=== Batch Results ===")
        fmt.Printf("Total time: %v (indexing: %v)\n\n", time.Since(totalStart), indexDuration)

        succeeded := 0
        var lowSavings []string
        for _, r := range results </span><span class="cov5" title="16">{
                base := filepath.Base(r.MkvPath)
                if r.Err != nil </span><span class="cov2" title="2">{
                        fmt.Printf("  FAIL  %s: %v\n", base, r.Err)
                }</span> else<span class="cov5" title="14"> {
                        fmt.Printf("  OK    %s -&gt; %s (%.1f%% savings)\n", base, filepath.Base(r.OutputPath), r.Savings)
                        succeeded++
                        if r.Savings &lt; warnThreshold </span><span class="cov3" title="6">{
                                lowSavings = append(lowSavings, fmt.Sprintf("  %s: %.1f%% savings", base, r.Savings))
                        }</span>
                }
        }
        <span class="cov4" title="10">fmt.Printf("\nSucceeded: %d/%d\n", succeeded, len(results))

        if !quiet &amp;&amp; len(lowSavings) &gt; 0 </span><span class="cov3" title="4">{
                fmt.Printf("\nWARNING: %d file(s) with space savings below %.0f%%:\n", len(lowSavings), warnThreshold)
                for _, s := range lowSavings </span><span class="cov3" title="4">{
                        fmt.Println(s)
                }</span>
                <span class="cov3" title="4">fmt.Println("  This may indicate wrong source or transcoded MKV.")</span>
        }
}

// verifyReconstruction verifies that the dedup file can reconstruct the original MKV.
// Set verbose=true to enable debug output for troubleshooting.
func verifyReconstruction(dedupPath, sourceDir, originalPath string, index *source.Index, verbose bool) error <span class="cov0" title="0">{
        reader, err := dedup.NewReader(dedupPath, sourceDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open dedup file: %w", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Set ES reader if this is an ES-based source
        if reader.UsesESOffsets() &amp;&amp; len(index.ESReaders) &gt; 0 </span><span class="cov0" title="0">{
                reader.SetESReader(index.ESReaders[0])
        }</span> else<span class="cov0" title="0"> {
                // Load raw source files
                if err := reader.LoadSourceFiles(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("load source files: %w", err)
                }</span>
        }

        // Open original MKV
        <span class="cov0" title="0">original, err := os.Open(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open original: %w", err)
        }</span>
        <span class="cov0" title="0">defer original.Close()

        // Debug: show first few bytes comparison (controlled by verbose flag)
        if verbose </span><span class="cov0" title="0">{
                origFirst := make([]byte, 32)
                reconFirst := make([]byte, 32)
                n, _ := original.ReadAt(origFirst, 0)
                fmt.Printf("  Debug: Original ReadAt(32, 0) returned %d bytes\n", n)
                n, _ = reader.ReadAt(reconFirst, 0)
                fmt.Printf("  Debug: Reader ReadAt(32, 0) returned %d bytes\n", n)
                fmt.Printf("  Debug: Original first 32 bytes:      %x\n", origFirst)
                fmt.Printf("  Debug: Reconstructed first 32 bytes: %x\n", reconFirst)
                original.Seek(0, 0) // Reset file position
        }</span>

        // Compare chunk by chunk
        <span class="cov0" title="0">const chunkSize = 1024 * 1024 // 1MB
        originalBuf := make([]byte, chunkSize)
        reconstructedBuf := make([]byte, chunkSize)

        var offset int64
        for </span><span class="cov0" title="0">{
                n1, err1 := original.Read(originalBuf)
                n2, err2 := reader.ReadAt(reconstructedBuf[:n1], offset)

                if verbose &amp;&amp; offset == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("  Debug: Loop first read - n1=%d, n2=%d, err1=%v, err2=%v\n", n1, n2, err1, err2)
                        fmt.Printf("  Debug: originalBuf first 32:      %x\n", originalBuf[:32])
                        fmt.Printf("  Debug: reconstructedBuf first 32: %x\n", reconstructedBuf[:32])
                }</span>

                <span class="cov0" title="0">if n1 != n2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("size mismatch at offset %d: original=%d, reconstructed=%d", offset, n1, n2)
                }</span>

                <span class="cov0" title="0">if !bytes.Equal(originalBuf[:n1], reconstructedBuf[:n2]) </span><span class="cov0" title="0">{
                        // Find first mismatch
                        for i := 0; i &lt; n1; i++ </span><span class="cov0" title="0">{
                                if originalBuf[i] != reconstructedBuf[i] </span><span class="cov0" title="0">{
                                        return fmt.Errorf("data mismatch at offset %d (orig: %02x, recon: %02x)",
                                                offset+int64(i), originalBuf[i], reconstructedBuf[i])
                                }</span>
                        }
                }

                <span class="cov0" title="0">offset += int64(n1)

                if err1 == io.EOF &amp;&amp; err2 == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err1 == io.EOF || err2 == io.EOF </span><span class="cov0" title="0">{
                        return fmt.Errorf("EOF mismatch at offset %d", offset)
                }</span>
                <span class="cov0" title="0">if err1 != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("read original at %d: %w", offset, err1)
                }</span>
                <span class="cov0" title="0">if err2 != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("read reconstructed at %d: %w", offset, err2)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// showInfo displays information about a dedup file.
func showInfo(dedupPath string) error <span class="cov0" title="0">{
        reader, err := dedup.NewReader(dedupPath, "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open dedup file: %w", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        info := reader.Info()

        fmt.Printf("Dedup file: %s\n", dedupPath)
        fmt.Println()
        fmt.Printf("Format version:     %d\n", info["version"].(uint32))
        fmt.Printf("Original MKV size:  %s bytes (%.2f MB)\n",
                formatInt(info["original_size"].(int64)),
                float64(info["original_size"].(int64))/(1024*1024))
        fmt.Printf("Original checksum:  %016x\n", info["original_checksum"].(uint64))
        fmt.Println()

        sourceType := "Unknown"
        switch info["source_type"].(uint8) </span>{
        case 0:<span class="cov0" title="0">
                sourceType = "DVD"</span>
        case 1:<span class="cov0" title="0">
                sourceType = "Blu-ray"</span>
        }
        <span class="cov0" title="0">fmt.Printf("Source type:        %s\n", sourceType)
        fmt.Printf("Uses ES offsets:    %v\n", info["uses_es_offsets"].(bool))
        fmt.Printf("Source file count:  %d\n", info["source_file_count"].(int))
        fmt.Printf("Index entry count:  %d\n", info["entry_count"].(int))
        fmt.Printf("Delta size:         %s bytes (%.2f MB)\n",
                formatInt(info["delta_size"].(int64)),
                float64(info["delta_size"].(int64))/(1024*1024))
        fmt.Println()

        // Source files
        fmt.Println("Source files:")
        for _, sf := range reader.SourceFiles() </span><span class="cov0" title="0">{
                fmt.Printf("  %s (%s bytes)\n", sf.RelativePath, formatInt(sf.Size))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// verifyDedup verifies a dedup file against the original MKV.
func verifyDedup(dedupPath, sourceDir, originalPath string) error <span class="cov0" title="0">{
        fmt.Printf("Verifying dedup file: %s\n", dedupPath)
        fmt.Printf("Source directory:     %s\n", sourceDir)
        fmt.Printf("Original MKV:         %s\n", originalPath)
        fmt.Println()

        // Open dedup file
        reader, err := dedup.NewReader(dedupPath, sourceDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open dedup file: %w", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Verify internal checksums
        fmt.Print("Verifying dedup file checksums...")
        if err := reader.VerifyIntegrity(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(" FAILED")
                return fmt.Errorf("integrity check: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(" OK")

        // For ES-based sources, we need to set up the ES reader
        if reader.UsesESOffsets() </span><span class="cov0" title="0">{
                // Create indexer to get ES reader
                indexer, err := source.NewIndexer(sourceDir, source.DefaultWindowSize)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create indexer: %w", err)
                }</span>
                <span class="cov0" title="0">if err := indexer.Build(nil); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("build index: %w", err)
                }</span>
                <span class="cov0" title="0">index := indexer.Index()
                defer index.Close()

                if len(index.ESReaders) &gt; 0 </span><span class="cov0" title="0">{
                        reader.SetESReader(index.ESReaders[0])
                }</span>
        } else<span class="cov0" title="0"> {
                // Load source files for raw access
                if err := reader.LoadSourceFiles(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("load source files: %w", err)
                }</span>
        }

        // Verify source file sizes
        <span class="cov0" title="0">fmt.Print("Verifying source files...")
        for _, sf := range reader.SourceFiles() </span><span class="cov0" title="0">{
                path := filepath.Join(sourceDir, sf.RelativePath)
                stat, err := os.Stat(path)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(" FAILED")
                        return fmt.Errorf("source file %s: %w", sf.RelativePath, err)
                }</span>
                <span class="cov0" title="0">if stat.Size() != sf.Size </span><span class="cov0" title="0">{
                        fmt.Println(" FAILED")
                        return fmt.Errorf("source file %s size mismatch: expected %d, got %d",
                                sf.RelativePath, sf.Size, stat.Size())
                }</span>
        }
        <span class="cov0" title="0">fmt.Println(" OK")

        // Verify reconstruction matches original
        fmt.Print("Verifying reconstruction...")
        original, err := os.Open(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(" FAILED")
                return fmt.Errorf("open original: %w", err)
        }</span>
        <span class="cov0" title="0">defer original.Close()

        const chunkSize = 4 * 1024 * 1024
        originalBuf := make([]byte, chunkSize)
        reconstructedBuf := make([]byte, chunkSize)
        var offset int64
        totalSize := reader.OriginalSize()

        for offset &lt; totalSize </span><span class="cov0" title="0">{
                remaining := totalSize - offset
                readSize := int64(chunkSize)
                if readSize &gt; remaining </span><span class="cov0" title="0">{
                        readSize = remaining
                }</span>

                <span class="cov0" title="0">n1, err1 := original.Read(originalBuf[:readSize])
                n2, err2 := reader.ReadAt(reconstructedBuf[:readSize], offset)

                if n1 != n2 </span><span class="cov0" title="0">{
                        fmt.Println(" FAILED")
                        return fmt.Errorf("size mismatch at offset %d", offset)
                }</span>

                <span class="cov0" title="0">if !bytes.Equal(originalBuf[:n1], reconstructedBuf[:n2]) </span><span class="cov0" title="0">{
                        fmt.Println(" FAILED")
                        for i := 0; i &lt; n1; i++ </span><span class="cov0" title="0">{
                                if originalBuf[i] != reconstructedBuf[i] </span><span class="cov0" title="0">{
                                        return fmt.Errorf("data mismatch at offset %d", offset+int64(i))
                                }</span>
                        }
                }

                <span class="cov0" title="0">if err1 != nil &amp;&amp; err1 != io.EOF </span><span class="cov0" title="0">{
                        fmt.Println(" FAILED")
                        return fmt.Errorf("read original: %w", err1)
                }</span>
                <span class="cov0" title="0">if err2 != nil &amp;&amp; err2 != io.EOF </span><span class="cov0" title="0">{
                        fmt.Println(" FAILED")
                        return fmt.Errorf("read reconstructed: %w", err2)
                }</span>

                <span class="cov0" title="0">offset += int64(n1)

                // Progress
                pct := float64(offset) / float64(totalSize) * 100
                fmt.Printf("\rVerifying reconstruction... %.1f%%", pct)</span>
        }
        <span class="cov0" title="0">fmt.Println(" OK")

        fmt.Println()
        fmt.Println("Verification PASSED")
        return nil</span>
}

// calculateFileChecksum calculates xxhash checksum of a file.
func calculateFileChecksum(path string) (uint64, error) <span class="cov5" title="12">{
        return calculateFileChecksumWithProgress(path, 0, "")
}</span>

// calculateFileChecksumWithProgress calculates xxhash checksum of a file,
// showing inline progress when expectedSize &gt; 0.
func calculateFileChecksumWithProgress(path string, expectedSize int64, displayName string) (uint64, error) <span class="cov5" title="16">{
        f, err := os.Open(path)
        if err != nil </span><span class="cov2" title="2">{
                return 0, err
        }</span>
        <span class="cov5" title="14">defer f.Close()

        hasher := xxhash.New()
        showProgress := expectedSize &gt; 0

        if !showProgress </span><span class="cov4" title="10">{
                if _, err := io.Copy(hasher, f); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov4" title="10">return hasher.Sum64(), nil</span>
        }

        <span class="cov3" title="4">buf := make([]byte, 4*1024*1024) // 4MB buffer
        var processed int64
        lastProgress := time.Time{}

        for </span><span class="cov4" title="8">{
                n, err := f.Read(buf)
                if n &gt; 0 </span><span class="cov3" title="4">{
                        if _, werr := hasher.Write(buf[:n]); werr != nil </span><span class="cov0" title="0">{
                                return 0, werr
                        }</span>
                        <span class="cov3" title="4">processed += int64(n)

                        if time.Since(lastProgress) &gt; 500*time.Millisecond </span><span class="cov3" title="4">{
                                pct := float64(processed) / float64(expectedSize) * 100
                                fmt.Printf("\r  Verifying %s... %.1f%%", displayName, pct)
                                lastProgress = time.Now()
                        }</span>
                }
                <span class="cov4" title="8">if err == io.EOF </span><span class="cov3" title="4">{
                        break</span>
                }
                <span class="cov3" title="4">if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        // Clear progress line
        <span class="cov3" title="4">progressText := fmt.Sprintf("  Verifying %s... 100.0%%", displayName)
        fmt.Printf("\r%s\r", strings.Repeat(" ", len(progressText)))

        return hasher.Sum64(), nil</span>
}

// checkDedup checks the integrity of a dedup file and its source files.
func checkDedup(dedupPath, sourceDir string, sourceChecksums bool) error <span class="cov5" title="16">{
        fmt.Printf("Checking dedup file: %s\n", dedupPath)
        fmt.Printf("Source directory:    %s\n", sourceDir)
        fmt.Println()

        // Phase 1: Open and verify dedup file integrity
        reader, err := dedup.NewReader(dedupPath, sourceDir)
        if err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("open dedup file: %w", err)
        }</span>
        <span class="cov5" title="14">defer reader.Close()

        fmt.Print("Checking dedup file integrity...")
        if err := reader.VerifyIntegrity(); err != nil </span><span class="cov2" title="2">{
                fmt.Println(" FAILED")
                return fmt.Errorf("integrity check: %w", err)
        }</span>
        <span class="cov5" title="12">fmt.Println(" OK")

        // Phase 2: Check source files exist with correct sizes
        sourceFiles := reader.SourceFiles()
        fmt.Printf("\nChecking source files (%d files)...\n", len(sourceFiles))

        errCount := 0
        for _, sf := range sourceFiles </span><span class="cov5" title="12">{
                sfPath := filepath.Join(sourceDir, sf.RelativePath)
                stat, err := os.Stat(sfPath)
                if err != nil </span><span class="cov2" title="2">{
                        fmt.Printf("  FAILED  %s: %v\n", sf.RelativePath, err)
                        errCount++
                        continue</span>
                }
                <span class="cov4" title="10">if stat.Size() != sf.Size </span><span class="cov3" title="4">{
                        fmt.Printf("  FAILED  %s: size mismatch (expected %s, got %s)\n",
                                sf.RelativePath, formatInt(sf.Size), formatInt(stat.Size()))
                        errCount++
                        continue</span>
                }
                <span class="cov3" title="6">fmt.Printf("  OK      %s (%s bytes)\n", sf.RelativePath, formatInt(sf.Size))</span>
        }

        // Phase 3: Optionally verify source file checksums
        <span class="cov5" title="12">if sourceChecksums </span><span class="cov3" title="6">{
                if errCount &gt; 0 </span><span class="cov2" title="2">{
                        fmt.Println("\nSkipping source checksum verification due to earlier errors")
                }</span> else<span class="cov3" title="4"> {
                        fmt.Printf("\nVerifying source file checksums...\n")
                        for _, sf := range sourceFiles </span><span class="cov3" title="4">{
                                sfPath := filepath.Join(sourceDir, sf.RelativePath)

                                checksum, err := calculateFileChecksumWithProgress(sfPath, sf.Size, sf.RelativePath)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("  FAILED  %s: %v\n", sf.RelativePath, err)
                                        errCount++
                                        continue</span>
                                }
                                <span class="cov3" title="4">if checksum != sf.Checksum </span><span class="cov2" title="2">{
                                        fmt.Printf("  FAILED  %s: checksum mismatch (expected %016x, got %016x)\n",
                                                sf.RelativePath, sf.Checksum, checksum)
                                        errCount++
                                        continue</span>
                                }
                                <span class="cov2" title="2">fmt.Printf("  OK      %s\n", sf.RelativePath)</span>
                        }
                }
        }

        // Final summary
        <span class="cov5" title="12">fmt.Println()
        if errCount &gt; 0 </span><span class="cov4" title="8">{
                return fmt.Errorf("check FAILED: %d error(s) found", errCount)
        }</span>
        <span class="cov3" title="4">fmt.Println("Check PASSED")
        return nil</span>
}

// ProbeResult represents the result of probing a source against an MKV.
type ProbeResult struct {
        SourcePath   string
        MatchCount   int
        TotalSamples int
        MatchPercent float64
}

// probe tests if an MKV likely matches one or more source directories.
// This is a fast test (targeting &lt;30 seconds) for quickly identifying which
// source directory an MKV came from, useful for multi-disc sets.
func probe(mkvPath string, sourceDirs []string) error <span class="cov0" title="0">{
        fmt.Printf("Probing %s against %d source(s)...\n", filepath.Base(mkvPath), len(sourceDirs))
        fmt.Println()

        // Phase 1: Parse MKV and sample packets
        fmt.Println("Parsing MKV and sampling packets...")
        parser, err := mkv.NewParser(mkvPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create parser: %w", err)
        }</span>
        <span class="cov0" title="0">defer parser.Close()

        if err := parser.Parse(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse MKV: %w", err)
        }</span>

        <span class="cov0" title="0">packets := parser.Packets()
        if len(packets) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no packets found in MKV")
        }</span>

        // Build track type map
        <span class="cov0" title="0">trackTypes := make(map[int]int)
        for _, t := range parser.Tracks() </span><span class="cov0" title="0">{
                trackTypes[int(t.Number)] = t.Type
        }</span>

        // Sample packets from different positions
        // 5 from first 10%, 10 from middle 80%, 5 from last 10%
        <span class="cov0" title="0">samples := samplePackets(packets, 20)
        fmt.Printf("  Sampled %d packets from %d total\n", len(samples), len(packets))

        // Read packet data and compute hashes using the shared sync point detection
        mkvFile, err := os.Open(mkvPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open MKV: %w", err)
        }</span>
        <span class="cov0" title="0">defer mkvFile.Close()

        windowSize := source.DefaultWindowSize
        var probeHashes []matcher.ProbeHash

        for _, pkt := range samples </span><span class="cov0" title="0">{
                // Read packet data (up to 4096 bytes like the matcher)
                readSize := pkt.Size
                if readSize &gt; 4096 </span><span class="cov0" title="0">{
                        readSize = 4096
                }</span>
                <span class="cov0" title="0">if readSize &lt; int64(windowSize) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">data := make([]byte, readSize)
                n, err := mkvFile.ReadAt(data, pkt.Offset)
                if err != nil || n &lt; windowSize </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Determine if this is video or audio
                <span class="cov0" title="0">trackType := trackTypes[int(pkt.TrackNum)]
                isVideo := trackType == mkv.TrackTypeVideo

                // Use shared function to extract probe hashes
                hashes := matcher.ExtractProbeHashes(data[:n], isVideo, windowSize)
                if len(hashes) &gt; 0 </span><span class="cov0" title="0">{
                        // Only need one hash per packet for probing
                        probeHashes = append(probeHashes, hashes[0])
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("  Computed %d probe hashes\n", len(probeHashes))
        fmt.Println()

        if len(probeHashes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no valid hashes computed from sampled packets")
        }</span>

        // Phase 2: Test each source directory
        <span class="cov0" title="0">results := make([]ProbeResult, 0, len(sourceDirs))

        for _, sourceDir := range sourceDirs </span><span class="cov0" title="0">{
                fmt.Printf("Indexing source: %s...\n", sourceDir)

                indexer, err := source.NewIndexer(sourceDir, windowSize)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  Error: %v\n", err)
                        results = append(results, ProbeResult{
                                SourcePath:   sourceDir,
                                MatchCount:   0,
                                TotalSamples: len(probeHashes),
                                MatchPercent: 0,
                        })
                        continue</span>
                }

                <span class="cov0" title="0">if err := indexer.Build(nil); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  Error building index: %v\n", err)
                        results = append(results, ProbeResult{
                                SourcePath:   sourceDir,
                                MatchCount:   0,
                                TotalSamples: len(probeHashes),
                                MatchPercent: 0,
                        })
                        continue</span>
                }

                <span class="cov0" title="0">index := indexer.Index()

                // Count matches, respecting video/audio stream type
                matchCount := 0
                for _, ph := range probeHashes </span><span class="cov0" title="0">{
                        if locs, ok := index.HashToLocations[ph.Hash]; ok </span><span class="cov0" title="0">{
                                // For ES-based indexes, check stream type matches
                                if index.UsesESOffsets </span><span class="cov0" title="0">{
                                        for _, loc := range locs </span><span class="cov0" title="0">{
                                                if loc.IsVideo == ph.IsVideo </span><span class="cov0" title="0">{
                                                        matchCount++
                                                        break</span>
                                                }
                                        }
                                } else<span class="cov0" title="0"> if len(locs) &gt; 0 </span><span class="cov0" title="0">{
                                        matchCount++
                                }</span>
                        }
                }

                <span class="cov0" title="0">index.Close()

                matchPercent := float64(matchCount) / float64(len(probeHashes)) * 100
                results = append(results, ProbeResult{
                        SourcePath:   sourceDir,
                        MatchCount:   matchCount,
                        TotalSamples: len(probeHashes),
                        MatchPercent: matchPercent,
                })

                fmt.Printf("  Matched %d/%d hashes (%.0f%%)\n", matchCount, len(probeHashes), matchPercent)</span>
        }

        // Sort results by match percentage (descending)
        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                return results[i].MatchPercent &gt; results[j].MatchPercent
        }</span>)

        // Print summary
        <span class="cov0" title="0">fmt.Println()
        fmt.Println("=== Results ===")
        fmt.Println()

        for _, r := range results </span><span class="cov0" title="0">{
                indicator := ""
                if r.MatchPercent &gt;= 80 </span><span class="cov0" title="0">{
                        indicator = " ← likely match"
                }</span> else<span class="cov0" title="0"> if r.MatchPercent &gt;= 40 </span><span class="cov0" title="0">{
                        indicator = " ← possible match"
                }</span>
                <span class="cov0" title="0">fmt.Printf("  %s  %d/%d matches (%.0f%%)%s\n",
                        r.SourcePath, r.MatchCount, r.TotalSamples, r.MatchPercent, indicator)</span>
        }

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("Interpretation:")
        fmt.Println("  80-100%: Very likely the correct source")
        fmt.Println("  40-80%:  Possible match (may be partial content)")
        fmt.Println("  &lt;40%:    Unlikely to be the source")

        return nil</span>
}

// samplePackets selects N packets distributed across the file:
// - 25% from first 10% of packets (early content)
// - 50% from middle 80% of packets (main content)
// - 25% from last 10% of packets (late content)
func samplePackets(packets []mkv.Packet, n int) []mkv.Packet <span class="cov6" title="34">{
        if len(packets) &lt;= n </span><span class="cov5" title="14">{
                return packets
        }</span>

        // Calculate distribution
        <span class="cov5" title="20">earlyCount := n / 4                    // 25% from first 10%
        lateCount := n / 4                     // 25% from last 10%
        midCount := n - earlyCount - lateCount // 50% from middle 80%

        // Calculate packet ranges
        earlyEnd := len(packets) / 10
        lateStart := len(packets) - len(packets)/10
        if earlyEnd &lt; 1 </span><span class="cov2" title="2">{
                earlyEnd = 1
        }</span>
        <span class="cov5" title="20">if lateStart &lt;= earlyEnd </span><span class="cov0" title="0">{
                lateStart = earlyEnd + 1
        }</span>

        <span class="cov5" title="20">samples := make([]mkv.Packet, 0, n)

        // Sample from early portion (first 10%)
        if earlyCount &gt; 0 &amp;&amp; earlyEnd &gt; 0 </span><span class="cov5" title="14">{
                step := earlyEnd / earlyCount
                if step &lt; 1 </span><span class="cov3" title="6">{
                        step = 1
                }</span>
                <span class="cov5" title="14">for i := 0; i &lt; earlyEnd &amp;&amp; len(samples) &lt; earlyCount; i += step </span><span class="cov8" title="112">{
                        samples = append(samples, packets[i])
                }</span>
        }

        // Sample from middle portion (middle 80%)
        <span class="cov5" title="20">midStart := earlyEnd
        midEnd := lateStart
        if midCount &gt; 0 &amp;&amp; midEnd &gt; midStart </span><span class="cov5" title="18">{
                step := (midEnd - midStart) / midCount
                if step &lt; 1 </span><span class="cov0" title="0">{
                        step = 1
                }</span>
                <span class="cov5" title="18">for i := midStart; i &lt; midEnd &amp;&amp; len(samples) &lt; earlyCount+midCount; i += step </span><span class="cov10" title="244">{
                        samples = append(samples, packets[i])
                }</span>
        }

        // Sample from late portion (last 10%)
        <span class="cov5" title="20">if lateCount &gt; 0 &amp;&amp; lateStart &lt; len(packets) </span><span class="cov5" title="12">{
                step := (len(packets) - lateStart) / lateCount
                if step &lt; 1 </span><span class="cov3" title="4">{
                        step = 1
                }</span>
                <span class="cov5" title="12">for i := lateStart; i &lt; len(packets) &amp;&amp; len(samples) &lt; n; i += step </span><span class="cov8" title="110">{
                        samples = append(samples, packets[i])
                }</span>
        }

        <span class="cov5" title="20">return samples</span>
}

// defaultConfigPath is the default config file location.
const defaultConfigPath = "/etc/mkvdup.conf"

// expandConfigDir expands a directory path to a list of .yaml/.yml files it contains.
func expandConfigDir(dir string) ([]string, error) <span class="cov4" title="8">{
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("read config directory %s: %w", dir, err)
        }</span>
        <span class="cov3" title="6">var paths []string
        for _, entry := range entries </span><span class="cov4" title="10">{
                if !entry.IsDir() &amp;&amp; (filepath.Ext(entry.Name()) == ".yaml" || filepath.Ext(entry.Name()) == ".yml") </span><span class="cov4" title="8">{
                        paths = append(paths, filepath.Join(dir, entry.Name()))
                }</span>
        }
        <span class="cov3" title="6">if len(paths) == 0 </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("no YAML files (.yaml, .yml) found in %s", dir)
        }</span>
        <span class="cov3" title="4">return paths, nil</span>
}

// mountFuse mounts a FUSE filesystem exposing dedup files as MKV files.
func mountFuse(mountpoint string, configPaths []string, opts MountOptions) error <span class="cov0" title="0">{
        // Daemonize unless --foreground is set or we're already a daemon child
        if !opts.Foreground &amp;&amp; !daemon.IsChild() </span><span class="cov0" title="0">{
                return daemon.Daemonize(opts.PidFile, opts.DaemonTimeout)
        }</span>

        // Write PID file in foreground mode (daemon mode writes it in Daemonize)
        <span class="cov0" title="0">if opts.Foreground &amp;&amp; opts.PidFile != "" </span><span class="cov0" title="0">{
                if err := daemon.WritePidFile(opts.PidFile, os.Getpid()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("write pid file: %w", err)
                }</span>
        }

        // Clean up PID file on exit (for both foreground and daemon child modes)
        <span class="cov0" title="0">if opts.PidFile != "" &amp;&amp; (opts.Foreground || daemon.IsChild()) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        _ = daemon.RemovePidFile(opts.PidFile)
                }</span>()
        }

        // If no config paths provided, use default
        <span class="cov0" title="0">if len(configPaths) == 0 </span><span class="cov0" title="0">{
                if _, err := os.Stat(defaultConfigPath); err == nil </span><span class="cov0" title="0">{
                        configPaths = []string{defaultConfigPath}
                }</span> else<span class="cov0" title="0"> {
                        if daemon.IsChild() </span><span class="cov0" title="0">{
                                daemon.NotifyError(fmt.Errorf("no config files specified and %s not found", defaultConfigPath))
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("no config files specified and %s not found", defaultConfigPath)</span>
                }
        }

        // Store the config-dir path for SIGHUP re-expansion
        <span class="cov0" title="0">var configDirPath string
        if opts.ConfigDir </span><span class="cov0" title="0">{
                configDirPath = configPaths[0]
        }</span>

        // If configDir is set, expand directory to list of .yaml files
        <span class="cov0" title="0">if opts.ConfigDir </span><span class="cov0" title="0">{
                if len(configPaths) != 1 </span><span class="cov0" title="0">{
                        err := fmt.Errorf("--config-dir requires exactly one directory path, got %d", len(configPaths))
                        if daemon.IsChild() </span><span class="cov0" title="0">{
                                daemon.NotifyError(err)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">expanded, err := expandConfigDir(configPaths[0])
                if err != nil </span><span class="cov0" title="0">{
                        if daemon.IsChild() </span><span class="cov0" title="0">{
                                daemon.NotifyError(err)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">configPaths = expanded</span>
        }

        // Set up permission store
        <span class="cov0" title="0">defaults := mkvfuse.Defaults{
                FileUID:  opts.DefaultUID,
                FileGID:  opts.DefaultGID,
                FileMode: opts.DefaultFileMode,
                DirUID:   opts.DefaultUID,
                DirGID:   opts.DefaultGID,
                DirMode:  opts.DefaultDirMode,
        }
        permPath := mkvfuse.ResolvePermissionsPath(opts.PermissionsFile)
        permStore := mkvfuse.NewPermissionStore(permPath, defaults, verbose)
        if err := permStore.Load(); err != nil </span><span class="cov0" title="0">{
                if daemon.IsChild() </span><span class="cov0" title="0">{
                        daemon.NotifyError(fmt.Errorf("load permissions: %w", err))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("load permissions: %w", err)</span>
        }

        // Create the root filesystem
        <span class="cov0" title="0">root, err := mkvfuse.NewMKVFSWithPermissions(configPaths, verbose, permStore)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("create filesystem: %w", err)
                if daemon.IsChild() </span><span class="cov0" title="0">{
                        daemon.NotifyError(err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Mount the filesystem
        <span class="cov0" title="0">fuseOpts := &amp;fs.Options{
                MountOptions: fuse.MountOptions{
                        AllowOther: opts.AllowOther,
                        Name:       "mkvdup",
                        FsName:     "mkvdup",
                        // Enable kernel permission checks for standard Unix semantics.
                        // This properly handles supplementary groups and matches behavior
                        // of real filesystems (ext4, XFS, btrfs, etc.).
                        Options: []string{"default_permissions"},
                },
        }

        server, err := fs.Mount(mountpoint, root, fuseOpts)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("mount: %w", err)
                if daemon.IsChild() </span><span class="cov0" title="0">{
                        daemon.NotifyError(err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Wait for mount to be ready
        <span class="cov0" title="0">server.WaitMount()

        // If we're a daemon child, signal success and detach from terminal
        if daemon.IsChild() </span><span class="cov0" title="0">{
                if err := daemon.NotifyReady(); err != nil </span><span class="cov0" title="0">{
                        // Parent may have timed out; log and continue since mount succeeded
                        fmt.Fprintf(os.Stderr, "warning: failed to notify parent: %v\n", err)
                }</span>
                <span class="cov0" title="0">daemon.Detach()</span>
        } else<span class="cov0" title="0"> {
                // Running in foreground mode - print info
                fmt.Printf("Mounted at %s\n", mountpoint)
                fmt.Printf("Files:\n")
                for _, configPath := range configPaths </span><span class="cov0" title="0">{
                        config, _ := dedup.ReadConfig(configPath)
                        if config != nil </span><span class="cov0" title="0">{
                                fmt.Printf("  %s\n", config.Name)
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println()
                fmt.Println("Press Ctrl+C to unmount")</span>
        }

        // Set up logging function. In daemon mode, use syslog since
        // stderr is redirected to /dev/null after Detach().
        <span class="cov0" title="0">logFn := func(format string, args ...interface{}) </span><span class="cov0" title="0">{
                log.Printf(format, args...)
        }</span>
        <span class="cov0" title="0">var syslogWriter *syslog.Writer
        if daemon.IsChild() </span><span class="cov0" title="0">{
                if w, err := syslog.New(syslog.LOG_INFO|syslog.LOG_DAEMON, "mkvdup"); err == nil </span><span class="cov0" title="0">{
                        syslogWriter = w
                        logFn = func(format string, args ...interface{}) </span><span class="cov0" title="0">{
                                syslogWriter.Info(fmt.Sprintf(format, args...))
                        }</span>
                }
        }
        <span class="cov0" title="0">if syslogWriter != nil </span><span class="cov0" title="0">{
                // Redirect global log output to syslog so that log.Printf calls
                // from BuildDirectoryTree (during reload) go to syslog too.
                log.SetOutput(syslogWriter)
                log.SetFlags(0) // syslog adds its own timestamp
                defer syslogWriter.Close()
        }</span>

        // Handle signals for graceful shutdown and config reload
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP)

        go func() </span><span class="cov0" title="0">{
                for sig := range sigChan </span><span class="cov0" title="0">{
                        switch sig </span>{
                        case syscall.SIGHUP:<span class="cov0" title="0">
                                logFn("received SIGHUP, reloading config...")

                                // Re-expand config-dir if applicable
                                var reloadPaths []string
                                if configDirPath != "" </span><span class="cov0" title="0">{
                                        expanded, err := expandConfigDir(configDirPath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logFn("reload failed: expand config dir: %v", err)
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">reloadPaths = expanded</span>
                                } else<span class="cov0" title="0"> {
                                        reloadPaths = configPaths
                                }</span>

                                // Resolve configs (expands includes, globs, virtual_files)
                                <span class="cov0" title="0">configs, err := dedup.ResolveConfigs(reloadPaths)
                                if err != nil </span><span class="cov0" title="0">{
                                        logFn("reload failed: resolve configs: %v", err)
                                        continue</span>
                                }

                                // Reload the filesystem
                                <span class="cov0" title="0">if err := root.Reload(configs, logFn); err != nil </span><span class="cov0" title="0">{
                                        logFn("reload failed: %v", err)
                                        continue</span>
                                }

                                <span class="cov0" title="0">logFn("config reloaded successfully")</span>

                        case syscall.SIGINT, syscall.SIGTERM:<span class="cov0" title="0">
                                if !daemon.IsChild() </span><span class="cov0" title="0">{
                                        fmt.Println("\nUnmounting...")
                                }</span>
                                <span class="cov0" title="0">server.Unmount()
                                return</span>
                        }
                }
        }()

        // Serve until unmounted
        <span class="cov0" title="0">server.Wait()

        if !daemon.IsChild() </span><span class="cov0" title="0">{
                fmt.Println("Unmounted")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// reloadDaemon validates config files and sends SIGHUP to the running daemon.
func reloadDaemon(pidFile string, configPaths []string, configDir bool) error <span class="cov3" title="6">{
        // Read PID from file
        pid, err := daemon.ReadPidFile(pidFile)
        if err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        // Verify the process exists (on Unix, FindProcess always succeeds;
        // send signal 0 to check if process is actually running)
        <span class="cov3" title="4">process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("find process %d: %w", pid, err)
        }</span>
        <span class="cov3" title="4">if err := process.Signal(syscall.Signal(0)); err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("daemon process %d is not running: %w", pid, err)
        }</span>

        // Validate config if paths provided
        <span class="cov2" title="2">if len(configPaths) &gt; 0 </span><span class="cov0" title="0">{
                resolved, err := resolveConfigPaths(configPaths, configDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("resolve config paths: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Println("Validating configuration...")
                allEntries, _, hasErrors := validateConfigEntries(resolved)
                nameErrors, _ := checkNameConflicts(allEntries)
                if hasErrors || nameErrors </span><span class="cov0" title="0">{
                        return fmt.Errorf("config validation failed, not sending reload signal")
                }</span>
                <span class="cov0" title="0">fmt.Println("Configuration valid.")
                fmt.Println()</span>
        }

        // Send SIGHUP to the daemon
        <span class="cov2" title="2">fmt.Printf("Sending SIGHUP to daemon (pid %d)...\n", pid)
        if err := process.Signal(syscall.SIGHUP); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("send SIGHUP to process %d: %w", pid, err)
        }</span>

        <span class="cov2" title="2">fmt.Println("Reload signal sent successfully.")
        return nil</span>
}

// validationEntry tracks the result of validating a single resolved config entry.
type validationEntry struct {
        name       string // virtual file name
        status     string // "OK", "WARN", "ERR"
        message    string // detail message (empty for OK)
        configFile string // which input config file this came from
        dedupFile  string // resolved dedup file path
}

// resolveConfigPaths expands --config-dir and applies defaults to get the final
// list of config file paths to validate.
func resolveConfigPaths(configPaths []string, configDir bool) ([]string, error) <span class="cov6" title="32">{
        if configDir </span><span class="cov2" title="2">{
                if len(configPaths) != 1 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("--config-dir requires exactly one directory path, got %d", len(configPaths))
                }</span>
                <span class="cov2" title="2">return expandConfigDir(configPaths[0])</span>
        }

        <span class="cov6" title="30">if len(configPaths) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no config files specified\nRun 'mkvdup validate --help' for usage")
        }</span>

        <span class="cov6" title="30">return configPaths, nil</span>
}

// validateConfigEntries resolves and validates each config file: YAML parsing,
// path existence checks, and dedup file header validation. Returns the
// validation entries, the successfully-parsed configs, and whether any errors
// were found.
func validateConfigEntries(configPaths []string) ([]validationEntry, []dedup.Config, bool) <span class="cov6" title="32">{
        var allEntries []validationEntry
        var allConfigs []dedup.Config
        hasErrors := false

        for _, configPath := range configPaths </span><span class="cov7" title="40">{
                fmt.Printf("Validating %s...\n", filepath.Base(configPath))

                configs, err := dedup.ResolveConfigs([]string{configPath})
                if err != nil </span><span class="cov3" title="4">{
                        fmt.Printf("  ERR  %s\n", err)
                        allEntries = append(allEntries, validationEntry{
                                name:       filepath.Base(configPath),
                                status:     "ERR",
                                message:    err.Error(),
                                configFile: configPath,
                        })
                        hasErrors = true
                        continue</span>
                }

                <span class="cov6" title="36">if len(configs) == 0 </span><span class="cov2" title="2">{
                        fmt.Printf("  (no entries)\n")
                        continue</span>
                }

                <span class="cov6" title="34">for _, cfg := range configs </span><span class="cov6" title="36">{
                        entry := validationEntry{
                                name:       cfg.Name,
                                status:     "OK",
                                configFile: configPath,
                                dedupFile:  cfg.DedupFile,
                        }

                        // Check dedup file exists
                        dedupStat, err := os.Stat(cfg.DedupFile)
                        if err != nil </span><span class="cov2" title="2">{
                                entry.status = "ERR"
                                entry.message = fmt.Sprintf("dedup file: %v", err)
                                fmt.Printf("  ERR  %s: %s\n", cfg.Name, entry.message)
                                allEntries = append(allEntries, entry)
                                hasErrors = true
                                continue</span>
                        }
                        <span class="cov6" title="34">if dedupStat.IsDir() </span><span class="cov0" title="0">{
                                entry.status = "ERR"
                                entry.message = fmt.Sprintf("dedup file is a directory: %s", cfg.DedupFile)
                                fmt.Printf("  ERR  %s: %s\n", cfg.Name, entry.message)
                                allEntries = append(allEntries, entry)
                                hasErrors = true
                                continue</span>
                        }

                        // Check source dir exists and is a directory
                        <span class="cov6" title="34">sourceStat, err := os.Stat(cfg.SourceDir)
                        if err != nil </span><span class="cov2" title="2">{
                                entry.status = "ERR"
                                entry.message = fmt.Sprintf("source directory: %v", err)
                                fmt.Printf("  ERR  %s: %s\n", cfg.Name, entry.message)
                                allEntries = append(allEntries, entry)
                                hasErrors = true
                                continue</span>
                        }
                        <span class="cov6" title="32">if !sourceStat.IsDir() </span><span class="cov2" title="2">{
                                entry.status = "ERR"
                                entry.message = fmt.Sprintf("source path is not a directory: %s", cfg.SourceDir)
                                fmt.Printf("  ERR  %s: %s\n", cfg.Name, entry.message)
                                allEntries = append(allEntries, entry)
                                hasErrors = true
                                continue</span>
                        }

                        // Validate dedup file header
                        <span class="cov6" title="30">reader, err := dedup.NewReaderLazy(cfg.DedupFile, cfg.SourceDir)
                        if err != nil </span><span class="cov0" title="0">{
                                entry.status = "ERR"
                                entry.message = fmt.Sprintf("invalid dedup file: %v", err)
                                fmt.Printf("  ERR  %s: %s\n", cfg.Name, entry.message)
                                allEntries = append(allEntries, entry)
                                hasErrors = true
                                continue</span>
                        }
                        <span class="cov6" title="30">reader.Close()

                        allEntries = append(allEntries, entry)
                        allConfigs = append(allConfigs, cfg)</span>
                }
        }

        <span class="cov6" title="32">return allEntries, allConfigs, hasErrors</span>
}

// checkNameConflicts validates virtual file paths and detects duplicate names
// and file/directory conflicts across all entries. Updates entry statuses
// in-place and returns whether any errors or warnings were found.
func checkNameConflicts(entries []validationEntry) (hasErrors, hasWarnings bool) <span class="cov6" title="32">{
        nameToConfig := make(map[string]string)   // clean path -&gt; config file
        dirComponents := make(map[string]string)  // paths used as directories -&gt; config file
        fileComponents := make(map[string]string) // paths used as files -&gt; config file

        for i, entry := range entries </span><span class="cov7" title="40">{
                if entry.status == "ERR" </span><span class="cov4" title="10">{
                        continue</span>
                }

                <span class="cov6" title="30">name := entry.name

                // Check for ".." path components
                if slices.Contains(strings.Split(name, "/"), "..") </span><span class="cov2" title="2">{
                        entries[i].status = "ERR"
                        entries[i].message = "invalid path: contains '..' component"
                        fmt.Printf("  ERR  %s: %s\n", name, entries[i].message)
                        hasErrors = true
                        continue</span>
                }

                // Clean and validate the path (same logic as tree.go insertFile)
                <span class="cov6" title="28">cleanPath := cleanVirtualPath(name)
                if cleanPath == "" </span><span class="cov2" title="2">{
                        entries[i].status = "ERR"
                        entries[i].message = "invalid path: empty after cleaning"
                        fmt.Printf("  ERR  %s: %s\n", name, entries[i].message)
                        hasErrors = true
                        continue</span>
                }

                // Check for duplicate names
                <span class="cov6" title="26">if prevConfig, exists := nameToConfig[cleanPath]; exists </span><span class="cov3" title="4">{
                        entries[i].status = "WARN"
                        entries[i].message = fmt.Sprintf("duplicate name (also in %s)", filepath.Base(prevConfig))
                        fmt.Printf("  WARN %s: %s\n", name, entries[i].message)
                        hasWarnings = true
                        continue</span>
                }
                <span class="cov6" title="22">nameToConfig[cleanPath] = entry.configFile

                // Check for file/directory conflicts
                parts := strings.Split(cleanPath, "/")
                conflictFound := false

                // Check if any prefix of this path is used as a file
                for j := 0; j &lt; len(parts)-1; j++ </span><span class="cov2" title="2">{
                        dirPath := strings.Join(parts[:j+1], "/")
                        if prevConfig, exists := fileComponents[dirPath]; exists </span><span class="cov2" title="2">{
                                entries[i].status = "WARN"
                                entries[i].message = fmt.Sprintf("path component %q conflicts with file in %s", dirPath, filepath.Base(prevConfig))
                                fmt.Printf("  WARN %s: %s\n", name, entries[i].message)
                                hasWarnings = true
                                conflictFound = true
                                break</span>
                        }
                        // Record as directory component
                        <span class="cov0" title="0">if _, exists := dirComponents[dirPath]; !exists </span><span class="cov0" title="0">{
                                dirComponents[dirPath] = entry.configFile
                        }</span>
                }
                <span class="cov6" title="22">if conflictFound </span><span class="cov2" title="2">{
                        continue</span>
                }

                // Check if this file name conflicts with a directory
                <span class="cov5" title="20">if prevConfig, exists := dirComponents[cleanPath]; exists </span><span class="cov0" title="0">{
                        entries[i].status = "WARN"
                        entries[i].message = fmt.Sprintf("conflicts with directory from %s", filepath.Base(prevConfig))
                        fmt.Printf("  WARN %s: %s\n", name, entries[i].message)
                        hasWarnings = true
                        continue</span>
                }

                <span class="cov5" title="20">fileComponents[cleanPath] = entry.configFile

                // Print OK for entries that passed all checks
                if entries[i].status == "OK" </span><span class="cov5" title="20">{
                        fmt.Printf("  OK   %s\n", name)
                }</span>
        }

        <span class="cov6" title="32">return hasErrors, hasWarnings</span>
}

// runDeepValidation performs integrity verification on dedup files that passed
// basic validation. Returns whether any errors were found.
func runDeepValidation(entries []validationEntry, configs []dedup.Config) bool <span class="cov3" title="4">{
        fmt.Println()
        fmt.Println("Running deep validation...")
        hasErrors := false
        for _, cfg := range configs </span><span class="cov3" title="4">{
                // Only deep-validate entries that passed basic validation
                entryOK := false
                for _, e := range entries </span><span class="cov3" title="4">{
                        if e.name == cfg.Name &amp;&amp; e.dedupFile == cfg.DedupFile &amp;&amp; e.status != "ERR" </span><span class="cov3" title="4">{
                                entryOK = true
                                break</span>
                        }
                }
                <span class="cov3" title="4">if !entryOK </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="4">reader, err := dedup.NewReader(cfg.DedupFile, cfg.SourceDir)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  ERR  %s: failed to open: %v\n", cfg.Name, err)
                        hasErrors = true
                        continue</span>
                }
                <span class="cov3" title="4">if err := reader.VerifyIntegrity(); err != nil </span><span class="cov2" title="2">{
                        fmt.Printf("  ERR  %s: integrity check failed: %v\n", cfg.Name, err)
                        reader.Close()
                        hasErrors = true
                        continue</span>
                }
                <span class="cov2" title="2">reader.Close()
                fmt.Printf("  OK   %s: checksums valid\n", cfg.Name)</span>
        }
        <span class="cov3" title="4">return hasErrors</span>
}

// validateConfigs validates configuration files and returns an exit code.
// Returns 0 if all configs are valid (warnings OK without strict), 1 otherwise.
func validateConfigs(configPaths []string, configDir, deep, strict bool) int <span class="cov6" title="32">{
        resolved, err := resolveConfigPaths(configPaths, configDir)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                return 1
        }</span>

        <span class="cov6" title="32">allEntries, allConfigs, hasErrors := validateConfigEntries(resolved)

        nameErrors, hasWarnings := checkNameConflicts(allEntries)
        hasErrors = hasErrors || nameErrors

        if deep </span><span class="cov3" title="4">{
                hasErrors = hasErrors || runDeepValidation(allEntries, allConfigs)
        }</span>

        // Print summary
        <span class="cov6" title="32">var okCount, warnCount, errCount int
        for _, e := range allEntries </span><span class="cov7" title="40">{
                switch e.status </span>{
                case "OK":<span class="cov5" title="20">
                        okCount++</span>
                case "WARN":<span class="cov3" title="6">
                        warnCount++</span>
                case "ERR":<span class="cov5" title="14">
                        errCount++</span>
                }
        }

        <span class="cov6" title="32">fmt.Println()
        fmt.Printf("Summary: %d entries, %d valid, %d warnings, %d errors\n",
                len(allEntries), okCount, warnCount, errCount)

        if hasErrors </span><span class="cov5" title="16">{
                return 1
        }</span>
        <span class="cov5" title="16">if strict &amp;&amp; hasWarnings </span><span class="cov2" title="2">{
                return 1
        }</span>
        <span class="cov5" title="14">return 0</span>
}

// cleanVirtualPath normalizes a virtual file path, matching the logic in
// internal/fuse/tree.go insertFile(). Returns empty string if the path is invalid.
func cleanVirtualPath(name string) string <span class="cov7" title="46">{
        // Clean the path using path.Clean (not filepath.Clean) to match
        // internal/fuse/tree.go insertFile() which uses forward-slash paths.
        cleaned := path.Clean(name)
        // Split and filter
        parts := strings.Split(cleaned, "/")
        var valid []string
        for _, p := range parts </span><span class="cov7" title="66">{
                if p != "" &amp;&amp; p != "." </span><span class="cov7" title="52">{
                        valid = append(valid, p)
                }</span>
        }
        <span class="cov7" title="46">if len(valid) == 0 </span><span class="cov4" title="8">{
                return ""
        }</span>
        <span class="cov6" title="38">return strings.Join(valid, "/")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Command mkvdup is the CLI tool for MKV-ISO deduplication.
package main

import (
        "fmt"
        "log"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/stuckj/mkvdup/internal/matcher"
        "github.com/stuckj/mkvdup/internal/mkv"
        "github.com/stuckj/mkvdup/internal/source"
)

// MountOptions holds all options for the mount command.
type MountOptions struct {
        AllowOther      bool
        Foreground      bool
        ConfigDir       bool
        PidFile         string
        DaemonTimeout   time.Duration
        PermissionsFile string
        DefaultUID      uint32
        DefaultGID      uint32
        DefaultFileMode uint32
        DefaultDirMode  uint32
}

// parseUint32 parses a string as uint32.
func parseUint32(s string) (uint32, error) <span class="cov7" title="16">{
        v, err := strconv.ParseUint(s, 10, 32)
        if err != nil </span><span class="cov6" title="8">{
                return 0, err
        }</span>
        <span class="cov6" title="8">return uint32(v), nil</span>
}

// parseOctalMode parses a string as an octal file mode.
func parseOctalMode(s string) (uint32, error) <span class="cov8" title="20">{
        // Strip leading 0 prefix for octal if present
        v, err := strconv.ParseUint(s, 8, 32)
        if err != nil </span><span class="cov5" title="6">{
                return 0, err
        }</span>
        <span class="cov7" title="14">return uint32(v), nil</span>
}

// parseWarnFlags extracts --warn-threshold and --quiet from args, returning the
// parsed values and the remaining positional arguments.
func parseWarnFlags(args []string) (warnThreshold float64, quiet bool, remaining []string) <span class="cov7" title="14">{
        warnThreshold = 75.0
        for i := 0; i &lt; len(args); i++ </span><span class="cov10" title="38">{
                switch args[i] </span>{
                case "--warn-threshold":<span class="cov6" title="10">
                        if i+1 &lt; len(args) &amp;&amp; !strings.HasPrefix(args[i+1], "--") </span><span class="cov6" title="10">{
                                v, err := strconv.ParseFloat(args[i+1], 64)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Fatalf("Error: --warn-threshold invalid: %v", err)
                                }</span>
                                <span class="cov6" title="10">if v &lt; 0 || v &gt; 100 </span><span class="cov0" title="0">{
                                        log.Fatalf("Error: --warn-threshold must be between 0 and 100")
                                }</span>
                                <span class="cov6" title="10">warnThreshold = v
                                i++</span>
                        } else<span class="cov0" title="0"> {
                                log.Fatalf("Error: --warn-threshold requires a numeric argument")
                        }</span>
                case "--quiet":<span class="cov5" title="6">
                        quiet = true</span>
                default:<span class="cov8" title="22">
                        remaining = append(remaining, args[i])</span>
                }
        }
        <span class="cov7" title="14">return</span>
}

// version is set at build time via -ldflags
var version = "dev"

// verbose is set to true when -v flag is passed
var verbose bool

func printVersion() <span class="cov2" title="2">{
        fmt.Printf("mkvdup version %s\n", version)
}</span>

func printUsage() <span class="cov4" title="4">{
        fmt.Print(`mkvdup - MKV deduplication tool using FUSE

Usage: mkvdup [options] &lt;command&gt; [args...]

Commands:
  create       Create dedup file from MKV + source directory
  batch-create Create multiple dedup files from one source
  probe        Quick test if MKV matches source(s)
  mount        Mount dedup files as FUSE filesystem
  info         Show dedup file information
  verify       Verify dedup file against original MKV
  check        Check dedup + source file integrity
  validate     Validate configuration files
  reload       Reload running daemon's configuration

Debug commands:
  parse-mkv    Parse MKV and show packet info
  index-source Index source directory
  match        Match MKV packets to source

Options:
  -v, --verbose   Enable verbose output
  -h, --help      Show help
  --version       Show version
`)
        fmt.Print(debugOptionsHelp())
        fmt.Print(`Run 'mkvdup &lt;command&gt; --help' for more information on a command.
See 'man mkvdup' for detailed documentation.
`)
}</span>

func printCommandUsage(cmd string) <span class="cov8" title="20">{
        switch cmd </span>{
        case "create":<span class="cov2" title="2">
                fmt.Print(`Usage: mkvdup create [options] &lt;mkv-file&gt; &lt;source-dir&gt; [output] [name]

Create a dedup file from an MKV and its source media.

Arguments:
    &lt;mkv-file&gt;    Path to the MKV file to deduplicate
    &lt;source-dir&gt;  Directory containing source media (ISO files or BDMV folders)
    [output]      Output .mkvdup file (default: &lt;mkv-file&gt;.mkvdup)
    [name]        Display name in FUSE mount (default: basename of mkv-file)

Options:
    --warn-threshold N  Minimum space savings percentage to avoid warning (default: 75)
    --quiet             Suppress the space savings warning
    --non-interactive   Don't prompt on codec mismatch (show warning and continue)

Before matching, codecs in the MKV are compared against the source media.
If a mismatch is detected (e.g., MKV has H.264 but source is MPEG-2), you
will be prompted to continue. Use --non-interactive for scripted usage.

Examples:
    mkvdup create movie.mkv /media/dvd-backups
    mkvdup create movie.mkv /media/dvd-backups movie.mkvdup "My Movie"
    mkvdup create --warn-threshold 50 movie.mkv /media/dvd-backups
    mkvdup create --quiet movie.mkv /media/dvd-backups
    mkvdup create --non-interactive movie.mkv /media/dvd-backups
`)</span>
        case "batch-create":<span class="cov0" title="0">
                fmt.Print(`Usage: mkvdup batch-create [options] &lt;manifest.yaml&gt;

Create multiple dedup files from MKVs sharing the same source directory.
The source is indexed once and reused for all files.

Codec compatibility is checked for each file. If a mismatch is detected,
a warning is printed but processing continues (non-interactive mode).

Arguments:
    &lt;manifest.yaml&gt;  YAML manifest file specifying source and MKV files

Options:
    --warn-threshold N  Minimum space savings percentage to avoid warning (default: 75)
    --quiet             Suppress the space savings warning

Manifest format:
    source_dir: /media/dvd-backups/disc1
    files:
      - mkv: episode1.mkv
        output: episode1.mkvdup        # optional
        name: "Show/S01/Episode 1.mkv" # optional
      - mkv: episode2.mkv

Fields:
    source_dir   Shared source directory (required)
    files        List of MKV files to process (required, at least one)
    mkv          Path to MKV file (required per entry)
    output       Output .mkvdup file (default: &lt;mkv&gt;.mkvdup)
    name         Display name in FUSE mount (default: basename of mkv)

Relative paths are resolved against the manifest file's directory.

Examples:
    mkvdup batch-create episodes.yaml
    mkvdup batch-create --quiet episodes.yaml
`)</span>
        case "probe":<span class="cov2" title="2">
                fmt.Print(`Usage: mkvdup probe &lt;mkv-file&gt; &lt;source-dir&gt;...

Quick test to check if an MKV matches one or more source directories.

Arguments:
    &lt;mkv-file&gt;    Path to the MKV file to test
    &lt;source-dir&gt;  One or more directories to test against

Examples:
    mkvdup probe movie.mkv /media/disc1 /media/disc2 /media/disc3
`)</span>
        case "mount":<span class="cov2" title="2">
                fmt.Print(`Usage: mkvdup mount [options] &lt;mountpoint&gt; [config.yaml...]

Mount dedup files as a FUSE filesystem.

Arguments:
    &lt;mountpoint&gt;   Directory to mount the filesystem
    [config.yaml]  YAML config files (default: /etc/mkvdup.conf)

Options:
    --allow-other          Allow other users to access the mount
    --foreground           Run in foreground (for debugging or systemd)
    --config-dir           Treat config argument as directory of YAML files (.yaml, .yml)
    --pid-file PATH        Write daemon PID to file
    --daemon-timeout DUR   Timeout waiting for daemon startup (default: 30s)

Permission Options:
    --default-uid UID          Default UID for files and directories (default: calling user's UID)
    --default-gid GID          Default GID for files and directories (default: calling user's GID)
    --default-file-mode MODE   Default mode for files (octal, default: 0444)
    --default-dir-mode MODE    Default mode for directories (octal, default: 0555)
    --permissions-file PATH    Path to permissions file (overrides default locations)

By default, mkvdup daemonizes after the mount is ready and returns.
Use --foreground to keep it attached to the terminal.

Permission files are searched in order:
  1. --permissions-file (if specified)
  2. ~/.config/mkvdup/permissions.yaml (if exists)
  3. /etc/mkvdup/permissions.yaml (if exists)
New permissions are written to ~/.config/mkvdup/permissions.yaml (user) or
/etc/mkvdup/permissions.yaml (root).

Examples:
    mkvdup mount /mnt/videos movie.mkvdup.yaml
    mkvdup mount /mnt/videos *.yaml
    mkvdup mount --allow-other /mnt/videos
    mkvdup mount --config-dir /mnt/videos /etc/mkvdup.d/
    mkvdup mount --foreground /mnt/videos config.yaml
    mkvdup mount --default-uid 1000 --default-gid 1000 /mnt/videos config.yaml
`)</span>
        case "info":<span class="cov2" title="2">
                fmt.Print(`Usage: mkvdup info &lt;dedup-file&gt;

Show information about a dedup file.

Arguments:
    &lt;dedup-file&gt;  Path to the .mkvdup file

Examples:
    mkvdup info movie.mkvdup
`)</span>
        case "verify":<span class="cov2" title="2">
                fmt.Print(`Usage: mkvdup verify &lt;dedup-file&gt; &lt;source-dir&gt; &lt;original-mkv&gt;

Verify that a dedup file correctly reconstructs the original MKV.

Arguments:
    &lt;dedup-file&gt;    Path to the .mkvdup file
    &lt;source-dir&gt;    Directory containing the source media
    &lt;original-mkv&gt;  Path to the original MKV for comparison

Examples:
    mkvdup verify movie.mkvdup /media/dvd-backups original.mkv
`)</span>
        case "check":<span class="cov0" title="0">
                fmt.Print(`Usage: mkvdup check &lt;dedup-file&gt; &lt;source-dir&gt; [options]

Check integrity of a dedup file and its source files.

Arguments:
    &lt;dedup-file&gt;  Path to the .mkvdup file
    &lt;source-dir&gt;  Directory containing the source media

Options:
    --source-checksums  Verify source file checksums (slow, reads entire files)

Checks performed:
    - Dedup file header validity (magic, version, structure)
    - Index and delta checksum verification
    - Source file existence and size
    With --source-checksums:
    - Source file checksum verification (reads entire files)

Examples:
    mkvdup check movie.mkvdup /media/dvd-backups
    mkvdup check --source-checksums movie.mkvdup /media/dvd-backups
`)</span>
        case "validate":<span class="cov0" title="0">
                fmt.Print(`Usage: mkvdup validate [options] &lt;config.yaml...&gt;

Validate configuration files for correctness before mounting.

Arguments:
    &lt;config.yaml&gt;  YAML config files to validate

Options:
    --config-dir   Treat config argument as directory of YAML files (.yaml, .yml)
    --deep         Verify dedup file headers and internal checksums
    --strict       Treat warnings as errors (exit 1 on warnings)

Validations performed:
    - YAML syntax and required fields (name, dedup_file, source_dir)
    - Include cycle detection
    - Dedup file existence and header validity
    - Source directory existence
    - Duplicate virtual file names (warning)
    - File/directory path conflicts (warning)
    - Invalid path names (empty, contains "..")
    With --deep:
    - Dedup file internal checksum verification

Exit codes:
    0  All configs valid (warnings may be present)
    1  Errors found (or warnings with --strict)

Examples:
    mkvdup validate config.yaml
    mkvdup validate *.yaml
    mkvdup validate --config-dir /etc/mkvdup.d/
    mkvdup validate --deep --strict /etc/mkvdup.conf
`)</span>
        case "reload":<span class="cov2" title="2">
                fmt.Print(`Usage: mkvdup reload --pid-file PATH [options] [config.yaml...]

Reload a running daemon's configuration by validating the config
and sending SIGHUP to the daemon process.

The config is validated BEFORE sending the signal. If validation
fails, the signal is not sent and the error is reported.

If no config files are specified, the signal is sent without
pre-validation (the daemon validates internally on SIGHUP).

Arguments:
    [config.yaml]  Config files to validate (same as mount's config args)

Required Options:
    --pid-file PATH    PID file of running daemon (must match mount's --pid-file)

Options:
    --config-dir       Treat config argument as directory of YAML files

Examples:
    mkvdup reload --pid-file /run/mkvdup.pid config.yaml
    mkvdup reload --pid-file /run/mkvdup.pid --config-dir /etc/mkvdup.d/
    mkvdup reload --pid-file /run/mkvdup.pid
`)</span>
        case "parse-mkv":<span class="cov2" title="2">
                fmt.Print(`Usage: mkvdup parse-mkv &lt;mkv-file&gt;

Parse an MKV file and display packet information (debugging).

Arguments:
    &lt;mkv-file&gt;  Path to the MKV file to parse

Examples:
    mkvdup parse-mkv movie.mkv
`)</span>
        case "index-source":<span class="cov2" title="2">
                fmt.Print(`Usage: mkvdup index-source &lt;source-dir&gt;

Index a source directory and display statistics (debugging).

Arguments:
    &lt;source-dir&gt;  Directory containing source media (ISO files or BDMV folders)

Examples:
    mkvdup index-source /media/dvd-backups
`)</span>
        case "match":<span class="cov2" title="2">
                fmt.Print(`Usage: mkvdup match &lt;mkv-file&gt; &lt;source-dir&gt;

Match MKV packets to source and show detailed results (debugging).

Arguments:
    &lt;mkv-file&gt;    Path to the MKV file
    &lt;source-dir&gt;  Directory containing source media

Examples:
    mkvdup match movie.mkv /media/dvd-backups
`)</span>
        default:<span class="cov2" title="2">
                printUsage()</span>
        }
}

func main() <span class="cov0" title="0">{
        // Process global flags before command
        args := os.Args[1:]
        var filteredArgs []string
        showHelp := false
        showVersion := false

        // Extract --cpuprofile flag (only available in debug builds)
        args, cpuprofile := parseCPUProfileFlag(args)
        defer startCPUProfile(cpuprofile)()

        for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                arg := args[i]
                switch </span>{
                case arg == "-v" || arg == "--verbose":<span class="cov0" title="0">
                        verbose = true</span>
                case arg == "-h" || arg == "--help":<span class="cov0" title="0">
                        showHelp = true</span>
                case arg == "--version":<span class="cov0" title="0">
                        showVersion = true</span>
                default:<span class="cov0" title="0">
                        filteredArgs = append(filteredArgs, arg)</span>
                }
        }
        <span class="cov0" title="0">args = filteredArgs

        // Handle --version (always top-level)
        if showVersion </span><span class="cov0" title="0">{
                printVersion()
                os.Exit(0)
        }</span>

        // If no command given, show appropriate help
        <span class="cov0" title="0">if len(args) &lt; 1 </span><span class="cov0" title="0">{
                if showHelp </span><span class="cov0" title="0">{
                        printUsage()
                        os.Exit(0)
                }</span>
                <span class="cov0" title="0">printUsage()
                os.Exit(1)</span>
        }

        <span class="cov0" title="0">cmd := args[0]
        args = args[1:]

        // If help flag was given with a command, show command-specific help
        if showHelp </span><span class="cov0" title="0">{
                printCommandUsage(cmd)
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">switch cmd </span>{
        case "create":<span class="cov0" title="0">
                warnThreshold, quiet, remaining := parseWarnFlags(args)
                nonInteractive := false
                var createArgs []string
                for i := 0; i &lt; len(remaining); i++ </span><span class="cov0" title="0">{
                        switch remaining[i] </span>{
                        case "--non-interactive":<span class="cov0" title="0">
                                nonInteractive = true</span>
                        default:<span class="cov0" title="0">
                                createArgs = append(createArgs, remaining[i])</span>
                        }
                }
                <span class="cov0" title="0">if len(createArgs) &lt; 2 </span><span class="cov0" title="0">{
                        printCommandUsage("create")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">output := ""
                name := ""
                if len(createArgs) &gt;= 3 </span><span class="cov0" title="0">{
                        output = createArgs[2]
                }</span>
                <span class="cov0" title="0">if len(createArgs) &gt;= 4 </span><span class="cov0" title="0">{
                        name = createArgs[3]
                }</span>
                <span class="cov0" title="0">if err := createDedup(createArgs[0], createArgs[1], output, name, warnThreshold, quiet, nonInteractive); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %v", err)
                }</span>

        case "batch-create":<span class="cov0" title="0">
                warnThreshold, quiet, batchArgs := parseWarnFlags(args)
                if len(batchArgs) &lt; 1 </span><span class="cov0" title="0">{
                        printCommandUsage("batch-create")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := createBatch(batchArgs[0], warnThreshold, quiet); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %v", err)
                }</span>

        case "probe":<span class="cov0" title="0">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        printCommandUsage("probe")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := probe(args[0], args[1:]); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %v", err)
                }</span>

        case "mount":<span class="cov0" title="0">
                // Parse mount-specific options
                allowOther := false
                foreground := false
                configDir := false
                pidFile := ""
                daemonTimeout := 30 * time.Second
                permissionsFile := ""
                defaultUID := uint32(os.Getuid())
                defaultGID := uint32(os.Getgid())
                defaultFileMode := uint32(0444)
                defaultDirMode := uint32(0555)
                var mountArgs []string
                for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        switch args[i] </span>{
                        case "--allow-other":<span class="cov0" title="0">
                                allowOther = true</span>
                        case "--foreground", "-f":<span class="cov0" title="0">
                                foreground = true</span>
                        case "--config-dir":<span class="cov0" title="0">
                                configDir = true</span>
                        case "--pid-file":<span class="cov0" title="0">
                                if i+1 &lt; len(args) &amp;&amp; !strings.HasPrefix(args[i+1], "--") </span><span class="cov0" title="0">{
                                        pidFile = args[i+1]
                                        i++
                                }</span> else<span class="cov0" title="0"> {
                                        log.Fatalf("Error: --pid-file requires a path argument")
                                }</span>
                        case "--daemon-timeout":<span class="cov0" title="0">
                                if i+1 &lt; len(args) &amp;&amp; !strings.HasPrefix(args[i+1], "--") </span><span class="cov0" title="0">{
                                        d, err := time.ParseDuration(args[i+1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Fatalf("Error: --daemon-timeout invalid duration: %v", err)
                                        }</span>
                                        <span class="cov0" title="0">daemonTimeout = d
                                        i++</span>
                                } else<span class="cov0" title="0"> {
                                        log.Fatalf("Error: --daemon-timeout requires a duration argument (e.g., 30s, 1m)")
                                }</span>
                        case "--permissions-file":<span class="cov0" title="0">
                                if i+1 &lt; len(args) &amp;&amp; !strings.HasPrefix(args[i+1], "--") </span><span class="cov0" title="0">{
                                        permissionsFile = args[i+1]
                                        i++
                                }</span> else<span class="cov0" title="0"> {
                                        log.Fatalf("Error: --permissions-file requires a path argument")
                                }</span>
                        case "--default-uid":<span class="cov0" title="0">
                                if i+1 &lt; len(args) &amp;&amp; !strings.HasPrefix(args[i+1], "--") </span><span class="cov0" title="0">{
                                        uid, err := parseUint32(args[i+1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Fatalf("Error: --default-uid invalid: %v", err)
                                        }</span>
                                        <span class="cov0" title="0">defaultUID = uid
                                        i++</span>
                                } else<span class="cov0" title="0"> {
                                        log.Fatalf("Error: --default-uid requires a numeric argument")
                                }</span>
                        case "--default-gid":<span class="cov0" title="0">
                                if i+1 &lt; len(args) &amp;&amp; !strings.HasPrefix(args[i+1], "--") </span><span class="cov0" title="0">{
                                        gid, err := parseUint32(args[i+1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Fatalf("Error: --default-gid invalid: %v", err)
                                        }</span>
                                        <span class="cov0" title="0">defaultGID = gid
                                        i++</span>
                                } else<span class="cov0" title="0"> {
                                        log.Fatalf("Error: --default-gid requires a numeric argument")
                                }</span>
                        case "--default-file-mode":<span class="cov0" title="0">
                                if i+1 &lt; len(args) &amp;&amp; !strings.HasPrefix(args[i+1], "--") </span><span class="cov0" title="0">{
                                        mode, err := parseOctalMode(args[i+1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Fatalf("Error: --default-file-mode invalid: %v", err)
                                        }</span>
                                        <span class="cov0" title="0">defaultFileMode = mode
                                        i++</span>
                                } else<span class="cov0" title="0"> {
                                        log.Fatalf("Error: --default-file-mode requires an octal mode argument")
                                }</span>
                        case "--default-dir-mode":<span class="cov0" title="0">
                                if i+1 &lt; len(args) &amp;&amp; !strings.HasPrefix(args[i+1], "--") </span><span class="cov0" title="0">{
                                        mode, err := parseOctalMode(args[i+1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Fatalf("Error: --default-dir-mode invalid: %v", err)
                                        }</span>
                                        <span class="cov0" title="0">defaultDirMode = mode
                                        i++</span>
                                } else<span class="cov0" title="0"> {
                                        log.Fatalf("Error: --default-dir-mode requires an octal mode argument")
                                }</span>
                        default:<span class="cov0" title="0">
                                mountArgs = append(mountArgs, args[i])</span>
                        }
                }
                <span class="cov0" title="0">if len(mountArgs) &lt; 1 </span><span class="cov0" title="0">{
                        printCommandUsage("mount")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">mountpoint := mountArgs[0]
                configPaths := mountArgs[1:]
                mountOpts := MountOptions{
                        AllowOther:      allowOther,
                        Foreground:      foreground,
                        ConfigDir:       configDir,
                        PidFile:         pidFile,
                        DaemonTimeout:   daemonTimeout,
                        PermissionsFile: permissionsFile,
                        DefaultUID:      defaultUID,
                        DefaultGID:      defaultGID,
                        DefaultFileMode: defaultFileMode,
                        DefaultDirMode:  defaultDirMode,
                }
                if err := mountFuse(mountpoint, configPaths, mountOpts); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %v", err)
                }</span>

        case "info":<span class="cov0" title="0">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        printCommandUsage("info")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := showInfo(args[0]); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %v", err)
                }</span>

        case "verify":<span class="cov0" title="0">
                if len(args) &lt; 3 </span><span class="cov0" title="0">{
                        printCommandUsage("verify")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := verifyDedup(args[0], args[1], args[2]); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %v", err)
                }</span>

        case "check":<span class="cov0" title="0">
                sourceChecksums := false
                var checkArgs []string
                for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        switch args[i] </span>{
                        case "--source-checksums":<span class="cov0" title="0">
                                sourceChecksums = true</span>
                        default:<span class="cov0" title="0">
                                checkArgs = append(checkArgs, args[i])</span>
                        }
                }
                <span class="cov0" title="0">if len(checkArgs) &lt; 2 </span><span class="cov0" title="0">{
                        printCommandUsage("check")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := checkDedup(checkArgs[0], checkArgs[1], sourceChecksums); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %v", err)
                }</span>

        case "validate":<span class="cov0" title="0">
                configDir := false
                deep := false
                strict := false
                var valArgs []string
                for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        switch args[i] </span>{
                        case "--config-dir":<span class="cov0" title="0">
                                configDir = true</span>
                        case "--deep":<span class="cov0" title="0">
                                deep = true</span>
                        case "--strict":<span class="cov0" title="0">
                                strict = true</span>
                        default:<span class="cov0" title="0">
                                valArgs = append(valArgs, args[i])</span>
                        }
                }
                <span class="cov0" title="0">if len(valArgs) &lt; 1 </span><span class="cov0" title="0">{
                        printCommandUsage("validate")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">os.Exit(validateConfigs(valArgs, configDir, deep, strict))</span>

        case "reload":<span class="cov0" title="0">
                pidFile := ""
                configDir := false
                var reloadArgs []string
                for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        switch args[i] </span>{
                        case "--pid-file":<span class="cov0" title="0">
                                if i+1 &lt; len(args) &amp;&amp; !strings.HasPrefix(args[i+1], "--") </span><span class="cov0" title="0">{
                                        pidFile = args[i+1]
                                        i++
                                }</span> else<span class="cov0" title="0"> {
                                        log.Fatalf("Error: --pid-file requires a path argument")
                                }</span>
                        case "--config-dir":<span class="cov0" title="0">
                                configDir = true</span>
                        default:<span class="cov0" title="0">
                                reloadArgs = append(reloadArgs, args[i])</span>
                        }
                }
                <span class="cov0" title="0">if pidFile == "" </span><span class="cov0" title="0">{
                        log.Fatalf("Error: --pid-file is required for reload")
                }</span>
                <span class="cov0" title="0">if err := reloadDaemon(pidFile, reloadArgs, configDir); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %v", err)
                }</span>

        case "parse-mkv":<span class="cov0" title="0">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        printCommandUsage("parse-mkv")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := parseMKV(args[0]); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %v", err)
                }</span>

        case "index-source":<span class="cov0" title="0">
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        printCommandUsage("index-source")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := indexSource(args[0]); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %v", err)
                }</span>

        case "match":<span class="cov0" title="0">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        printCommandUsage("match")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := matchMKV(args[0], args[1]); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %v", err)
                }</span>

        case "help":<span class="cov0" title="0">
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        printCommandUsage(args[0])
                }</span> else<span class="cov0" title="0"> {
                        printUsage()
                }</span>
                <span class="cov0" title="0">os.Exit(0)</span>

        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown command: %s\n\n", cmd)
                printUsage()
                os.Exit(1)</span>
        }
}

func parseMKV(path string) error <span class="cov0" title="0">{
        fmt.Printf("Parsing MKV file: %s\n", path)

        parser, err := mkv.NewParser(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create parser: %w", err)
        }</span>
        <span class="cov0" title="0">defer parser.Close()

        fmt.Printf("File size: %s bytes (%.2f GB)\n", formatInt(parser.Size()), float64(parser.Size())/(1024*1024*1024))

        start := time.Now()
        lastProgress := time.Now()

        err = parser.Parse(func(processed, total int64) </span><span class="cov0" title="0">{
                if time.Since(lastProgress) &gt; 500*time.Millisecond </span><span class="cov0" title="0">{
                        pct := float64(processed) / float64(total) * 100
                        fmt.Printf("\rProgress: %.1f%% (%s / %s bytes)", pct, formatInt(processed), formatInt(total))
                        lastProgress = time.Now()
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">elapsed := time.Since(start)
        fmt.Printf("\rProgress: 100.0%% - Complete                    \n")
        fmt.Printf("Parse time: %v\n", elapsed)
        fmt.Println()

        fmt.Printf("Tracks: %d\n", len(parser.Tracks()))
        for _, t := range parser.Tracks() </span><span class="cov0" title="0">{
                typeStr := "unknown"
                switch t.Type </span>{
                case mkv.TrackTypeVideo:<span class="cov0" title="0">
                        typeStr = "video"</span>
                case mkv.TrackTypeAudio:<span class="cov0" title="0">
                        typeStr = "audio"</span>
                case mkv.TrackTypeSubtitle:<span class="cov0" title="0">
                        typeStr = "subtitle"</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Track %d: %s (codec: %s)\n", t.Number, typeStr, t.CodecID)</span>
        }
        <span class="cov0" title="0">fmt.Println()

        fmt.Printf("Total packets: %d\n", parser.PacketCount())
        fmt.Printf("  Video packets: %d\n", parser.VideoPacketCount())
        fmt.Printf("  Audio packets: %d\n", parser.AudioPacketCount())

        // Show some sample packets
        packets := parser.Packets()
        if len(packets) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println()
                fmt.Println("Sample packets (first 5):")
                for i := 0; i &lt; 5 &amp;&amp; i &lt; len(packets); i++ </span><span class="cov0" title="0">{
                        p := packets[i]
                        fmt.Printf("  Packet %d: offset=%d, size=%d, track=%d, keyframe=%v\n",
                                i, p.Offset, p.Size, p.TrackNum, p.Keyframe)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func indexSource(dir string) error <span class="cov0" title="0">{
        fmt.Printf("Indexing source directory: %s\n", dir)

        indexer, err := source.NewIndexer(dir, source.DefaultWindowSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create indexer: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Source type: %s\n", indexer.SourceType())

        start := time.Now()
        lastProgress := time.Now()

        err = indexer.Build(func(processed, total int64) </span><span class="cov0" title="0">{
                if time.Since(lastProgress) &gt; 500*time.Millisecond </span><span class="cov0" title="0">{
                        pct := float64(processed) / float64(total) * 100
                        fmt.Printf("\rProgress: %.1f%% (%s / %s bytes)", pct, formatInt(processed), formatInt(total))
                        lastProgress = time.Now()
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("build index: %w", err)
        }</span>

        <span class="cov0" title="0">elapsed := time.Since(start)
        fmt.Printf("\rProgress: 100.0%% - Complete                    \n")
        fmt.Printf("Index time: %v\n", elapsed)
        fmt.Println()

        index := indexer.Index()
        defer index.Close()
        fmt.Printf("Source files: %d\n", len(index.Files))
        for _, f := range index.Files </span><span class="cov0" title="0">{
                fmt.Printf("  %s: %s bytes\n", f.RelativePath, formatInt(f.Size))
        }</span>
        <span class="cov0" title="0">fmt.Println()

        fmt.Printf("Unique hashes: %d\n", len(index.HashToLocations))
        if index.UsesESOffsets </span><span class="cov0" title="0">{
                fmt.Printf("Index type: ES-aware (MPEG-PS)\n")
        }</span>

        // Count total locations
        <span class="cov0" title="0">totalLocations := 0
        for _, locs := range index.HashToLocations </span><span class="cov0" title="0">{
                totalLocations += len(locs)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Total indexed locations: %d\n", totalLocations)

        return nil</span>
}

func matchMKV(mkvPath, sourceDir string) error <span class="cov0" title="0">{
        totalStart := time.Now()

        // Phase 1: Parse MKV
        fmt.Println("Phase 1/3: Parsing MKV file...")
        parser, err := mkv.NewParser(mkvPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create parser: %w", err)
        }</span>
        <span class="cov0" title="0">defer parser.Close()

        start := time.Now()
        if err := parser.Parse(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse MKV: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("  Parsed %d packets in %v\n", parser.PacketCount(), time.Since(start))

        // Phase 2: Index source
        fmt.Println("Phase 2/3: Indexing source...")
        indexer, err := source.NewIndexer(sourceDir, source.DefaultWindowSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create indexer: %w", err)
        }</span>

        <span class="cov0" title="0">start = time.Now()
        lastProgress := time.Now()
        err = indexer.Build(func(processed, total int64) </span><span class="cov0" title="0">{
                if time.Since(lastProgress) &gt; 500*time.Millisecond </span><span class="cov0" title="0">{
                        pct := float64(processed) / float64(total) * 100
                        fmt.Printf("\r  Progress: %.1f%%", pct)
                        lastProgress = time.Now()
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("build index: %w", err)
        }</span>
        <span class="cov0" title="0">index := indexer.Index()
        defer index.Close()
        fmt.Printf("\r  Indexed %d hashes in %v                    \n", len(index.HashToLocations), time.Since(start))
        if index.UsesESOffsets </span><span class="cov0" title="0">{
                fmt.Println("  (Using ES-aware indexing for MPEG-PS)")
        }</span>

        // Phase 3: Match packets
        <span class="cov0" title="0">fmt.Println("Phase 3/3: Matching packets...")
        m, err := matcher.NewMatcher(index)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create matcher: %w", err)
        }</span>
        <span class="cov0" title="0">defer m.Close()

        start = time.Now()
        lastProgress = time.Now()
        result, err := m.Match(mkvPath, parser.Packets(), parser.Tracks(), func(processed, total int) </span><span class="cov0" title="0">{
                if time.Since(lastProgress) &gt; 500*time.Millisecond </span><span class="cov0" title="0">{
                        pct := float64(processed) / float64(total) * 100
                        fmt.Printf("\r  Progress: %.1f%% (%d/%d packets)", pct, processed, total)
                        lastProgress = time.Now()
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("match: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("\r  Matched in %v                              \n", time.Since(start))

        // Summary
        fmt.Println()
        fmt.Println("=== Results ===")
        fmt.Printf("Total time: %v\n", time.Since(totalStart))
        fmt.Println()

        mkvSize := parser.Size()
        fmt.Printf("MKV file size:      %s bytes (%.2f MB)\n", formatInt(mkvSize), float64(mkvSize)/(1024*1024))
        fmt.Printf("Matched bytes:      %s bytes (%.2f MB, %.1f%%)\n",
                formatInt(result.MatchedBytes), float64(result.MatchedBytes)/(1024*1024),
                float64(result.MatchedBytes)/float64(mkvSize)*100)
        fmt.Printf("Delta (unmatched):  %s bytes (%.2f MB, %.1f%%)\n",
                formatInt(result.UnmatchedBytes), float64(result.UnmatchedBytes)/(1024*1024),
                float64(result.UnmatchedBytes)/float64(mkvSize)*100)
        fmt.Println()

        fmt.Printf("Packets matched:    %d / %d (%.1f%%)\n",
                result.MatchedPackets, result.TotalPackets,
                float64(result.MatchedPackets)/float64(result.TotalPackets)*100)
        fmt.Printf("Index entries:      %d\n", len(result.Entries))
        fmt.Println()

        // Storage savings
        indexSize := int64(len(result.Entries) * 25) // Approximate: each entry ~25 bytes
        headerSize := int64(57)
        totalDedupSize := headerSize + indexSize + int64(len(result.DeltaData))
        savings := float64(mkvSize-totalDedupSize) / float64(mkvSize) * 100

        fmt.Printf("Estimated dedup file size:\n")
        fmt.Printf("  Header:     %s bytes\n", formatInt(headerSize))
        fmt.Printf("  Index:      %s bytes (~%s entries × 25)\n", formatInt(indexSize), formatInt(int64(len(result.Entries))))
        fmt.Printf("  Delta:      %s bytes\n", formatInt(int64(len(result.DeltaData))))
        fmt.Printf("  Total:      %s bytes (%.2f MB)\n", formatInt(totalDedupSize), float64(totalDedupSize)/(1024*1024))
        fmt.Printf("  Savings:    %.1f%% reduction\n", savings)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">//go:build !debug

package main

// parseCPUProfileFlag is a no-op in release builds.
// The --cpuprofile flag is only available in debug builds (go build -tags debug).
func parseCPUProfileFlag(args []string) ([]string, string) <span class="cov0" title="0">{
        return args, ""
}</span>

// debugOptionsHelp returns empty string in release builds.
func debugOptionsHelp() string <span class="cov10" title="4">{
        return ""
}</span>

// startCPUProfile is a no-op in release builds.
func startCPUProfile(_ string) func() <span class="cov0" title="0">{
        return func() </span>{<span class="cov0" title="0">}</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package daemon provides daemonization support for mkvdup FUSE mount.
//
// It uses a re-exec pattern where the parent process spawns a child with
// an environment variable marker. The child signals readiness to the parent
// via a pipe, allowing the parent to return success/failure appropriately.
package daemon

import (
        "errors"
        "fmt"
        "io"
        "os"
        "os/exec"
        "strconv"
        "strings"
        "syscall"
        "time"

        "golang.org/x/sys/unix"
)

// childEnvVar is the environment variable that marks a child daemon process.
const childEnvVar = "MKVDUP_DAEMON_CHILD"

// readyPipeFdEnvVar is the environment variable containing the pipe fd for signaling.
const readyPipeFdEnvVar = "MKVDUP_READY_PIPE_FD"

// Status codes sent from child to parent via the ready pipe.
const (
        statusReady byte = 0 // Mount successful
        statusError byte = 1 // Mount failed
)

// IsChild returns true if the current process is a daemon child.
func IsChild() bool <span class="cov7" title="8">{
        return os.Getenv(childEnvVar) == "1"
}</span>

// Daemonize spawns the current executable as a background daemon.
// It waits for the child to signal readiness or error via a pipe.
// Returns nil on success (child signaled ready) or error on failure.
// The timeout specifies how long to wait for the child to signal.
func Daemonize(pidFile string, timeout time.Duration) error <span class="cov0" title="0">{
        // Create pipe for child to signal readiness
        readPipe, writePipe, err := os.Pipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create pipe: %w", err)
        }</span>
        <span class="cov0" title="0">defer readPipe.Close()

        // Build command with same arguments
        cmd := exec.Command(os.Args[0], os.Args[1:]...)

        // Set up environment
        cmd.Env = append(os.Environ(),
                childEnvVar+"=1",
                readyPipeFdEnvVar+"=3", // fd 3 is after stdin/stdout/stderr
        )

        // Pass write end of pipe to child as fd 3
        cmd.ExtraFiles = []*os.File{writePipe}

        // Detach from terminal
        cmd.Stdin = nil
        cmd.Stdout = nil
        cmd.Stderr = nil
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setsid: true, // Create new session
        }

        // Start child process
        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                writePipe.Close()
                return fmt.Errorf("start daemon: %w", err)
        }</span>

        // Close write end in parent (child has it)
        <span class="cov0" title="0">writePipe.Close()

        // Wait for child to signal with timeout
        resultChan := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                status := make([]byte, 1)
                n, err := readPipe.Read(status)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                                resultChan &lt;- fmt.Errorf("daemon child exited unexpectedly")
                        }</span> else<span class="cov0" title="0"> {
                                resultChan &lt;- fmt.Errorf("read from child: %w", err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">if n != 1 </span><span class="cov0" title="0">{
                        resultChan &lt;- fmt.Errorf("unexpected read size from child: %d", n)
                        return
                }</span>

                <span class="cov0" title="0">if status[0] == statusReady </span><span class="cov0" title="0">{
                        resultChan &lt;- nil
                }</span> else<span class="cov0" title="0"> {
                        // Read full error message until EOF to avoid truncation
                        errMsg, readErr := io.ReadAll(readPipe)
                        if readErr != nil &amp;&amp; !errors.Is(readErr, io.EOF) </span><span class="cov0" title="0">{
                                resultChan &lt;- fmt.Errorf("daemon failed (error reading message): %v", readErr)
                                return
                        }</span>
                        <span class="cov0" title="0">if len(errMsg) &gt; 0 </span><span class="cov0" title="0">{
                                resultChan &lt;- fmt.Errorf("daemon failed: %s", string(errMsg))
                        }</span> else<span class="cov0" title="0"> {
                                resultChan &lt;- fmt.Errorf("daemon failed with unknown error")
                        }</span>
                }
        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-resultChan:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        // Try to clean up the child
                        if cmd.Process != nil </span><span class="cov0" title="0">{
                                cmd.Process.Kill()
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                // Success - child is running and mount is ready
                <span class="cov0" title="0">if pidFile != "" </span><span class="cov0" title="0">{
                        // Write PID file from parent since child may not have permission
                        if err := WritePidFile(pidFile, cmd.Process.Pid); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "warning: failed to write pid file: %v\n", err)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                // Close pipe to unblock the goroutine waiting on Read()
                readPipe.Close()
                if cmd.Process != nil </span><span class="cov0" title="0">{
                        cmd.Process.Kill()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("daemon startup timed out after %v", timeout)</span>
        }
}

// NotifyReady signals to the parent that the mount is ready.
// This should be called by the child after the FUSE mount is ready.
func NotifyReady() error <span class="cov5" title="4">{
        fd, err := getReadyPipeFd()
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov3" title="2">pipe := os.NewFile(fd, "ready-pipe")
        if pipe == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid pipe fd")
        }</span>
        <span class="cov3" title="2">defer pipe.Close()

        _, err = pipe.Write([]byte{statusReady})
        return err</span>
}

// NotifyError signals to the parent that the mount failed.
// This should be called by the child if an error occurs during startup.
func NotifyError(mountErr error) error <span class="cov6" title="6">{
        fd, err := getReadyPipeFd()
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov5" title="4">pipe := os.NewFile(fd, "ready-pipe")
        if pipe == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid pipe fd")
        }</span>
        <span class="cov5" title="4">defer pipe.Close()

        // Write error status followed by error message
        _, err = pipe.Write([]byte{statusError})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="4">_, err = pipe.Write([]byte(mountErr.Error()))
        return err</span>
}

// getReadyPipeFd returns the file descriptor for the ready pipe.
func getReadyPipeFd() (uintptr, error) <span class="cov10" title="16">{
        fdStr := os.Getenv(readyPipeFdEnvVar)
        if fdStr == "" </span><span class="cov6" title="6">{
                return 0, fmt.Errorf("not running as daemon child")
        }</span>
        <span class="cov8" title="10">fd, err := strconv.ParseUint(fdStr, 10, strconv.IntSize)
        if err != nil </span><span class="cov3" title="2">{
                return 0, fmt.Errorf("invalid pipe fd: %w", err)
        }</span>
        <span class="cov7" title="8">return uintptr(fd), nil</span>
}

// Detach closes stdin, stdout, and stderr to fully detach from the terminal.
// This should be called by the child after signaling ready.
func Detach() <span class="cov0" title="0">{
        // Redirect standard file descriptors to /dev/null
        devNull, err := os.OpenFile("/dev/null", os.O_RDWR, 0)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "daemon: failed to open /dev/null: %v\n", err)
                return
        }</span>

        // Replace stdin, stdout, stderr with /dev/null
        // Use unix.Dup2 for cross-architecture compatibility (syscall.Dup2 not available on arm64)
        // Errors are logged but not fatal since the daemon can still function
        <span class="cov0" title="0">if err := unix.Dup2(int(devNull.Fd()), int(os.Stdin.Fd())); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "daemon: failed to redirect stdin: %v\n", err)
        }</span>
        <span class="cov0" title="0">if err := unix.Dup2(int(devNull.Fd()), int(os.Stdout.Fd())); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "daemon: failed to redirect stdout: %v\n", err)
        }</span>
        <span class="cov0" title="0">if err := unix.Dup2(int(devNull.Fd()), int(os.Stderr.Fd())); err != nil </span><span class="cov0" title="0">{
                // stderr may already be redirected, best effort
                _ = err
        }</span>
        <span class="cov0" title="0">if err := devNull.Close(); err != nil </span><span class="cov0" title="0">{
                // Can't log since stderr may be redirected
                _ = err
        }</span>
}

// WritePidFile writes the given PID to a file.
func WritePidFile(path string, pid int) error <span class="cov7" title="8">{
        return os.WriteFile(path, []byte(strconv.Itoa(pid)+"\n"), 0644)
}</span>

// RemovePidFile removes the PID file at the given path.
func RemovePidFile(path string) error <span class="cov5" title="4">{
        return os.Remove(path)
}</span>

// ReadPidFile reads a PID from the given file path.
func ReadPidFile(path string) (int, error) <span class="cov10" title="16">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov5" title="4">{
                return 0, fmt.Errorf("read pid file: %w", err)
        }</span>
        <span class="cov9" title="12">pidStr := strings.TrimSpace(string(data))
        pid, err := strconv.Atoi(pidStr)
        if err != nil </span><span class="cov3" title="2">{
                return 0, fmt.Errorf("invalid pid in %s: %w", path, err)
        }</span>
        <span class="cov8" title="10">if pid &lt;= 0 </span><span class="cov5" title="4">{
                return 0, fmt.Errorf("invalid pid %d in %s", pid, path)
        }</span>
        <span class="cov6" title="6">return pid, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package dedup

import (
        "fmt"
        "log"
        "os"
        "path/filepath"
        "sort"

        "github.com/bmatcuk/doublestar/v4"
        "gopkg.in/yaml.v3"
)

// Config represents the contents of a .mkvdup.yaml file.
type Config struct {
        Name      string `yaml:"name"`
        DedupFile string `yaml:"dedup_file"`
        SourceDir string `yaml:"source_dir"`
}

// configFile is the internal YAML representation that supports includes
// and virtual_files in addition to the standard Config fields.
type configFile struct {
        Name         string   `yaml:"name"`
        DedupFile    string   `yaml:"dedup_file"`
        SourceDir    string   `yaml:"source_dir"`
        Includes     []string `yaml:"includes"`
        VirtualFiles []Config `yaml:"virtual_files"`
}

// WriteConfig writes the .mkvdup.yaml config file.
func WriteConfig(configPath, name, dedupFile, sourceDir string) error <span class="cov5" title="16">{
        content := fmt.Sprintf(`# Auto-generated by mkvdup create
name: %q
dedup_file: %q
source_dir: %q
`, name, dedupFile, sourceDir)

        return os.WriteFile(configPath, []byte(content), 0644)
}</span>

// ReadConfig reads a .mkvdup.yaml config file.
func ReadConfig(configPath string) (*Config, error) <span class="cov6" title="27">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov3" title="4">{
                return nil, fmt.Errorf("read config file: %w", err)
        }</span>

        <span class="cov6" title="23">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov3" title="4">{
                return nil, fmt.Errorf("parse config %s: %w", configPath, err)
        }</span>

        <span class="cov5" title="19">if config.Name == "" || config.DedupFile == "" || config.SourceDir == "" </span><span class="cov4" title="10">{
                return nil, fmt.Errorf("invalid config: missing required fields")
        }</span>

        <span class="cov4" title="9">return &amp;config, nil</span>
}

// ResolveConfigs reads config files and recursively expands includes and
// virtual_files into a flat list of Config entries. Cycle detection prevents
// infinite recursion from circular includes.
func ResolveConfigs(configPaths []string) ([]Config, error) <span class="cov8" title="90">{
        seen := make(map[string]bool)
        var all []Config
        for _, p := range configPaths </span><span class="cov8" title="94">{
                configs, err := resolveConfig(p, seen)
                if err != nil </span><span class="cov5" title="12">{
                        return nil, err
                }</span>
                <span class="cov8" title="82">all = append(all, configs...)</span>
        }
        <span class="cov8" title="78">return all, nil</span>
}

// resolveConfig recursively resolves a single config file.
func resolveConfig(configPath string, seen map[string]bool) ([]Config, error) <span class="cov8" title="116">{
        absPath, err := filepath.Abs(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resolve path %s: %w", configPath, err)
        }</span>

        // Resolve symlinks for reliable cycle detection.
        <span class="cov8" title="116">realPath, err := filepath.EvalSymlinks(absPath)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("resolve symlinks %s: %w", absPath, err)
        }</span>

        <span class="cov8" title="114">if seen[realPath] </span><span class="cov3" title="4">{
                log.Printf("warning: skipping already-seen config %s (cycle detection)", realPath)
                return nil, nil
        }</span>
        <span class="cov8" title="110">seen[realPath] = true

        data, err := os.ReadFile(realPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read config file %s: %w", realPath, err)
        }</span>

        <span class="cov8" title="110">var cf configFile
        if err := yaml.Unmarshal(data, &amp;cf); err != nil </span><span class="cov3" title="4">{
                return nil, fmt.Errorf("parse config %s: %w", realPath, err)
        }</span>

        <span class="cov8" title="106">configDir := filepath.Dir(realPath)
        var configs []Config

        // If top-level name/dedup_file/source_dir are set, add as a Config entry.
        hasName := cf.Name != ""
        hasDedup := cf.DedupFile != ""
        hasSource := cf.SourceDir != ""
        if hasName || hasDedup || hasSource </span><span class="cov8" title="80">{
                if !hasName || !hasDedup || !hasSource </span><span class="cov3" title="4">{
                        return nil, fmt.Errorf("config %s: name, dedup_file, and source_dir must all be set if any is set", realPath)
                }</span>
                <span class="cov8" title="76">configs = append(configs, Config{
                        Name:      cf.Name,
                        DedupFile: resolveRelative(configDir, cf.DedupFile),
                        SourceDir: resolveRelative(configDir, cf.SourceDir),
                })</span>
        }

        // Process includes.
        <span class="cov8" title="102">for _, pattern := range cf.Includes </span><span class="cov6" title="22">{
                pattern = resolveRelative(configDir, pattern)
                matches, err := doublestar.FilepathGlob(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expand include pattern %q in %s: %w", pattern, realPath, err)
                }</span>
                <span class="cov6" title="22">sort.Strings(matches)
                for _, match := range matches </span><span class="cov6" title="22">{
                        sub, err := resolveConfig(match, seen)
                        if err != nil </span><span class="cov2" title="2">{
                                return nil, err
                        }</span>
                        <span class="cov5" title="20">configs = append(configs, sub...)</span>
                }
        }

        // Process virtual_files.
        <span class="cov8" title="100">for _, vf := range cf.VirtualFiles </span><span class="cov5" title="14">{
                if vf.Name == "" || vf.DedupFile == "" || vf.SourceDir == "" </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("config %s: virtual_files entry missing required fields (name, dedup_file, source_dir)", realPath)
                }</span>
                <span class="cov5" title="12">configs = append(configs, Config{
                        Name:      vf.Name,
                        DedupFile: resolveRelative(configDir, vf.DedupFile),
                        SourceDir: resolveRelative(configDir, vf.SourceDir),
                })</span>
        }

        <span class="cov8" title="98">return configs, nil</span>
}

// BatchManifest represents the batch create manifest file format.
type BatchManifest struct {
        SourceDir string              `yaml:"source_dir"`
        Files     []BatchManifestFile `yaml:"files"`
}

// BatchManifestFile represents a single file entry in a batch manifest.
type BatchManifestFile struct {
        MKV    string `yaml:"mkv"`
        Output string `yaml:"output"`
        Name   string `yaml:"name"`
}

// ReadBatchManifest reads and validates a batch manifest file.
// Relative paths are resolved against the manifest file's directory.
// Default values are applied for optional fields.
func ReadBatchManifest(manifestPath string) (*BatchManifest, error) <span class="cov5" title="20">{
        data, err := os.ReadFile(manifestPath)
        if err != nil </span><span class="cov3" title="4">{
                return nil, fmt.Errorf("read batch manifest: %w", err)
        }</span>

        <span class="cov5" title="16">var manifest BatchManifest
        if err := yaml.Unmarshal(data, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse batch manifest %s: %w", manifestPath, err)
        }</span>

        <span class="cov5" title="16">if manifest.SourceDir == "" </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("batch manifest %s: source_dir is required", manifestPath)
        }</span>
        <span class="cov5" title="14">if len(manifest.Files) == 0 </span><span class="cov3" title="4">{
                return nil, fmt.Errorf("batch manifest %s: files list is empty", manifestPath)
        }</span>

        <span class="cov4" title="10">absPath, err := filepath.Abs(manifestPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resolve manifest path: %w", err)
        }</span>
        <span class="cov4" title="10">manifestDir := filepath.Dir(absPath)

        // Resolve source_dir relative to manifest
        manifest.SourceDir = resolveRelative(manifestDir, manifest.SourceDir)

        // Validate and resolve each file entry
        for i := range manifest.Files </span><span class="cov5" title="16">{
                f := &amp;manifest.Files[i]
                if f.MKV == "" </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("batch manifest %s: files[%d] missing required 'mkv' field", manifestPath, i)
                }</span>
                <span class="cov5" title="14">f.MKV = resolveRelative(manifestDir, f.MKV)

                // Apply defaults
                if f.Output == "" </span><span class="cov4" title="8">{
                        f.Output = f.MKV + ".mkvdup"
                }</span> else<span class="cov3" title="6"> {
                        f.Output = resolveRelative(manifestDir, f.Output)
                }</span>
                <span class="cov5" title="14">if f.Name == "" </span><span class="cov4" title="10">{
                        f.Name = filepath.Base(f.MKV)
                }</span>
        }

        <span class="cov4" title="8">return &amp;manifest, nil</span>
}

// resolveRelative resolves a path relative to baseDir. If the path is already
// absolute, it is returned unchanged.
func resolveRelative(baseDir, path string) string <span class="cov10" title="228">{
        if filepath.IsAbs(path) </span><span class="cov9" title="196">{
                return path
        }</span>
        <span class="cov6" title="32">return filepath.Join(baseDir, path)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package dedup provides reading and writing of .mkvdup deduplication files.
package dedup

import (
        "encoding/binary"

        "github.com/stuckj/mkvdup/internal/matcher"
        "github.com/stuckj/mkvdup/internal/source"
)

// File format constants
const (
        Magic   = "MKVDUP01"
        Version = 3 // v3: Source field expanded to uint16 for &gt;256 source files
        // HeaderSize = Magic(8) + Version(4) + Flags(4) + OriginalSize(8) + OriginalChecksum(8) +
        //              SourceType(1) + UsesESOffsets(1) + SourceFileCount(2) + EntryCount(8) +
        //              DeltaOffset(8) + DeltaSize(8) = 60 bytes
        HeaderSize  = 60
        EntrySize   = 28 // Fixed entry size: 8+8+2+8+1+1 = 28 bytes
        FooterSize  = 24
        MagicSize   = 8
        VersionSize = 4
)

// Source types
const (
        SourceTypeDVD    uint8 = 0
        SourceTypeBluray uint8 = 1
)

// Header represents the fixed header at the start of a .mkvdup file.
type Header struct {
        Magic            [8]byte // "MKVDUP01"
        Version          uint32  // File format version
        Flags            uint32  // Reserved for future use
        OriginalSize     int64   // Size of original MKV file
        OriginalChecksum uint64  // xxhash of original MKV file
        SourceType       uint8   // 0=DVD, 1=Blu-ray
        UsesESOffsets    uint8   // 1 if source uses ES offsets (MPEG-PS)
        SourceFileCount  uint16  // Number of source files
        EntryCount       uint64  // Number of index entries
        DeltaOffset      int64   // Offset to delta section
        DeltaSize        int64   // Size of delta section
}

// SourceFile represents a source file entry in the dedup file.
type SourceFile struct {
        RelativePath string // Path relative to source directory
        Size         int64  // File size
        Checksum     uint64 // xxhash of file
}

// Entry represents an index entry in the dedup file.
// This mirrors matcher.Entry but is specifically for serialization.
type Entry struct {
        MkvOffset        int64  // Start offset in the MKV file
        Length           int64  // Length of this region
        Source           uint16 // 0 = delta, 1+ = source file index + 1 (supports up to 65535 files)
        SourceOffset     int64  // Offset in source file (or ES offset)
        IsVideo          bool   // For ES-based sources
        AudioSubStreamID byte   // For ES-based audio sub-streams
}

// RawEntry matches the 28-byte on-disk entry format exactly.
// Uses byte arrays for int64 fields to handle unaligned access portably.
// This enables direct memory-mapped access without parsing into []Entry.
type RawEntry struct {
        MkvOffset        [8]byte // int64, little-endian
        Length           [8]byte // int64, little-endian
        Source           [2]byte // uint16, little-endian
        SourceOffset     [8]byte // int64, little-endian (unaligned at byte 18)
        ESFlags          uint8   // bit 0 = IsVideo
        AudioSubStreamID uint8
}

// ToEntry converts a RawEntry to an Entry by parsing the byte arrays.
func (r *RawEntry) ToEntry() Entry <span class="cov10" title="1229793">{
        return Entry{
                MkvOffset:        int64(binary.LittleEndian.Uint64(r.MkvOffset[:])),
                Length:           int64(binary.LittleEndian.Uint64(r.Length[:])),
                Source:           binary.LittleEndian.Uint16(r.Source[:]),
                SourceOffset:     int64(binary.LittleEndian.Uint64(r.SourceOffset[:])),
                IsVideo:          r.ESFlags&amp;1 == 1,
                AudioSubStreamID: r.AudioSubStreamID,
        }
}</span>

// Footer represents the footer at the end of a .mkvdup file.
type Footer struct {
        IndexChecksum uint64  // xxhash of index section
        DeltaChecksum uint64  // xxhash of delta section
        Magic         [8]byte // "MKVDUP01" (for reverse scanning)
}

// File represents a complete dedup file structure for reconstruction.
// Note: Entries are accessed directly from mmap via Reader.getEntry(),
// not stored in this struct, to avoid large memory allocation.
type File struct {
        Header        Header
        SourceFiles   []SourceFile
        DeltaOffset   int64 // Offset to delta section in file
        UsesESOffsets bool
}

// ToMatcherEntry converts a dedup Entry to a matcher Entry.
func (e *Entry) ToMatcherEntry() matcher.Entry <span class="cov0" title="0">{
        return matcher.Entry{
                MkvOffset:        e.MkvOffset,
                Length:           e.Length,
                Source:           e.Source,
                SourceOffset:     e.SourceOffset,
                IsVideo:          e.IsVideo,
                AudioSubStreamID: e.AudioSubStreamID,
        }
}</span>

// FromMatcherEntry creates a dedup Entry from a matcher Entry.
func FromMatcherEntry(e matcher.Entry) Entry <span class="cov9" title="856960">{
        return Entry{
                MkvOffset:        e.MkvOffset,
                Length:           e.Length,
                Source:           e.Source,
                SourceOffset:     e.SourceOffset,
                IsVideo:          e.IsVideo,
                AudioSubStreamID: e.AudioSubStreamID,
        }
}</span>

// ToSourceFile converts source.File to dedup SourceFile.
func ToSourceFile(sf source.File) SourceFile <span class="cov3" title="70">{
        return SourceFile{
                RelativePath: sf.RelativePath,
                Size:         sf.Size,
                Checksum:     sf.Checksum,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package dedup

import (
        "encoding/binary"
        "fmt"
        "io"
        "os"
        "sort"
        "sync"

        "github.com/cespare/xxhash/v2"
        "github.com/stuckj/mkvdup/internal/mmap"
)

// blockSize is the block size for the block index.
// Each block maps an MKV offset range to an entry index for O(1) lookup.
// 64KB balances memory overhead vs scan distance.
const blockSize = 64 * 1024

// Reader reads .mkvdup files and provides data reconstruction.
// Reader is safe for concurrent use from multiple goroutines.
type Reader struct {
        file        *File
        dedupMmap   *mmap.File
        dedupPath   string
        sourceDir   string
        sourceMmaps []*mmap.File
        esReader    ESReader  // For ES-based sources (v1 only, deprecated in v2)
        entriesOnce sync.Once // For lazy entry access initialization
        entriesErr  error     // Error from entry access initialization

        // Direct mmap access to entries (no []Entry allocation)
        indexStart int64 // Byte offset where entries begin in file
        entryCount int   // Number of entries

        // Block index for fast entry lookup on cache miss.
        // Maps block_number (MKV offset / blockSize) → entry index for O(1)
        // narrowing, followed by bounded binary search within the block range.
        // Built once in initEntryAccess; immutable after that (no mutex needed).
        blockIndex []int

        // Last-entry cache for O(1) sequential read lookup
        // Protected by cacheMu for concurrent access safety
        cacheMu        sync.Mutex
        lastEntryIdx   int   // Index of last accessed entry (-1 if none)
        lastEntry      Entry // The cached parsed entry
        lastEntryValid bool  // Whether lastEntry is valid
}

// ESReader interface for reading ES data from MPEG-PS sources.
type ESReader interface {
        ReadESData(esOffset int64, size int, isVideo bool) ([]byte, error)
        ReadAudioSubStreamData(subStreamID byte, esOffset int64, size int) ([]byte, error)
}

// NewReader opens a dedup file for reading with entry access initialized immediately.
// Use NewReaderLazy for faster initialization when entries can be accessed on first read.
func NewReader(dedupPath, sourceDir string) (*Reader, error) <span class="cov3" title="96">{
        r, err := NewReaderLazy(dedupPath, sourceDir)
        if err != nil </span><span class="cov2" title="14">{
                return nil, err
        }</span>

        // Force immediate entry access initialization
        <span class="cov3" title="82">if err := r.initEntryAccess(); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return nil, fmt.Errorf("init entry access: %w", err)
        }</span>

        <span class="cov3" title="82">return r, nil</span>
}

// NewReaderLazy opens a dedup file but only reads the header.
// Entries are loaded lazily on first Read. Use this for fast mount times with many files.
func NewReaderLazy(dedupPath, sourceDir string) (*Reader, error) <span class="cov3" title="191">{
        f, err := os.Open(dedupPath)
        if err != nil </span><span class="cov2" title="8">{
                return nil, fmt.Errorf("open dedup file: %w", err)
        }</span>
        <span class="cov3" title="183">defer f.Close()

        file, err := parseHeaderOnly(f)
        if err != nil </span><span class="cov2" title="10">{
                return nil, fmt.Errorf("parse dedup header: %w", err)
        }</span>

        // Memory-map the dedup file
        <span class="cov3" title="173">dedupMmap, err := mmap.Open(dedupPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mmap dedup file: %w", err)
        }</span>

        <span class="cov3" title="173">return &amp;Reader{
                file:         file,
                dedupMmap:    dedupMmap,
                dedupPath:    dedupPath,
                sourceDir:    sourceDir,
                lastEntryIdx: -1, // No entry cached yet
        }, nil</span>
}

// SetESReader sets the ES reader for ES-based sources.
func (r *Reader) SetESReader(esReader ESReader) <span class="cov1" title="2">{
        r.esReader = esReader
}</span>

// LoadSourceFiles memory-maps all source files.
func (r *Reader) LoadSourceFiles() error <span class="cov2" title="15">{
        r.sourceMmaps = make([]*mmap.File, len(r.file.SourceFiles))
        for i, sf := range r.file.SourceFiles </span><span class="cov2" title="15">{
                path := r.sourceDir + "/" + sf.RelativePath
                m, err := mmap.Open(path)
                if err != nil </span><span class="cov1" title="2">{
                        // Clean up already opened files
                        for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                if r.sourceMmaps[j] != nil </span><span class="cov0" title="0">{
                                        r.sourceMmaps[j].Close()
                                }</span>
                        }
                        <span class="cov1" title="2">return fmt.Errorf("mmap source file %s: %w", sf.RelativePath, err)</span>
                }
                <span class="cov2" title="13">r.sourceMmaps[i] = m</span>
        }
        <span class="cov2" title="13">return nil</span>
}

// Close releases all resources.
func (r *Reader) Close() error <span class="cov3" title="169">{
        if r.dedupMmap != nil </span><span class="cov3" title="169">{
                r.dedupMmap.Close()
        }</span>
        <span class="cov3" title="169">for _, m := range r.sourceMmaps </span><span class="cov2" title="9">{
                if m != nil </span><span class="cov2" title="7">{
                        m.Close()
                }</span>
        }
        <span class="cov3" title="169">return nil</span>
}

// initEntryAccess initializes direct mmap access to entries (no parsing into []Entry).
// This is called lazily on first entry access.
func (r *Reader) initEntryAccess() error <span class="cov6" title="8030">{
        r.entriesOnce.Do(func() </span><span class="cov3" title="111">{
                // Calculate index start offset
                r.indexStart = int64(HeaderSize) + r.calculateSourceFilesSize()
                r.entryCount = int(r.file.Header.EntryCount)

                // Validate mmap has enough data for all entries
                requiredSize := r.indexStart + int64(r.entryCount)*EntrySize
                if int64(r.dedupMmap.Size()) &lt; requiredSize </span><span class="cov0" title="0">{
                        r.entriesErr = fmt.Errorf("mmap too small: need %d, have %d",
                                requiredSize, r.dedupMmap.Size())
                        return
                }</span>

                // Build block index for fast random access lookup
                <span class="cov3" title="111">r.buildBlockIndex()</span>
        })
        <span class="cov6" title="8030">return r.entriesErr</span>
}

// buildBlockIndex creates a mapping from block numbers to entry indices.
// Each block represents a fixed-size range of MKV offsets. The index maps
// block_number → the entry index whose region covers or precedes that block's
// start offset. This narrows binary search from O(log N) over all entries
// to O(log B) within a single block's entries.
//
// Algorithm: single pass over all entries, filling block slots as we go.
// Time: O(entryCount + blockCount), Space: O(blockCount).
func (r *Reader) buildBlockIndex() <span class="cov3" title="111">{
        originalSize := r.file.Header.OriginalSize
        if originalSize &lt;= 0 || r.entryCount == 0 </span><span class="cov2" title="24">{
                return
        }</span>

        <span class="cov3" title="87">blockCount := int((originalSize + blockSize - 1) / blockSize)
        r.blockIndex = make([]int, blockCount)

        entryIdx := 0
        for b := range blockCount </span><span class="cov7" title="189165">{
                blockStart := int64(b) * blockSize
                // Advance entryIdx to the last entry whose MkvOffset &lt;= blockStart.
                // For block 0 (blockStart=0), this stays at 0 since no entry precedes it.
                for entryIdx+1 &lt; r.entryCount </span><span class="cov9" title="7928226">{
                        nextOffset, ok := r.getMkvOffset(entryIdx + 1)
                        if !ok || nextOffset &gt; blockStart </span><span class="cov7" title="187980">{
                                break</span>
                        }
                        <span class="cov9" title="7740246">entryIdx++</span>
                }
                <span class="cov7" title="189165">r.blockIndex[b] = entryIdx</span>
        }
}

// getEntry returns the entry at the given index by parsing from mmap.
// Uses cache for O(1) sequential access. Safe for concurrent use.
func (r *Reader) getEntry(idx int) (Entry, bool) <span class="cov8" title="1229813">{
        if idx &lt; 0 || idx &gt;= r.entryCount </span><span class="cov2" title="6">{
                return Entry{}, false
        }</span>

        // Check cache first (with lock)
        <span class="cov8" title="1229807">r.cacheMu.Lock()
        if r.lastEntryValid &amp;&amp; r.lastEntryIdx == idx </span><span class="cov2" title="28">{
                entry := r.lastEntry
                r.cacheMu.Unlock()
                return entry, true
        }</span>
        <span class="cov8" title="1229779">r.cacheMu.Unlock()

        // Parse entry from mmap using RawEntry (no lock needed - mmap is read-only)
        offset := r.indexStart + int64(idx)*EntrySize
        data := r.dedupMmap.Slice(offset, EntrySize)
        if len(data) &lt; EntrySize </span><span class="cov0" title="0">{
                return Entry{}, false
        }</span>

        // Parse using RawEntry for portable unaligned access
        // Layout: MkvOffset(8) + Length(8) + Source(2) + SourceOffset(8) + ESFlags(1) + AudioSubStreamID(1) = 28
        <span class="cov8" title="1229779">var raw RawEntry
        copy(raw.MkvOffset[:], data[0:8])
        copy(raw.Length[:], data[8:16])
        copy(raw.Source[:], data[16:18])
        copy(raw.SourceOffset[:], data[18:26])
        raw.ESFlags = data[26]
        raw.AudioSubStreamID = data[27]

        entry := raw.ToEntry()

        // Update cache (with lock)
        r.cacheMu.Lock()
        r.lastEntryIdx = idx
        r.lastEntry = entry
        r.lastEntryValid = true
        r.cacheMu.Unlock()

        return entry, true</span>
}

// getMkvOffset returns just the MkvOffset for entry at idx (for binary search).
// This avoids full entry parsing when only the offset is needed.
func (r *Reader) getMkvOffset(idx int) (int64, bool) <span class="cov10" title="7972600">{
        if idx &lt; 0 || idx &gt;= r.entryCount </span><span class="cov1" title="4">{
                return 0, false
        }</span>

        <span class="cov9" title="7972596">offset := r.indexStart + int64(idx)*EntrySize
        data := r.dedupMmap.Slice(offset, 8) // Only read MkvOffset field (first 8 bytes)
        if len(data) &lt; 8 </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov9" title="7972596">return int64(binary.LittleEndian.Uint64(data)), true</span>
}

// getEntryLength returns just the Length for entry at idx (for binary search).
// This avoids full entry parsing when only offset and length are needed.
func (r *Reader) getEntryLength(idx int) (int64, bool) <span class="cov7" title="44374">{
        if idx &lt; 0 || idx &gt;= r.entryCount </span><span class="cov1" title="4">{
                return 0, false
        }</span>

        // Length is at offset 8 within each entry (after MkvOffset)
        <span class="cov7" title="44370">offset := r.indexStart + int64(idx)*EntrySize + 8
        data := r.dedupMmap.Slice(offset, 8)
        if len(data) &lt; 8 </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov7" title="44370">return int64(binary.LittleEndian.Uint64(data)), true</span>
}

// OriginalSize returns the size of the original MKV file.
func (r *Reader) OriginalSize() int64 <span class="cov3" title="73">{
        return r.file.Header.OriginalSize
}</span>

// OriginalChecksum returns the checksum of the original MKV file.
func (r *Reader) OriginalChecksum() uint64 <span class="cov1" title="2">{
        return r.file.Header.OriginalChecksum
}</span>

// SourceFiles returns the list of source files.
func (r *Reader) SourceFiles() []SourceFile <span class="cov2" title="16">{
        return r.file.SourceFiles
}</span>

// EntryCount returns the number of index entries.
// Returns 0 if entry access initialization failed. Use InitEntryAccess() to check for errors.
func (r *Reader) EntryCount() int <span class="cov2" title="12">{
        r.initEntryAccess() // Ensure entryCount is initialized
        return r.entryCount
}</span>

// InitEntryAccess explicitly initializes entry access and returns any error.
// This is useful when you need to check for initialization errors before calling
// methods like EntryCount() or Info() that silently return zero/empty on error.
func (r *Reader) InitEntryAccess() error <span class="cov1" title="4">{
        return r.initEntryAccess()
}</span>

// UsesESOffsets returns true if this dedup file uses ES offsets.
func (r *Reader) UsesESOffsets() bool <span class="cov2" title="17">{
        return r.file.UsesESOffsets
}</span>

// ReadAt reads reconstructed MKV data at the given offset.
func (r *Reader) ReadAt(buf []byte, offset int64) (int, error) <span class="cov6" title="7890">{
        // Initialize entry access on first read (lazy initialization)
        if err := r.initEntryAccess(); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("init entry access: %w", err)
        }</span>

        <span class="cov6" title="7890">if offset &gt;= r.file.Header.OriginalSize </span><span class="cov2" title="6">{
                return 0, io.EOF
        }</span>

        <span class="cov6" title="7884">totalRead := 0
        remaining := len(buf)
        originalOffset := offset // Preserve original offset for buffer position calculation

        // Limit read to file size
        if offset+int64(remaining) &gt; r.file.Header.OriginalSize </span><span class="cov0" title="0">{
                remaining = int(r.file.Header.OriginalSize - offset)
        }</span>

        // Find entries that cover this range
        <span class="cov6" title="7884">entries := r.findEntriesForRange(offset, int64(remaining))

        for _, entry := range entries </span><span class="cov8" title="1219665">{
                if remaining &lt;= 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Calculate overlap
                <span class="cov8" title="1219665">entryEnd := entry.MkvOffset + entry.Length
                readStart := offset
                if readStart &lt; entry.MkvOffset </span><span class="cov0" title="0">{
                        readStart = entry.MkvOffset
                }</span>
                <span class="cov8" title="1219665">readEnd := offset + int64(remaining)
                if readEnd &gt; entryEnd </span><span class="cov8" title="1211783">{
                        readEnd = entryEnd
                }</span>

                <span class="cov8" title="1219665">readLen := int(readEnd - readStart)
                if readLen &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Calculate offset within entry
                <span class="cov8" title="1219665">offsetInEntry := readStart - entry.MkvOffset
                sourceOffset := entry.SourceOffset + offsetInEntry

                // Read data from appropriate source
                var data []byte
                var err error

                if entry.Source == 0 </span><span class="cov7" title="208707">{
                        // Read from delta section
                        data, err = r.readDelta(sourceOffset, readLen)
                }</span> else<span class="cov8" title="1010958"> if r.file.UsesESOffsets &amp;&amp; r.esReader != nil </span><span class="cov0" title="0">{
                        // Read from ES
                        if entry.IsVideo </span><span class="cov0" title="0">{
                                data, err = r.esReader.ReadESData(sourceOffset, readLen, true)
                        }</span> else<span class="cov0" title="0"> {
                                data, err = r.esReader.ReadAudioSubStreamData(entry.AudioSubStreamID, sourceOffset, readLen)
                        }</span>
                } else<span class="cov8" title="1010958"> {
                        // Read from raw source file
                        fileIndex := int(entry.Source - 1)
                        data, err = r.readSource(fileIndex, sourceOffset, readLen)
                }</span>

                <span class="cov8" title="1219665">if err != nil </span><span class="cov0" title="0">{
                        return totalRead, fmt.Errorf("read at offset %d: %w", readStart, err)
                }</span>

                // Copy to output buffer - use original offset to calculate buffer position
                <span class="cov8" title="1219665">bufOffset := int(readStart - originalOffset)
                copy(buf[bufOffset:], data)
                totalRead += len(data)
                remaining -= len(data)
                offset = readEnd</span>
        }

        <span class="cov6" title="7884">if totalRead == 0 &amp;&amp; len(buf) &gt; 0 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>

        <span class="cov6" title="7884">return totalRead, nil</span>
}

func (r *Reader) findEntriesForRange(offset, length int64) []Entry <span class="cov6" title="7894">{
        if r.entryCount == 0 </span><span class="cov1" title="2">{
                return nil
        }</span>

        <span class="cov6" title="7892">endOffset := offset + length

        // Fast path: check if offset is within cached entry (with lock)
        r.cacheMu.Lock()
        if r.lastEntryValid &amp;&amp; r.lastEntryIdx &gt;= 0 &amp;&amp; r.lastEntryIdx &lt; r.entryCount </span><span class="cov6" title="7869">{
                if offset &gt;= r.lastEntry.MkvOffset &amp;&amp; offset &lt; r.lastEntry.MkvOffset+r.lastEntry.Length </span><span class="cov2" title="8">{
                        // Cache hit - start from cached entry
                        startIdx := r.lastEntryIdx
                        r.cacheMu.Unlock()

                        var result []Entry
                        for i := startIdx; i &lt; r.entryCount; i++ </span><span class="cov4" title="424">{
                                entry, ok := r.getEntry(i)
                                if !ok || entry.MkvOffset &gt;= endOffset </span><span class="cov1" title="5">{
                                        break</span>
                                }
                                <span class="cov4" title="419">result = append(result, entry)</span>
                        }
                        <span class="cov2" title="8">return result</span>
                }
        }
        <span class="cov6" title="7884">r.cacheMu.Unlock()

        // Cache miss - use block index to narrow binary search range
        var lo, hi int
        if r.blockIndex != nil </span><span class="cov6" title="7884">{
                blockNum := int(offset / blockSize)
                if blockNum &gt;= len(r.blockIndex) </span><span class="cov0" title="0">{
                        blockNum = len(r.blockIndex) - 1
                }</span>
                <span class="cov6" title="7884">lo = r.blockIndex[blockNum]

                // Upper bound: start of next block's entries (or entryCount)
                if blockNum+1 &lt; len(r.blockIndex) </span><span class="cov6" title="7884">{
                        // Search up to 1 past the next block's start entry to handle
                        // entries that span block boundaries
                        hi = r.blockIndex[blockNum+1] + 1
                        if hi &gt; r.entryCount </span><span class="cov0" title="0">{
                                hi = r.entryCount
                        }</span>
                } else<span class="cov0" title="0"> {
                        hi = r.entryCount
                }</span>
        } else<span class="cov0" title="0"> {
                lo = 0
                hi = r.entryCount
        }</span>

        // Binary search within [lo, hi) for first entry whose range covers offset
        <span class="cov6" title="7884">idx := lo + sort.Search(hi-lo, func(i int) bool </span><span class="cov7" title="44364">{
                mkvOffset, ok := r.getMkvOffset(lo + i)
                if !ok </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov7" title="44364">entryLen, ok := r.getEntryLength(lo + i)
                if !ok </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov7" title="44364">return mkvOffset+entryLen &gt; offset</span>
        })

        <span class="cov6" title="7884">var result []Entry
        for i := idx; i &lt; r.entryCount; i++ </span><span class="cov8" title="1227135">{
                entry, ok := r.getEntry(i)
                if !ok || entry.MkvOffset &gt;= endOffset </span><span class="cov6" title="7879">{
                        break</span>
                }
                <span class="cov8" title="1219256">result = append(result, entry)</span>
        }

        <span class="cov6" title="7884">return result</span>
}

func (r *Reader) readDelta(offset int64, size int) ([]byte, error) <span class="cov7" title="208707">{
        fileOffset := r.file.DeltaOffset + offset
        // Zero-copy slice from mmap'd data
        data := r.dedupMmap.Slice(fileOffset, size)
        if data == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("delta offset out of range")
        }</span>
        <span class="cov7" title="208707">return data, nil</span>
}

func (r *Reader) readSource(fileIndex int, offset int64, size int) ([]byte, error) <span class="cov8" title="1010958">{
        if fileIndex &lt; 0 || fileIndex &gt;= len(r.sourceMmaps) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid file index: %d", fileIndex)
        }</span>
        <span class="cov8" title="1010958">if r.sourceMmaps[fileIndex] == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("source file %d not loaded", fileIndex)
        }</span>

        // Zero-copy slice from mmap'd data
        <span class="cov8" title="1010958">data := r.sourceMmaps[fileIndex].Slice(offset, size)
        if data == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("source offset out of range")
        }</span>
        <span class="cov8" title="1010958">return data, nil</span>
}

// parseHeaderOnly parses just the header and source files (not entries) for fast initialization.
func parseHeaderOnly(r io.Reader) (*File, error) <span class="cov3" title="183">{
        file := &amp;File{}

        // Read and verify magic
        magic := make([]byte, MagicSize)
        if _, err := io.ReadFull(r, magic); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read magic: %w", err)
        }</span>
        <span class="cov3" title="183">if string(magic) != Magic </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("invalid magic: %s", magic)
        }</span>
        <span class="cov3" title="181">copy(file.Header.Magic[:], magic)

        // Read version
        if err := binary.Read(r, binary.LittleEndian, &amp;file.Header.Version); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read version: %w", err)
        }</span>
        // Support current version (3) only. Older versions must be recreated.
        <span class="cov3" title="181">if file.Header.Version != Version </span><span class="cov2" title="6">{
                if file.Header.Version == 1 </span><span class="cov1" title="2">{
                        return nil, fmt.Errorf("unsupported version 1 (uses ES offsets); please recreate with 'mkvdup create'")
                }</span>
                <span class="cov1" title="4">if file.Header.Version == 2 </span><span class="cov1" title="2">{
                        return nil, fmt.Errorf("unsupported version 2 (uses uint8 source index); please recreate with 'mkvdup create'")
                }</span>
                <span class="cov1" title="2">return nil, fmt.Errorf("unsupported version: %d (expected %d)", file.Header.Version, Version)</span>
        }

        // Read flags
        <span class="cov3" title="175">if err := binary.Read(r, binary.LittleEndian, &amp;file.Header.Flags); err != nil </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("read flags: %w", err)
        }</span>

        // Read original size
        <span class="cov3" title="173">if err := binary.Read(r, binary.LittleEndian, &amp;file.Header.OriginalSize); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read original size: %w", err)
        }</span>

        // Read original checksum
        <span class="cov3" title="173">if err := binary.Read(r, binary.LittleEndian, &amp;file.Header.OriginalChecksum); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read original checksum: %w", err)
        }</span>

        // Read source type
        <span class="cov3" title="173">if err := binary.Read(r, binary.LittleEndian, &amp;file.Header.SourceType); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read source type: %w", err)
        }</span>

        // Read uses ES offsets flag
        <span class="cov3" title="173">if err := binary.Read(r, binary.LittleEndian, &amp;file.Header.UsesESOffsets); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read uses ES offsets: %w", err)
        }</span>
        <span class="cov3" title="173">file.UsesESOffsets = file.Header.UsesESOffsets == 1

        // Read source file count
        if err := binary.Read(r, binary.LittleEndian, &amp;file.Header.SourceFileCount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read source file count: %w", err)
        }</span>

        // Read entry count
        <span class="cov3" title="173">if err := binary.Read(r, binary.LittleEndian, &amp;file.Header.EntryCount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read entry count: %w", err)
        }</span>

        // Read delta offset
        <span class="cov3" title="173">if err := binary.Read(r, binary.LittleEndian, &amp;file.Header.DeltaOffset); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read delta offset: %w", err)
        }</span>
        <span class="cov3" title="173">file.DeltaOffset = file.Header.DeltaOffset

        // Read delta size
        if err := binary.Read(r, binary.LittleEndian, &amp;file.Header.DeltaSize); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read delta size: %w", err)
        }</span>

        // Read source files
        <span class="cov3" title="173">file.SourceFiles = make([]SourceFile, file.Header.SourceFileCount)
        for i := range file.SourceFiles </span><span class="cov3" title="151">{
                var pathLen uint16
                if err := binary.Read(r, binary.LittleEndian, &amp;pathLen); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("read path length: %w", err)
                }</span>

                <span class="cov3" title="151">path := make([]byte, pathLen)
                if _, err := io.ReadFull(r, path); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("read path: %w", err)
                }</span>
                <span class="cov3" title="151">file.SourceFiles[i].RelativePath = string(path)

                if err := binary.Read(r, binary.LittleEndian, &amp;file.SourceFiles[i].Size); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("read file size: %w", err)
                }</span>

                <span class="cov3" title="151">if err := binary.Read(r, binary.LittleEndian, &amp;file.SourceFiles[i].Checksum); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("read file checksum: %w", err)
                }</span>
        }

        // Entries are accessed directly from mmap via Reader.getEntry()
        <span class="cov3" title="173">return file, nil</span>
}

// VerifyIntegrity verifies the dedup file checksums.
func (r *Reader) VerifyIntegrity() error <span class="cov2" title="27">{
        // Initialize entry access to get entryCount
        if err := r.initEntryAccess(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("init entry access: %w", err)
        }</span>

        <span class="cov2" title="27">f, err := os.Open(r.dedupPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open dedup file: %w", err)
        }</span>
        <span class="cov2" title="27">defer f.Close()

        // Get file size
        stat, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stat dedup file: %w", err)
        }</span>

        // Read footer
        <span class="cov2" title="27">footerOffset := stat.Size() - FooterSize
        if _, err := f.Seek(footerOffset, 0); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("seek to footer: %w", err)
        }</span>

        <span class="cov2" title="27">var footer Footer
        if err := binary.Read(f, binary.LittleEndian, &amp;footer.IndexChecksum); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read index checksum: %w", err)
        }</span>
        <span class="cov2" title="27">if err := binary.Read(f, binary.LittleEndian, &amp;footer.DeltaChecksum); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read delta checksum: %w", err)
        }</span>
        <span class="cov2" title="27">footerMagic := make([]byte, MagicSize)
        if _, err := io.ReadFull(f, footerMagic); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read footer magic: %w", err)
        }</span>
        <span class="cov2" title="27">if string(footerMagic) != Magic </span><span class="cov1" title="2">{
                return fmt.Errorf("invalid footer magic")
        }</span>

        // Calculate and verify index checksum (zero-copy)
        <span class="cov2" title="25">indexSize := int(int64(r.entryCount) * EntrySize)
        indexData := r.dedupMmap.Slice(r.indexStart, indexSize)
        if indexData == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read index for checksum: slice out of range")
        }</span>
        <span class="cov2" title="25">if xxhash.Sum64(indexData) != footer.IndexChecksum </span><span class="cov1" title="2">{
                return fmt.Errorf("index checksum mismatch")
        }</span>

        // Calculate and verify delta checksum (zero-copy)
        <span class="cov2" title="23">deltaData := r.dedupMmap.Slice(r.file.DeltaOffset, int(r.file.Header.DeltaSize))
        if deltaData == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read delta for checksum: slice out of range")
        }</span>
        <span class="cov2" title="23">if xxhash.Sum64(deltaData) != footer.DeltaChecksum </span><span class="cov1" title="4">{
                return fmt.Errorf("delta checksum mismatch")
        }</span>

        <span class="cov2" title="19">return nil</span>
}

func (r *Reader) calculateSourceFilesSize() int64 <span class="cov3" title="111">{
        var size int64
        for _, sf := range r.file.SourceFiles </span><span class="cov3" title="85">{
                size += 2 + int64(len(sf.RelativePath)) + 8 + 8
        }</span>
        <span class="cov3" title="111">return size</span>
}

// Info returns a summary of the dedup file.
// If entry access initialization failed, the "error" key will contain the error message
// and "entry_count" will be 0.
func (r *Reader) Info() map[string]any <span class="cov2" title="15">{
        err := r.initEntryAccess() // Ensure entryCount is initialized
        info := map[string]any{
                "version":           r.file.Header.Version,
                "original_size":     r.file.Header.OriginalSize,
                "original_checksum": r.file.Header.OriginalChecksum,
                "source_type":       r.file.Header.SourceType,
                "uses_es_offsets":   r.file.UsesESOffsets,
                "source_file_count": len(r.file.SourceFiles),
                "entry_count":       r.entryCount,
                "delta_size":        r.file.Header.DeltaSize,
        }
        if err != nil </span><span class="cov0" title="0">{
                info["error"] = err.Error()
        }</span>
        <span class="cov2" title="15">return info</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package dedup

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "io"
        "os"

        "github.com/cespare/xxhash/v2"
        "github.com/stuckj/mkvdup/internal/matcher"
        "github.com/stuckj/mkvdup/internal/source"
)

// Writer creates .mkvdup files.
type Writer struct {
        file        *os.File
        header      Header
        sourceFiles []SourceFile
        entries     []Entry
        deltaData   []byte
}

// NewWriter creates a new dedup file writer.
func NewWriter(path string) (*Writer, error) <span class="cov3" title="96">{
        f, err := os.Create(path)
        if err != nil </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("create file: %w", err)
        }</span>
        <span class="cov3" title="94">return &amp;Writer{file: f}, nil</span>
}

// SetHeader sets the header information.
// In v2, UsesESOffsets is always 0 (raw offsets are stored instead).
func (w *Writer) SetHeader(originalSize int64, originalChecksum uint64, sourceType source.Type) <span class="cov3" title="90">{
        copy(w.header.Magic[:], Magic)
        w.header.Version = Version
        w.header.Flags = 0
        w.header.OriginalSize = originalSize
        w.header.OriginalChecksum = originalChecksum
        w.header.UsesESOffsets = 0 // v2 always uses raw offsets

        switch sourceType </span>{
        case source.TypeDVD:<span class="cov3" title="81">
                w.header.SourceType = SourceTypeDVD</span>
        case source.TypeBluray:<span class="cov2" title="9">
                w.header.SourceType = SourceTypeBluray</span>
        }
}

// SetSourceFiles sets the source file list.
func (w *Writer) SetSourceFiles(files []source.File) <span class="cov3" title="66">{
        w.sourceFiles = make([]SourceFile, len(files))
        for i, sf := range files </span><span class="cov3" title="70">{
                w.sourceFiles[i] = ToSourceFile(sf)
        }</span>
        <span class="cov3" title="66">w.header.SourceFileCount = uint16(len(files))</span>
}

// SetMatchResult sets the match result (entries and delta).
// If esConverters is provided and non-empty, ES-offset entries will be converted
// to raw-offset entries, potentially splitting entries that span multiple ranges.
func (w *Writer) SetMatchResult(result *matcher.Result, esConverters []source.ESRangeConverter) error <span class="cov3" title="90">{
        // Convert matcher entries to dedup entries
        entries := make([]Entry, len(result.Entries))
        for i, e := range result.Entries </span><span class="cov9" title="856960">{
                entries[i] = FromMatcherEntry(e)
        }</span>

        // Convert ES offsets to raw offsets if we have converters
        <span class="cov3" title="90">if len(esConverters) &gt; 0 </span><span class="cov2" title="11">{
                var err error
                entries, err = w.convertESToRawOffsets(entries, esConverters)
                if err != nil </span><span class="cov1" title="2">{
                        return fmt.Errorf("convert ES to raw offsets: %w", err)
                }</span>
        }

        <span class="cov3" title="88">w.entries = entries
        w.deltaData = result.DeltaData
        w.header.EntryCount = uint64(len(w.entries))
        w.header.DeltaSize = int64(len(result.DeltaData))
        return nil</span>
}

// convertESToRawOffsets converts ES-offset entries to raw-offset entries.
// Entries that span multiple PES payload ranges are split into multiple entries.
func (w *Writer) convertESToRawOffsets(entries []Entry, esConverters []source.ESRangeConverter) ([]Entry, error) <span class="cov2" title="11">{
        // Pre-allocate with ~2x capacity since entries typically expand to multiple raw ranges
        result := make([]Entry, 0, len(entries)*2)

        for _, entry := range entries </span><span class="cov9" title="733081">{
                if entry.Source == 0 </span><span class="cov8" title="366542">{
                        // Delta entry - no conversion needed
                        result = append(result, entry)
                        continue</span>
                }

                // Get the ES converter for this source file
                <span class="cov8" title="366539">fileIndex := int(entry.Source - 1)
                if fileIndex &gt;= len(esConverters) || esConverters[fileIndex] == nil </span><span class="cov0" title="0">{
                        // No converter available - assume raw offsets already
                        result = append(result, entry)
                        continue</span>
                }
                <span class="cov8" title="366539">converter := esConverters[fileIndex]

                // Get raw ranges for this ES region
                var rawRanges []source.RawRange
                var err error
                if entry.IsVideo </span><span class="cov8" title="163239">{
                        rawRanges, err = converter.RawRangesForESRegion(entry.SourceOffset, int(entry.Length), true)
                }</span> else<span class="cov8" title="203300"> {
                        rawRanges, err = converter.RawRangesForAudioSubStream(entry.AudioSubStreamID, entry.SourceOffset, int(entry.Length))
                }</span>
                <span class="cov8" title="366539">if err != nil </span><span class="cov1" title="2">{
                        return nil, fmt.Errorf("convert entry at MKV offset %d: %w", entry.MkvOffset, err)
                }</span>

                // Create one entry per raw range
                <span class="cov8" title="366537">mkvOffset := entry.MkvOffset
                for _, rr := range rawRanges </span><span class="cov9" title="2353474">{
                        result = append(result, Entry{
                                MkvOffset:        mkvOffset,
                                Length:           int64(rr.Size),
                                Source:           entry.Source,
                                SourceOffset:     rr.FileOffset, // Raw file offset!
                                IsVideo:          entry.IsVideo,
                                AudioSubStreamID: entry.AudioSubStreamID,
                        })
                        mkvOffset += int64(rr.Size)
                }</span>
        }

        <span class="cov2" title="9">return result, nil</span>
}

// WriteProgressFunc is called to report write progress.
type WriteProgressFunc func(written, total int64)

// Write writes the dedup file.
func (w *Writer) Write() error <span class="cov3" title="86">{
        return w.WriteWithProgress(nil)
}</span>

// WriteWithProgress writes the dedup file with progress reporting.
func (w *Writer) WriteWithProgress(progress WriteProgressFunc) error <span class="cov3" title="88">{
        // Calculate offsets and total size
        sourceFilesSize := w.calculateSourceFilesSize()
        indexSize := int64(len(w.entries)) * EntrySize
        deltaOffset := int64(HeaderSize) + sourceFilesSize + indexSize
        w.header.DeltaOffset = deltaOffset

        totalSize := deltaOffset + w.header.DeltaSize + FooterSize
        var written int64

        // Write header
        if err := w.writeHeader(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write header: %w", err)
        }</span>
        <span class="cov3" title="88">written += HeaderSize

        // Write source files section
        if err := w.writeSourceFiles(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write source files: %w", err)
        }</span>
        <span class="cov3" title="88">written += sourceFilesSize

        // Write index entries and calculate checksum
        indexChecksum, err := w.writeEntriesWithProgress(progress, &amp;written, totalSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write entries: %w", err)
        }</span>

        // Write delta data and calculate checksum
        <span class="cov3" title="88">deltaChecksum, err := w.writeDeltaWithProgress(progress, &amp;written, totalSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write delta: %w", err)
        }</span>

        // Write footer
        <span class="cov3" title="88">if err := w.writeFooter(indexChecksum, deltaChecksum); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write footer: %w", err)
        }</span>

        <span class="cov3" title="88">if progress != nil </span><span class="cov1" title="2">{
                progress(totalSize, totalSize)
        }</span>

        <span class="cov3" title="88">return nil</span>
}

// Close closes the writer.
func (w *Writer) Close() error <span class="cov3" title="96">{
        if w.file != nil </span><span class="cov3" title="96">{
                return w.file.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (w *Writer) calculateSourceFilesSize() int64 <span class="cov3" title="88">{
        var size int64
        for _, sf := range w.sourceFiles </span><span class="cov3" title="70">{
                // PathLen (2) + Path (variable) + Size (8) + Checksum (8)
                size += 2 + int64(len(sf.RelativePath)) + 8 + 8
        }</span>
        <span class="cov3" title="88">return size</span>
}

func (w *Writer) writeHeader() error <span class="cov3" title="88">{
        // Write magic
        if _, err := w.file.Write([]byte(Magic)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write version
        <span class="cov3" title="88">if err := binary.Write(w.file, binary.LittleEndian, w.header.Version); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write flags
        <span class="cov3" title="88">if err := binary.Write(w.file, binary.LittleEndian, w.header.Flags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write original size
        <span class="cov3" title="88">if err := binary.Write(w.file, binary.LittleEndian, w.header.OriginalSize); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write original checksum
        <span class="cov3" title="88">if err := binary.Write(w.file, binary.LittleEndian, w.header.OriginalChecksum); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write source type
        <span class="cov3" title="88">if err := binary.Write(w.file, binary.LittleEndian, w.header.SourceType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write uses ES offsets flag
        <span class="cov3" title="88">if err := binary.Write(w.file, binary.LittleEndian, w.header.UsesESOffsets); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write source file count
        <span class="cov3" title="88">if err := binary.Write(w.file, binary.LittleEndian, w.header.SourceFileCount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write entry count
        <span class="cov3" title="88">if err := binary.Write(w.file, binary.LittleEndian, w.header.EntryCount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write delta offset
        <span class="cov3" title="88">if err := binary.Write(w.file, binary.LittleEndian, w.header.DeltaOffset); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write delta size
        <span class="cov3" title="88">if err := binary.Write(w.file, binary.LittleEndian, w.header.DeltaSize); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="88">return nil</span>
}

func (w *Writer) writeSourceFiles() error <span class="cov3" title="88">{
        for _, sf := range w.sourceFiles </span><span class="cov3" title="70">{
                // Write path length
                pathLen := uint16(len(sf.RelativePath))
                if err := binary.Write(w.file, binary.LittleEndian, pathLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Write path
                <span class="cov3" title="70">if _, err := w.file.Write([]byte(sf.RelativePath)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Write size
                <span class="cov3" title="70">if err := binary.Write(w.file, binary.LittleEndian, sf.Size); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Write checksum
                <span class="cov3" title="70">if err := binary.Write(w.file, binary.LittleEndian, sf.Checksum); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov3" title="88">return nil</span>
}

func (w *Writer) writeEntriesWithProgress(progress WriteProgressFunc, written *int64, total int64) (uint64, error) <span class="cov3" title="88">{
        hasher := xxhash.New()
        // Use buffered writer to batch syscalls (64KB buffer)
        bufWriter := bufio.NewWriterSize(w.file, 64*1024)
        writer := io.MultiWriter(bufWriter, hasher)

        entryCount := len(w.entries)
        lastProgress := 0

        // Reusable buffer for entry serialization (allocation-free per entry)
        var entryBuf [EntrySize]byte

        for i, entry := range w.entries </span><span class="cov10" title="2843895">{
                // Serialize entry to buffer using allocation-free Put* functions
                binary.LittleEndian.PutUint64(entryBuf[0:8], uint64(entry.MkvOffset))
                binary.LittleEndian.PutUint64(entryBuf[8:16], uint64(entry.Length))
                binary.LittleEndian.PutUint16(entryBuf[16:18], entry.Source)
                binary.LittleEndian.PutUint64(entryBuf[18:26], uint64(entry.SourceOffset))

                // ES flags byte: bit 0 = IsVideo
                var esFlags uint8
                if entry.IsVideo </span><span class="cov9" title="2137829">{
                        esFlags = 1
                }</span>
                <span class="cov10" title="2843895">entryBuf[26] = esFlags
                entryBuf[27] = entry.AudioSubStreamID

                // Single write per entry
                if _, err := writer.Write(entryBuf[:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov10" title="2843895">*written += EntrySize

                // Report progress every 1% or 10000 entries
                if progress != nil &amp;&amp; entryCount &gt; 0 </span><span class="cov1" title="4">{
                        pct := (i + 1) * 100 / entryCount
                        if pct &gt; lastProgress || (i+1)%10000 == 0 </span><span class="cov1" title="4">{
                                progress(*written, total)
                                lastProgress = pct
                        }</span>
                }
        }

        // Flush buffered writer
        <span class="cov3" title="88">if err := bufWriter.Flush(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov3" title="88">return hasher.Sum64(), nil</span>
}

func (w *Writer) writeDeltaWithProgress(progress WriteProgressFunc, written *int64, total int64) (uint64, error) <span class="cov3" title="88">{
        hasher := xxhash.New()

        // Write delta in chunks to report progress
        const chunkSize = 64 * 1024 // 64KB chunks
        data := w.deltaData
        lastProgress := 0

        for len(data) &gt; 0 </span><span class="cov6" title="13940">{
                chunk := data
                if len(chunk) &gt; chunkSize </span><span class="cov6" title="13858">{
                        chunk = data[:chunkSize]
                }</span>
                <span class="cov6" title="13940">data = data[len(chunk):]

                // Write to file
                if _, err := w.file.Write(chunk); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                // Update hash
                <span class="cov6" title="13940">hasher.Write(chunk)

                *written += int64(len(chunk))

                // Report progress every chunk
                if progress != nil &amp;&amp; w.header.DeltaSize &gt; 0 </span><span class="cov1" title="2">{
                        pct := int((*written * 100) / total)
                        if pct &gt; lastProgress </span><span class="cov1" title="2">{
                                progress(*written, total)
                                lastProgress = pct
                        }</span>
                }
        }

        <span class="cov3" title="88">return hasher.Sum64(), nil</span>
}

func (w *Writer) writeFooter(indexChecksum, deltaChecksum uint64) error <span class="cov3" title="88">{
        // Write index checksum
        if err := binary.Write(w.file, binary.LittleEndian, indexChecksum); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write delta checksum
        <span class="cov3" title="88">if err := binary.Write(w.file, binary.LittleEndian, deltaChecksum); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write magic
        <span class="cov3" title="88">if _, err := w.file.Write([]byte(Magic)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="88">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package fuse

import (
        "fmt"

        "github.com/stuckj/mkvdup/internal/dedup"
        "github.com/stuckj/mkvdup/internal/source"
)

// Ensure adapters implement interfaces
var _ ReaderInitializer = (*dedupReaderAdapter)(nil)
var _ ReaderFactory = (*DefaultReaderFactory)(nil)
var _ ConfigReader = (*DefaultConfigReader)(nil)

// dedupReaderAdapter wraps dedup.Reader to implement ReaderInitializer interface.
type dedupReaderAdapter struct {
        reader *dedup.Reader
        // index stores the source index for cleanup when using ES offsets.
        // This is nil when using raw source files.
        index *source.Index
}

func (a *dedupReaderAdapter) OriginalSize() int64 <span class="cov4" title="25">{
        return a.reader.OriginalSize()
}</span>

func (a *dedupReaderAdapter) UsesESOffsets() bool <span class="cov1" title="2">{
        return a.reader.UsesESOffsets()
}</span>

func (a *dedupReaderAdapter) InitializeForReading(sourceDir string) error <span class="cov3" title="7">{
        if a.reader.UsesESOffsets() </span><span class="cov0" title="0">{
                // Create indexer to get ES reader
                indexer, err := source.NewIndexer(sourceDir, source.DefaultWindowSize)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create indexer: %w", err)
                }</span>
                <span class="cov0" title="0">if err := indexer.Build(nil); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("build index: %w", err)
                }</span>
                <span class="cov0" title="0">index := indexer.Index()
                if len(index.ESReaders) &gt; 0 </span><span class="cov0" title="0">{
                        a.reader.SetESReader(index.ESReaders[0])
                }</span>
                // Store index for cleanup in Close()
                <span class="cov0" title="0">a.index = index</span>
        } else<span class="cov3" title="7"> {
                // Load source files for raw access
                if err := a.reader.LoadSourceFiles(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("load source files: %w", err)
                }</span>
        }
        <span class="cov3" title="7">return nil</span>
}

func (a *dedupReaderAdapter) ReadAt(p []byte, off int64) (n int, err error) <span class="cov10" title="6274">{
        return a.reader.ReadAt(p, off)
}</span>

func (a *dedupReaderAdapter) Close() error <span class="cov4" title="31">{
        var errs []error
        if err := a.reader.Close(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>
        <span class="cov4" title="31">if a.index != nil </span><span class="cov1" title="2">{
                if err := a.index.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov4" title="31">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return errs[0]
        }</span>
        <span class="cov4" title="31">return nil</span>
}

// DefaultReaderFactory is the default implementation of ReaderFactory.
type DefaultReaderFactory struct{}

func (f *DefaultReaderFactory) NewReaderLazy(dedupPath, sourceDir string) (ReaderInitializer, error) <span class="cov4" title="31">{
        reader, err := dedup.NewReaderLazy(dedupPath, sourceDir)
        if err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>
        <span class="cov4" title="29">return &amp;dedupReaderAdapter{reader: reader}, nil</span>
}

// DefaultConfigReader is the default implementation of ConfigReader.
type DefaultConfigReader struct{}

func (r *DefaultConfigReader) ReadConfig(path string) (*Config, error) <span class="cov3" title="7">{
        config, err := dedup.ReadConfig(path)
        if err != nil </span><span class="cov2" title="4">{
                return nil, err
        }</span>
        <span class="cov2" title="3">return &amp;Config{
                Name:      config.Name,
                DedupFile: config.DedupFile,
                SourceDir: config.SourceDir,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package fuse provides a FUSE filesystem for accessing deduplicated MKV files.
package fuse

import (
        "context"
        "fmt"
        "log"
        "path/filepath"
        "sort"
        "sync"
        "syscall"
        "time"

        "github.com/hanwen/go-fuse/v2/fs"
        "github.com/hanwen/go-fuse/v2/fuse"
        "github.com/stuckj/mkvdup/internal/dedup"
)

// MKVFile represents a virtual MKV file backed by a dedup file.
type MKVFile struct {
        Name      string
        DedupPath string
        SourceDir string
        Size      int64
        reader    DedupReader
        mu        sync.RWMutex

        // Factory for lazy initialization (injected from root)
        readerFactory ReaderFactory
}

// MKVFSRoot is the root node of the FUSE filesystem.
type MKVFSRoot struct {
        fs.Inode

        // Directory tree for hierarchical file organization
        rootDir *MKVFSDirNode

        // Flat map for O(1) lookup by full path (kept for backwards compatibility)
        files map[string]*MKVFile

        mu      sync.RWMutex
        verbose bool

        // Factories for dependency injection (allows mocking in tests)
        readerFactory ReaderFactory
        configReader  ConfigReader

        // Permission store for chmod/chown support
        permStore *PermissionStore
}

// MKVFSNode represents a file node in the FUSE filesystem.
type MKVFSNode struct {
        fs.Inode
        file      *MKVFile
        path      string // full path for permission lookups
        verbose   bool
        permStore *PermissionStore
}

// MKVFSDirNode represents a directory node in the FUSE filesystem.
type MKVFSDirNode struct {
        fs.Inode
        name    string                   // basename (e.g., "Action")
        path    string                   // full path from root (e.g., "Movies/Action")
        files   map[string]*MKVFile      // files directly in this directory
        subdirs map[string]*MKVFSDirNode // child directories
        mu      sync.RWMutex
        verbose bool

        // Factory for creating file nodes (injected from root)
        readerFactory ReaderFactory

        // Permission store for chmod/chown support
        permStore *PermissionStore
}

// Ensure interfaces are implemented
var _ fs.InodeEmbedder = (*MKVFSRoot)(nil)
var _ fs.InodeEmbedder = (*MKVFSNode)(nil)
var _ fs.InodeEmbedder = (*MKVFSDirNode)(nil)
var _ fs.NodeReaddirer = (*MKVFSRoot)(nil)
var _ fs.NodeLookuper = (*MKVFSRoot)(nil)
var _ fs.NodeGetattrer = (*MKVFSRoot)(nil)
var _ fs.NodeReaddirer = (*MKVFSDirNode)(nil)
var _ fs.NodeLookuper = (*MKVFSDirNode)(nil)
var _ fs.NodeGetattrer = (*MKVFSDirNode)(nil)
var _ fs.NodeMkdirer = (*MKVFSDirNode)(nil)
var _ fs.NodeRmdirer = (*MKVFSDirNode)(nil)
var _ fs.NodeUnlinker = (*MKVFSDirNode)(nil)
var _ fs.NodeCreater = (*MKVFSDirNode)(nil)
var _ fs.NodeOpener = (*MKVFSNode)(nil)
var _ fs.NodeReader = (*MKVFSNode)(nil)
var _ fs.NodeGetattrer = (*MKVFSNode)(nil)
var _ fs.NodeSetattrer = (*MKVFSNode)(nil)
var _ fs.NodeSetattrer = (*MKVFSDirNode)(nil)

// getFilePerms returns file permissions from the store, or defaults if store is nil.
func getFilePerms(store *PermissionStore, path string) (uid, gid, mode uint32) <span class="cov10" title="25135">{
        if store != nil </span><span class="cov4" title="56">{
                return store.GetFilePerms(path)
        }</span>
        <span class="cov9" title="25079">return 0, 0, 0444</span>
}

// getDirPerms returns directory permissions from the store, or defaults if store is nil.
func getDirPerms(store *PermissionStore, path string) (uid, gid, mode uint32) <span class="cov5" title="119">{
        if store != nil </span><span class="cov4" title="54">{
                return store.GetDirPerms(path)
        }</span>
        <span class="cov4" title="65">return 0, 0, 0555</span>
}

// NewMKVFS creates a new MKVFS root from a list of config files.
// Config files are resolved recursively (includes and virtual_files are expanded).
// Set verbose=true to enable debug logging.
func NewMKVFS(configPaths []string, verbose bool) (*MKVFSRoot, error) <span class="cov3" title="11">{
        configs, err := dedup.ResolveConfigs(configPaths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resolve configs: %w", err)
        }</span>
        <span class="cov3" title="11">return NewMKVFSFromConfigs(configs, verbose, &amp;DefaultReaderFactory{}, nil)</span>
}

// NewMKVFSWithPermissions creates a new MKVFS root with a permission store.
// Config files are resolved recursively (includes and virtual_files are expanded).
func NewMKVFSWithPermissions(configPaths []string, verbose bool, permStore *PermissionStore) (*MKVFSRoot, error) <span class="cov0" title="0">{
        configs, err := dedup.ResolveConfigs(configPaths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resolve configs: %w", err)
        }</span>
        <span class="cov0" title="0">return NewMKVFSFromConfigs(configs, verbose, &amp;DefaultReaderFactory{}, permStore)</span>
}

// MKVFSOptions contains options for creating an MKVFS filesystem.
type MKVFSOptions struct {
        Verbose         bool
        PermissionsPath string
        // Defaults holds the default permissions to use when a PermissionStore is configured.
        // If nil, DefaultPerms() is used. Set to a non-nil value to use specific defaults.
        // Note: explicit-zero defaults only work when provided programmatically here;
        // they are not persisted to or loaded from the permissions YAML file.
        Defaults *Defaults
}

// NewMKVFSWithOptions creates a new MKVFS root with the given options.
// Config files are resolved recursively (includes and virtual_files are expanded).
func NewMKVFSWithOptions(configPaths []string, opts MKVFSOptions) (*MKVFSRoot, error) <span class="cov2" title="7">{
        var permStore *PermissionStore
        if opts.PermissionsPath != "" </span><span class="cov2" title="7">{
                defaults := DefaultPerms()
                if opts.Defaults != nil </span><span class="cov2" title="7">{
                        defaults = *opts.Defaults
                }</span>
                <span class="cov2" title="7">permStore = NewPermissionStore(opts.PermissionsPath, defaults, opts.Verbose)
                if err := permStore.Load(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("load permissions: %w", err)
                }</span>
        }
        <span class="cov2" title="7">configs, err := dedup.ResolveConfigs(configPaths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resolve configs: %w", err)
        }</span>
        <span class="cov2" title="7">return NewMKVFSFromConfigs(configs, opts.Verbose, &amp;DefaultReaderFactory{}, permStore)</span>
}

// NewMKVFSWithFactories creates a new MKVFS root with custom factories.
// This allows injecting mock implementations for testing.
func NewMKVFSWithFactories(configPaths []string, verbose bool, readerFactory ReaderFactory, configReader ConfigReader, permStore *PermissionStore) (*MKVFSRoot, error) <span class="cov3" title="16">{
        root := &amp;MKVFSRoot{
                files:         make(map[string]*MKVFile),
                verbose:       verbose,
                readerFactory: readerFactory,
                configReader:  configReader,
                permStore:     permStore,
        }

        if verbose </span><span class="cov0" title="0">{
                log.Printf("Creating MKVFS with %d config files", len(configPaths))
        }</span>

        <span class="cov3" title="16">for _, configPath := range configPaths </span><span class="cov3" title="22">{
                if verbose </span><span class="cov0" title="0">{
                        log.Printf("Reading config: %s", configPath)
                }</span>
                <span class="cov3" title="22">config, err := root.configReader.ReadConfig(configPath)
                if err != nil </span><span class="cov1" title="2">{
                        return nil, fmt.Errorf("read config %s: %w", configPath, err)
                }</span>
                <span class="cov3" title="20">if verbose </span><span class="cov0" title="0">{
                        log.Printf("Config: name=%s, dedup=%s, source=%s", config.Name, config.DedupFile, config.SourceDir)
                }</span>

                // Resolve relative paths
                <span class="cov3" title="20">configDir := filepath.Dir(configPath)
                dedupPath := config.DedupFile
                if !filepath.IsAbs(dedupPath) </span><span class="cov1" title="2">{
                        dedupPath = filepath.Join(configDir, dedupPath)
                }</span>
                <span class="cov3" title="20">sourceDir := config.SourceDir
                if !filepath.IsAbs(sourceDir) </span><span class="cov1" title="2">{
                        sourceDir = filepath.Join(configDir, sourceDir)
                }</span>

                // Open dedup file to get size (lazy loading - only reads header)
                <span class="cov3" title="20">if verbose </span><span class="cov0" title="0">{
                        log.Printf("Opening dedup file: %s", dedupPath)
                }</span>
                <span class="cov3" title="20">reader, err := root.readerFactory.NewReaderLazy(dedupPath, sourceDir)
                if err != nil </span><span class="cov1" title="2">{
                        if verbose </span><span class="cov0" title="0">{
                                log.Printf("Failed to open dedup file: %v", err)
                        }</span>
                        <span class="cov1" title="2">return nil, fmt.Errorf("open dedup file %s: %w", dedupPath, err)</span>
                }

                <span class="cov3" title="18">mkvFile := &amp;MKVFile{
                        Name:          config.Name,
                        DedupPath:     dedupPath,
                        SourceDir:     sourceDir,
                        Size:          reader.OriginalSize(),
                        readerFactory: root.readerFactory,
                }

                // Don't keep reader open - we'll open it lazily
                reader.Close()

                root.files[config.Name] = mkvFile
                if verbose </span><span class="cov0" title="0">{
                        log.Printf("Added file: %s (size=%d)", config.Name, mkvFile.Size)
                }</span>
        }

        <span class="cov3" title="12">if verbose </span><span class="cov0" title="0">{
                log.Printf("Total files: %d", len(root.files))
        }</span>

        // Build directory tree from collected files
        <span class="cov3" title="12">fileList := make([]*MKVFile, 0, len(root.files))
        for _, f := range root.files </span><span class="cov3" title="18">{
                fileList = append(fileList, f)
        }</span>
        <span class="cov3" title="12">root.rootDir = BuildDirectoryTree(fileList, verbose, readerFactory, permStore)

        // Clean up stale permission entries if we have a permission store
        if permStore != nil </span><span class="cov1" title="2">{
                validFiles, validDirs := root.collectValidPaths()
                removed := permStore.CleanupStale(validFiles, validDirs)
                if removed &gt; 0 </span><span class="cov0" title="0">{
                        if verbose </span><span class="cov0" title="0">{
                                log.Printf("Cleaned up %d stale permission entries", removed)
                        }</span>
                        <span class="cov0" title="0">if err := permStore.Save(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to save permissions after cleanup: %v", err)
                        }</span>
                }
        }

        <span class="cov3" title="12">if verbose </span><span class="cov0" title="0">{
                log.Printf("Directory tree built with %d root entries", len(root.rootDir.files)+len(root.rootDir.subdirs))
        }</span>

        <span class="cov3" title="12">return root, nil</span>
}

// NewMKVFSFromConfigs creates a new MKVFS root from already-resolved configs.
// Paths in configs must already be absolute (as returned by dedup.ResolveConfigs).
func NewMKVFSFromConfigs(configs []dedup.Config, verbose bool, readerFactory ReaderFactory, permStore *PermissionStore) (*MKVFSRoot, error) <span class="cov4" title="30">{
        root := &amp;MKVFSRoot{
                files:         make(map[string]*MKVFile),
                verbose:       verbose,
                readerFactory: readerFactory,
                permStore:     permStore,
        }

        if verbose </span><span class="cov1" title="1">{
                log.Printf("Creating MKVFS with %d resolved configs", len(configs))
        }</span>

        <span class="cov4" title="30">for _, config := range configs </span><span class="cov4" title="36">{
                if verbose </span><span class="cov1" title="1">{
                        log.Printf("Config: name=%s, dedup=%s, source=%s", config.Name, config.DedupFile, config.SourceDir)
                }</span>

                // Open dedup file to get size (lazy loading - only reads header)
                <span class="cov4" title="36">if verbose </span><span class="cov1" title="1">{
                        log.Printf("Opening dedup file: %s", config.DedupFile)
                }</span>
                <span class="cov4" title="36">reader, err := root.readerFactory.NewReaderLazy(config.DedupFile, config.SourceDir)
                if err != nil </span><span class="cov0" title="0">{
                        if verbose </span><span class="cov0" title="0">{
                                log.Printf("Failed to open dedup file: %v", err)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("open dedup file %s: %w", config.DedupFile, err)</span>
                }

                <span class="cov4" title="36">mkvFile := &amp;MKVFile{
                        Name:          config.Name,
                        DedupPath:     config.DedupFile,
                        SourceDir:     config.SourceDir,
                        Size:          reader.OriginalSize(),
                        readerFactory: root.readerFactory,
                }

                // Don't keep reader open - we'll open it lazily
                reader.Close()

                root.files[config.Name] = mkvFile
                if verbose </span><span class="cov1" title="1">{
                        log.Printf("Added file: %s (size=%d)", config.Name, mkvFile.Size)
                }</span>
        }

        <span class="cov4" title="30">if verbose </span><span class="cov1" title="1">{
                log.Printf("Total files: %d", len(root.files))
        }</span>

        // Build directory tree from collected files
        <span class="cov4" title="30">fileList := make([]*MKVFile, 0, len(root.files))
        for _, f := range root.files </span><span class="cov4" title="36">{
                fileList = append(fileList, f)
        }</span>
        <span class="cov4" title="30">root.rootDir = BuildDirectoryTree(fileList, verbose, readerFactory, permStore)

        // Clean up stale permission entries if we have a permission store
        if permStore != nil </span><span class="cov2" title="7">{
                validFiles, validDirs := root.collectValidPaths()
                removed := permStore.CleanupStale(validFiles, validDirs)
                if removed &gt; 0 </span><span class="cov0" title="0">{
                        if verbose </span><span class="cov0" title="0">{
                                log.Printf("Cleaned up %d stale permission entries", removed)
                        }</span>
                        <span class="cov0" title="0">if err := permStore.Save(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to save permissions after cleanup: %v", err)
                        }</span>
                }
        }

        <span class="cov4" title="30">if verbose </span><span class="cov1" title="1">{
                log.Printf("Directory tree built with %d root entries", len(root.rootDir.files)+len(root.rootDir.subdirs))
        }</span>

        <span class="cov4" title="30">return root, nil</span>
}

// Reload updates the filesystem with new configs. It updates existing MKVFile
// objects in place to preserve pointer identity for cached FUSE inodes, and
// merges the directory tree structure (required because go-fuse caches
// persistent inode objects by inode number).
//
// Semantics:
//   - New files become immediately visible
//   - Removed files disappear from listings
//   - Modified mappings update existing MKVFile objects in place; active readers
//     are closed if the underlying dedup path changed (re-opened lazily on next read)
//   - Permissions are reloaded from disk and stale entries cleaned up
//     (cleanup is skipped if permission reload fails, to avoid overwriting
//     a temporarily unreadable permissions file)
func (r *MKVFSRoot) Reload(configs []dedup.Config, logFn func(string, ...interface{})) error <span class="cov3" title="12">{
        if logFn == nil </span><span class="cov3" title="10">{
                logFn = func(string, ...interface{}) </span>{<span class="cov3" title="10">}</span>
        }

        // Build new file set from configs
        <span class="cov3" title="12">newFiles := make(map[string]*MKVFile)
        for _, config := range configs </span><span class="cov3" title="18">{
                reader, err := r.readerFactory.NewReaderLazy(config.DedupFile, config.SourceDir)
                if err != nil </span><span class="cov1" title="2">{
                        logFn("warning: skipping %s: %v", config.Name, err)
                        continue</span>
                }

                <span class="cov3" title="16">mkvFile := &amp;MKVFile{
                        Name:          config.Name,
                        DedupPath:     config.DedupFile,
                        SourceDir:     config.SourceDir,
                        Size:          reader.OriginalSize(),
                        readerFactory: r.readerFactory,
                }
                reader.Close()
                if existing, ok := newFiles[config.Name]; ok </span><span class="cov0" title="0">{
                        logFn("warning: duplicate name %q (dedup: %s replaced by %s)", config.Name, existing.DedupPath, mkvFile.DedupPath)
                }</span>
                <span class="cov3" title="16">newFiles[config.Name] = mkvFile</span>
        }

        // Build new directory tree
        <span class="cov3" title="12">fileList := make([]*MKVFile, 0, len(newFiles))
        for _, f := range newFiles </span><span class="cov3" title="16">{
                fileList = append(fileList, f)
        }</span>
        <span class="cov3" title="12">newTree := BuildDirectoryTree(fileList, r.verbose, r.readerFactory, r.permStore)

        // Update flat files map in place (preserves pointer identity for cached inodes)
        r.mu.Lock()
        for name := range r.files </span><span class="cov3" title="16">{
                if _, inNew := newFiles[name]; !inNew </span><span class="cov2" title="4">{
                        delete(r.files, name)
                }</span>
        }
        <span class="cov3" title="12">for name, newFile := range newFiles </span><span class="cov3" title="16">{
                if existingFile, ok := r.files[name]; ok </span><span class="cov3" title="12">{
                        existingFile.mu.Lock()
                        existingFile.updateFrom(newFile)
                        existingFile.mu.Unlock()
                }</span> else<span class="cov2" title="4"> {
                        r.files[name] = newFile
                }</span>
        }
        <span class="cov3" title="12">r.mu.Unlock()

        // Merge new tree into existing tree in place
        mergeDirectoryTree(r.rootDir, newTree)

        // Reload permissions and clean up stale entries
        if r.permStore != nil </span><span class="cov0" title="0">{
                if err := r.permStore.Load(); err != nil </span><span class="cov0" title="0">{
                        logFn("warning: failed to reload permissions: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        validFiles, validDirs := r.collectValidPaths()
                        removed := r.permStore.CleanupStale(validFiles, validDirs)
                        if removed &gt; 0 </span><span class="cov0" title="0">{
                                logFn("cleaned up %d stale permission entries", removed)
                                if err := r.permStore.Save(); err != nil </span><span class="cov0" title="0">{
                                        logFn("warning: failed to save permissions after cleanup: %v", err)
                                }</span>
                        }
                }
        }

        <span class="cov3" title="12">logFn("reload complete: %d files", len(newFiles))
        return nil</span>
}

// Getattr implements fs.NodeGetattrer - returns attributes for the root directory.
// This ensures the root directory uses permissions from the permission store,
// consistent with all subdirectories.
func (r *MKVFSRoot) Getattr(ctx context.Context, fh fs.FileHandle, out *fuse.AttrOut) syscall.Errno <span class="cov4" title="61">{
        now := time.Now()

        uid, gid, mode := getDirPerms(r.permStore, "")

        out.Mode = fuse.S_IFDIR | mode
        out.Uid = uid
        out.Gid = gid
        out.Atime = uint64(now.Unix())
        out.Mtime = uint64(now.Unix())
        out.Ctime = uint64(now.Unix())
        out.Nlink = 2
        if r.rootDir != nil </span><span class="cov4" title="61">{
                r.rootDir.mu.RLock()
                out.Nlink += uint32(len(r.rootDir.subdirs))
                r.rootDir.mu.RUnlock()
        }</span>
        <span class="cov4" title="61">return 0</span>
}

// Readdir implements fs.NodeReaddirer - lists files in the root directory.
// Delegates to the directory tree for hierarchical listing.
func (r *MKVFSRoot) Readdir(ctx context.Context) (fs.DirStream, syscall.Errno) <span class="cov2" title="8">{
        // Permission checks are handled by the kernel via default_permissions mount option.
        // This properly checks supplementary groups and matches real filesystem behavior.

        if r.rootDir != nil </span><span class="cov2" title="6">{
                return r.rootDir.readdirInternal(ctx)
        }</span>

        // Fallback to flat listing if no directory tree (shouldn't happen)
        <span class="cov1" title="2">r.mu.RLock()
        defer r.mu.RUnlock()

        if r.verbose </span><span class="cov0" title="0">{
                log.Printf("Readdir: listing %d files (flat)", len(r.files))
        }</span>

        <span class="cov1" title="2">entries := make([]fuse.DirEntry, 0, len(r.files))
        for name := range r.files </span><span class="cov2" title="4">{
                if r.verbose </span><span class="cov0" title="0">{
                        log.Printf("Readdir: adding %s", name)
                }</span>
                <span class="cov2" title="4">entries = append(entries, fuse.DirEntry{
                        Name: name,
                        Mode: fuse.S_IFREG,
                })</span>
        }
        <span class="cov1" title="2">return fs.NewListDirStream(entries), 0</span>
}

// Lookup implements fs.NodeLookuper - looks up a file or directory by name.
// Uses the directory tree for hierarchical lookup.
func (r *MKVFSRoot) Lookup(ctx context.Context, name string, out *fuse.EntryOut) (*fs.Inode, syscall.Errno) <span class="cov4" title="30">{
        // Permission checks are handled by the kernel via default_permissions mount option.

        if r.rootDir != nil </span><span class="cov3" title="28">{
                r.rootDir.mu.RLock()
                defer r.rootDir.mu.RUnlock()

                // Check subdirectories first
                if subdir, ok := r.rootDir.subdirs[name]; ok </span><span class="cov3" title="12">{
                        if r.verbose </span><span class="cov0" title="0">{
                                log.Printf("Lookup: found subdir %s at root", name)
                        }</span>

                        // Lock subdir to safely access its fields
                        <span class="cov3" title="12">subdir.mu.RLock()
                        subdirCount := len(subdir.subdirs)
                        subdir.mu.RUnlock()

                        uid, gid, mode := getDirPerms(r.permStore, subdir.path)

                        now := time.Now()
                        out.Mode = fuse.S_IFDIR | mode
                        out.Uid = uid
                        out.Gid = gid
                        out.Atime = uint64(now.Unix())
                        out.Mtime = uint64(now.Unix())
                        out.Ctime = uint64(now.Unix())
                        out.Nlink = 2 + uint32(subdirCount)

                        stable := fs.StableAttr{
                                Mode: fuse.S_IFDIR,
                                Ino:  hashString(subdir.path),
                        }
                        child := r.NewPersistentInode(ctx, subdir, stable)
                        return child, 0</span>
                }

                // Check files
                <span class="cov3" title="16">if file, ok := r.rootDir.files[name]; ok </span><span class="cov3" title="16">{
                        if r.verbose </span><span class="cov0" title="0">{
                                log.Printf("Lookup: found file %s at root (size=%d)", name, file.Size)
                        }</span>

                        <span class="cov3" title="16">uid, gid, mode := getFilePerms(r.permStore, name)

                        now := time.Now()
                        out.Size = uint64(file.Size)
                        out.Mode = fuse.S_IFREG | mode
                        out.Uid = uid
                        out.Gid = gid
                        out.Atime = uint64(now.Unix())
                        out.Mtime = uint64(now.Unix())
                        out.Ctime = uint64(now.Unix())
                        out.Nlink = 1

                        node := &amp;MKVFSNode{file: file, path: name, verbose: r.verbose, permStore: r.permStore}
                        stable := fs.StableAttr{
                                Mode: fuse.S_IFREG,
                                Ino:  hashString(name),
                        }
                        child := r.NewInode(ctx, node, stable)
                        return child, 0</span>
                }

                <span class="cov0" title="0">if r.verbose </span><span class="cov0" title="0">{
                        log.Printf("Lookup: not found %s at root", name)
                }</span>
                <span class="cov0" title="0">return nil, syscall.ENOENT</span>
        }

        // Fallback to flat lookup if no directory tree (shouldn't happen)
        <span class="cov1" title="2">r.mu.RLock()
        file, ok := r.files[name]
        r.mu.RUnlock()

        if !ok </span><span class="cov1" title="2">{
                if r.verbose </span><span class="cov0" title="0">{
                        log.Printf("Lookup: file not found: %s", name)
                }</span>
                <span class="cov1" title="2">return nil, syscall.ENOENT</span>
        }

        <span class="cov0" title="0">if r.verbose </span><span class="cov0" title="0">{
                log.Printf("Lookup: %s (size=%d)", name, file.Size)
        }</span>

        <span class="cov0" title="0">uid, gid, mode := getFilePerms(r.permStore, name)

        // Create a new file node
        node := &amp;MKVFSNode{file: file, path: name, verbose: r.verbose, permStore: r.permStore}

        // Set attributes
        now := time.Now()
        out.Size = uint64(file.Size)
        out.Mode = fuse.S_IFREG | mode
        out.Uid = uid
        out.Gid = gid
        out.Atime = uint64(now.Unix())
        out.Mtime = uint64(now.Unix())
        out.Ctime = uint64(now.Unix())

        // Create inode with stable ID based on filename
        stable := fs.StableAttr{
                Mode: fuse.S_IFREG,
                Ino:  hashString(name),
        }

        child := r.NewInode(ctx, node, stable)
        return child, 0</span>
}

// Getattr implements fs.NodeGetattrer - returns file attributes.
func (n *MKVFSNode) Getattr(ctx context.Context, fh fs.FileHandle, out *fuse.AttrOut) syscall.Errno <span class="cov9" title="25094">{
        now := time.Now()
        out.Size = uint64(n.file.Size)

        uid, gid, mode := getFilePerms(n.permStore, n.path)

        out.Mode = fuse.S_IFREG | mode
        out.Uid = uid
        out.Gid = gid
        out.Atime = uint64(now.Unix())
        out.Mtime = uint64(now.Unix())
        out.Ctime = uint64(now.Unix())
        out.Nlink = 1
        return 0
}</span>

// Setattr implements fs.NodeSetattrer - handles chmod/chown on files.
func (n *MKVFSNode) Setattr(ctx context.Context, fh fs.FileHandle, in *fuse.SetAttrIn, out *fuse.AttrOut) syscall.Errno <span class="cov3" title="23">{
        if n.permStore == nil </span><span class="cov1" title="2">{
                // No permission store - can't change permissions
                return syscall.EROFS
        }</span>

        // Only UID, GID, and mode changes are supported. All other setattr operations
        // (e.g. size truncation, atime/mtime updates) must fail on this read-only FS.
        <span class="cov3" title="21">supportedMask := uint32(fuse.FATTR_UID | fuse.FATTR_GID | fuse.FATTR_MODE)
        if in.Valid&amp;^supportedMask != 0 </span><span class="cov0" title="0">{
                return syscall.EROFS
        }</span>

        // Get current permissions and caller
        <span class="cov3" title="21">fileUID, fileGID, fileMode := getFilePerms(n.permStore, n.path)
        caller, ok := GetCaller(ctx)
        if !ok </span><span class="cov0" title="0">{
                return syscall.EACCES
        }</span>

        <span class="cov3" title="21">var newUID, newGID, newMode *uint32

        // Check which fields are being changed
        if in.Valid&amp;fuse.FATTR_UID != 0 </span><span class="cov2" title="6">{
                newUID = &amp;in.Uid
        }</span>
        <span class="cov3" title="21">if in.Valid&amp;fuse.FATTR_GID != 0 </span><span class="cov3" title="10">{
                newGID = &amp;in.Gid
        }</span>
        <span class="cov3" title="21">if in.Valid&amp;fuse.FATTR_MODE != 0 </span><span class="cov2" title="7">{
                mode := in.Mode &amp; 0777 // Only permission bits
                newMode = &amp;mode
        }</span>

        // Normalize no-op changes to nil to avoid unnecessary disk writes
        <span class="cov3" title="21">if newUID != nil &amp;&amp; *newUID == fileUID </span><span class="cov0" title="0">{
                newUID = nil
        }</span>
        <span class="cov3" title="21">if newGID != nil &amp;&amp; *newGID == fileGID </span><span class="cov0" title="0">{
                newGID = nil
        }</span>
        <span class="cov3" title="21">if newMode != nil &amp;&amp; *newMode == fileMode </span><span class="cov0" title="0">{
                newMode = nil
        }</span>

        // Permission checks for chown
        <span class="cov3" title="21">if newUID != nil || newGID != nil </span><span class="cov3" title="14">{
                if errno := CheckChown(caller, fileUID, fileGID, newUID, newGID); errno != 0 </span><span class="cov2" title="6">{
                        if n.verbose </span><span class="cov0" title="0">{
                                log.Printf("Setattr: chown permission denied for %s (caller uid=%d)", n.path, caller.Uid)
                        }</span>
                        <span class="cov2" title="6">return errno</span>
                }
        }

        // Permission checks for chmod
        <span class="cov3" title="15">if newMode != nil </span><span class="cov2" title="7">{
                if errno := CheckChmod(caller, fileUID); errno != 0 </span><span class="cov1" title="2">{
                        if n.verbose </span><span class="cov0" title="0">{
                                log.Printf("Setattr: chmod permission denied for %s (caller uid=%d)", n.path, caller.Uid)
                        }</span>
                        <span class="cov1" title="2">return errno</span>
                }
        }

        // Update permission store
        <span class="cov3" title="13">if err := n.permStore.SetFilePerms(n.path, newUID, newGID, newMode); err != nil </span><span class="cov0" title="0">{
                if n.verbose </span><span class="cov0" title="0">{
                        log.Printf("Setattr error: %s: %v", n.path, err)
                }</span>
                <span class="cov0" title="0">return syscall.EIO</span>
        }

        <span class="cov3" title="13">if n.verbose </span><span class="cov0" title="0">{
                log.Printf("Setattr: %s uid=%v gid=%v mode=%v", n.path, newUID, newGID, newMode)
        }</span>

        // Return updated attributes
        <span class="cov3" title="13">return n.Getattr(ctx, fh, out)</span>
}

// Open implements fs.NodeOpener - opens a file for reading.
func (n *MKVFSNode) Open(ctx context.Context, flags uint32) (fs.FileHandle, uint32, syscall.Errno) <span class="cov3" title="10">{
        // This is a read-only filesystem - reject any write access or operations
        // that would modify the filesystem. Note: O_RDONLY|O_APPEND is a valid
        // read-only open on Linux (positions at EOF), so we only check access mode.
        accMode := flags &amp; syscall.O_ACCMODE
        if accMode != syscall.O_RDONLY || flags&amp;(syscall.O_TRUNC|syscall.O_CREAT) != 0 </span><span class="cov0" title="0">{
                return nil, 0, syscall.EROFS
        }</span>

        // Permission checks are handled by the kernel via default_permissions mount option.

        <span class="cov3" title="10">if n.verbose </span><span class="cov0" title="0">{
                log.Printf("Open: %s", n.file.Name)
        }</span>
        // Initialize reader lazily if needed
        <span class="cov3" title="10">if err := n.ensureReader(); err != nil </span><span class="cov1" title="2">{
                if n.verbose </span><span class="cov0" title="0">{
                        log.Printf("Open error: %s: %v", n.file.Name, err)
                }</span>
                <span class="cov1" title="2">return nil, 0, syscall.EIO</span>
        }
        <span class="cov2" title="8">return nil, fuse.FOPEN_KEEP_CACHE | fuse.FOPEN_CACHE_DIR, 0</span>
}

// Read implements fs.NodeReader - reads data from the file.
func (n *MKVFSNode) Read(ctx context.Context, fh fs.FileHandle, dest []byte, off int64) (fuse.ReadResult, syscall.Errno) <span class="cov8" title="6281">{
        // Permission checks are handled by the kernel via default_permissions mount option.

        n.file.mu.RLock()
        defer n.file.mu.RUnlock()

        if n.file.reader == nil </span><span class="cov1" title="2">{
                // Reader not initialized
                if n.verbose </span><span class="cov0" title="0">{
                        log.Printf("Read error: %s: reader not initialized", n.file.Name)
                }</span>
                <span class="cov1" title="2">return nil, syscall.EIO</span>
        }

        // Clamp read to file size
        <span class="cov8" title="6279">if off &gt;= n.file.Size </span><span class="cov1" title="2">{
                return fuse.ReadResultData(nil), 0
        }</span>

        <span class="cov8" title="6277">endOff := off + int64(len(dest))
        if endOff &gt; n.file.Size </span><span class="cov1" title="1">{
                dest = dest[:n.file.Size-off]
        }</span>

        // Read from dedup reader
        <span class="cov8" title="6277">nRead, err := n.file.reader.ReadAt(dest, off)
        if err != nil &amp;&amp; nRead == 0 </span><span class="cov0" title="0">{
                if n.verbose </span><span class="cov0" title="0">{
                        log.Printf("Read error: %s at offset %d: %v", n.file.Name, off, err)
                }</span>
                <span class="cov0" title="0">return nil, syscall.EIO</span>
        }

        <span class="cov8" title="6277">if n.verbose </span><span class="cov0" title="0">{
                log.Printf("Read: %s offset=%d len=%d read=%d", n.file.Name, off, len(dest), nRead)
        }</span>

        <span class="cov8" title="6277">return fuse.ReadResultData(dest[:nRead]), 0</span>
}

// ensureReader ensures the dedup reader is initialized.
func (n *MKVFSNode) ensureReader() error <span class="cov3" title="12">{
        n.file.mu.Lock()
        defer n.file.mu.Unlock()

        if n.file.reader != nil </span><span class="cov1" title="2">{
                return nil
        }</span>

        // Open dedup file with lazy loading using the factory
        <span class="cov3" title="10">reader, err := n.file.readerFactory.NewReaderLazy(n.file.DedupPath, n.file.SourceDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open dedup file: %w", err)
        }</span>

        // Initialize the reader for reading (handles ES vs raw internally)
        <span class="cov3" title="10">if err := reader.InitializeForReading(n.file.SourceDir); err != nil </span><span class="cov1" title="2">{
                reader.Close()
                return fmt.Errorf("initialize reader: %w", err)
        }</span>

        <span class="cov2" title="8">n.file.reader = reader
        return nil</span>
}

// Close cleans up the file's resources.
func (f *MKVFile) Close() <span class="cov2" title="4">{
        f.mu.Lock()
        defer f.mu.Unlock()

        if f.reader != nil </span><span class="cov1" title="2">{
                f.reader.Close()
                f.reader = nil
        }</span>
}

// updateFrom copies data fields from src into f. If the underlying dedup file
// changed, any active reader is closed since it's no longer valid.
// The caller must hold f.mu (write lock).
func (f *MKVFile) updateFrom(src *MKVFile) <span class="cov3" title="28">{
        // Close reader if the underlying file changed — it's no longer valid
        if f.reader != nil &amp;&amp; (f.DedupPath != src.DedupPath || f.SourceDir != src.SourceDir) </span><span class="cov1" title="2">{
                f.reader.Close()
                f.reader = nil
        }</span>
        <span class="cov3" title="28">f.Name = src.Name
        f.DedupPath = src.DedupPath
        f.SourceDir = src.SourceDir
        f.Size = src.Size
        f.readerFactory = src.readerFactory</span>
}

// hashString creates a stable inode number from a string.
func hashString(s string) uint64 <span class="cov4" title="44">{
        var h uint64 = 5381
        for _, c := range s </span><span class="cov6" title="380">{
                h = ((h &lt;&lt; 5) + h) + uint64(c)
        }</span>
        <span class="cov4" title="44">return h</span>
}

// collectValidPaths returns maps of all valid file and directory paths.
func (r *MKVFSRoot) collectValidPaths() (files, dirs map[string]bool) <span class="cov2" title="9">{
        files = make(map[string]bool)
        dirs = make(map[string]bool)

        if r.rootDir == nil </span><span class="cov0" title="0">{
                return files, dirs
        }</span>

        <span class="cov2" title="9">r.collectPathsRecursive(r.rootDir, files, dirs)
        return files, dirs</span>
}

func (r *MKVFSRoot) collectPathsRecursive(node *MKVFSDirNode, files, dirs map[string]bool) <span class="cov3" title="12">{
        node.mu.RLock()
        defer node.mu.RUnlock()

        // Add this directory (including root with empty path)
        dirs[node.path] = true

        // Add files
        for name := range node.files </span><span class="cov2" title="9">{
                var filePath string
                if node.path == "" </span><span class="cov2" title="6">{
                        filePath = name
                }</span> else<span class="cov1" title="3"> {
                        filePath = node.path + "/" + name
                }</span>
                <span class="cov2" title="9">files[filePath] = true</span>
        }

        // Recurse into subdirectories
        <span class="cov3" title="12">for _, subdir := range node.subdirs </span><span class="cov1" title="3">{
                r.collectPathsRecursive(subdir, files, dirs)
        }</span>
}

// --- MKVFSDirNode interface implementations ---

// Readdir implements fs.NodeReaddirer - lists files and subdirectories.
func (d *MKVFSDirNode) Readdir(ctx context.Context) (fs.DirStream, syscall.Errno) <span class="cov2" title="6">{
        // Permission checks are handled by the kernel via default_permissions mount option.
        return d.readdirInternal(ctx)
}</span>

// readdirInternal performs the directory listing. It does not perform any permission
// checks itself (those are handled by the kernel via default_permissions) and is
// shared by both MKVFSRoot.Readdir and MKVFSDirNode.Readdir.
func (d *MKVFSDirNode) readdirInternal(ctx context.Context) (fs.DirStream, syscall.Errno) <span class="cov3" title="12">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        if d.verbose </span><span class="cov1" title="1">{
                log.Printf("Readdir: %s (files=%d, subdirs=%d)", d.path, len(d.files), len(d.subdirs))
        }</span>

        <span class="cov3" title="12">entries := make([]fuse.DirEntry, 0, len(d.files)+len(d.subdirs))

        // Collect and sort subdirectory names for deterministic ordering
        subdirNames := make([]string, 0, len(d.subdirs))
        for name := range d.subdirs </span><span class="cov3" title="13">{
                subdirNames = append(subdirNames, name)
        }</span>
        <span class="cov3" title="12">sort.Strings(subdirNames)

        // Add subdirectories first (sorted)
        for _, name := range subdirNames </span><span class="cov3" title="13">{
                if d.verbose </span><span class="cov0" title="0">{
                        log.Printf("Readdir: adding subdir %s", name)
                }</span>
                <span class="cov3" title="13">entries = append(entries, fuse.DirEntry{
                        Name: name,
                        Mode: fuse.S_IFDIR,
                })</span>
        }

        // Collect and sort file names for deterministic ordering
        <span class="cov3" title="12">fileNames := make([]string, 0, len(d.files))
        for name := range d.files </span><span class="cov3" title="17">{
                fileNames = append(fileNames, name)
        }</span>
        <span class="cov3" title="12">sort.Strings(fileNames)

        // Add files (sorted)
        for _, name := range fileNames </span><span class="cov3" title="17">{
                if d.verbose </span><span class="cov1" title="1">{
                        log.Printf("Readdir: adding file %s", name)
                }</span>
                <span class="cov3" title="17">entries = append(entries, fuse.DirEntry{
                        Name: name,
                        Mode: fuse.S_IFREG,
                })</span>
        }

        <span class="cov3" title="12">return fs.NewListDirStream(entries), 0</span>
}

// Lookup implements fs.NodeLookuper - looks up a file or subdirectory by name.
func (d *MKVFSDirNode) Lookup(ctx context.Context, name string, out *fuse.EntryOut) (*fs.Inode, syscall.Errno) <span class="cov3" title="10">{
        // Permission checks are handled by the kernel via default_permissions mount option.

        d.mu.RLock()
        defer d.mu.RUnlock()

        // Check subdirectories first
        if subdir, ok := d.subdirs[name]; ok </span><span class="cov2" title="4">{
                if d.verbose </span><span class="cov0" title="0">{
                        log.Printf("Lookup: found subdir %s in %s", name, d.path)
                }</span>

                // Lock subdir to safely access its fields
                <span class="cov2" title="4">subdir.mu.RLock()
                subdirCount := len(subdir.subdirs)
                subdir.mu.RUnlock()

                uid, gid, mode := getDirPerms(d.permStore, subdir.path)

                now := time.Now()
                out.Mode = fuse.S_IFDIR | mode
                out.Uid = uid
                out.Gid = gid
                out.Atime = uint64(now.Unix())
                out.Mtime = uint64(now.Unix())
                out.Ctime = uint64(now.Unix())
                out.Nlink = 2 + uint32(subdirCount)

                stable := fs.StableAttr{
                        Mode: fuse.S_IFDIR,
                        Ino:  hashString(subdir.path),
                }
                child := d.NewPersistentInode(ctx, subdir, stable)
                return child, 0</span>
        }

        // Check files
        <span class="cov2" title="6">if file, ok := d.files[name]; ok </span><span class="cov2" title="4">{
                if d.verbose </span><span class="cov0" title="0">{
                        log.Printf("Lookup: found file %s in %s (size=%d)", name, d.path, file.Size)
                }</span>

                <span class="cov2" title="4">var filePath string
                if d.path == "" </span><span class="cov0" title="0">{
                        filePath = name
                }</span> else<span class="cov2" title="4"> {
                        filePath = d.path + "/" + name
                }</span>

                <span class="cov2" title="4">uid, gid, mode := getFilePerms(d.permStore, filePath)

                now := time.Now()
                out.Size = uint64(file.Size)
                out.Mode = fuse.S_IFREG | mode
                out.Uid = uid
                out.Gid = gid
                out.Atime = uint64(now.Unix())
                out.Mtime = uint64(now.Unix())
                out.Ctime = uint64(now.Unix())
                out.Nlink = 1

                node := &amp;MKVFSNode{file: file, path: filePath, verbose: d.verbose, permStore: d.permStore}
                stable := fs.StableAttr{
                        Mode: fuse.S_IFREG,
                        Ino:  hashString(filePath),
                }
                child := d.NewInode(ctx, node, stable)
                return child, 0</span>
        }

        <span class="cov1" title="2">if d.verbose </span><span class="cov0" title="0">{
                log.Printf("Lookup: not found %s in %s", name, d.path)
        }</span>
        <span class="cov1" title="2">return nil, syscall.ENOENT</span>
}

// Getattr implements fs.NodeGetattrer - returns directory attributes.
func (d *MKVFSDirNode) Getattr(ctx context.Context, fh fs.FileHandle, out *fuse.AttrOut) syscall.Errno <span class="cov4" title="31">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        now := time.Now()

        uid, gid, mode := getDirPerms(d.permStore, d.path)

        out.Mode = fuse.S_IFDIR | mode
        out.Uid = uid
        out.Gid = gid
        out.Atime = uint64(now.Unix())
        out.Mtime = uint64(now.Unix())
        out.Ctime = uint64(now.Unix())
        out.Nlink = 2 + uint32(len(d.subdirs))
        return 0
}</span>

// Setattr implements fs.NodeSetattrer - handles chmod/chown on directories.
func (d *MKVFSDirNode) Setattr(ctx context.Context, fh fs.FileHandle, in *fuse.SetAttrIn, out *fuse.AttrOut) syscall.Errno <span class="cov3" title="13">{
        if d.permStore == nil </span><span class="cov1" title="2">{
                // No permission store - can't change permissions
                return syscall.EROFS
        }</span>

        // Only UID, GID, and mode changes are supported. All other setattr operations
        // (e.g. size truncation, atime/mtime updates) must fail on this read-only FS.
        <span class="cov3" title="11">supportedMask := uint32(fuse.FATTR_UID | fuse.FATTR_GID | fuse.FATTR_MODE)
        if in.Valid&amp;^supportedMask != 0 </span><span class="cov0" title="0">{
                return syscall.EROFS
        }</span>

        // Get current permissions and caller
        <span class="cov3" title="11">dirUID, dirGID, dirMode := getDirPerms(d.permStore, d.path)
        caller, ok := GetCaller(ctx)
        if !ok </span><span class="cov0" title="0">{
                return syscall.EACCES
        }</span>

        <span class="cov3" title="11">var newUID, newGID, newMode *uint32

        // Check which fields are being changed
        if in.Valid&amp;fuse.FATTR_UID != 0 </span><span class="cov2" title="6">{
                newUID = &amp;in.Uid
        }</span>
        <span class="cov3" title="11">if in.Valid&amp;fuse.FATTR_GID != 0 </span><span class="cov2" title="4">{
                newGID = &amp;in.Gid
        }</span>
        <span class="cov3" title="11">if in.Valid&amp;fuse.FATTR_MODE != 0 </span><span class="cov2" title="5">{
                mode := in.Mode &amp; 0777 // Only permission bits
                newMode = &amp;mode
        }</span>

        // Normalize no-op changes to nil to avoid unnecessary disk writes
        <span class="cov3" title="11">if newUID != nil &amp;&amp; *newUID == dirUID </span><span class="cov0" title="0">{
                newUID = nil
        }</span>
        <span class="cov3" title="11">if newGID != nil &amp;&amp; *newGID == dirGID </span><span class="cov0" title="0">{
                newGID = nil
        }</span>
        <span class="cov3" title="11">if newMode != nil &amp;&amp; *newMode == dirMode </span><span class="cov0" title="0">{
                newMode = nil
        }</span>

        // Permission checks for chown
        <span class="cov3" title="11">if newUID != nil || newGID != nil </span><span class="cov2" title="6">{
                if errno := CheckChown(caller, dirUID, dirGID, newUID, newGID); errno != 0 </span><span class="cov1" title="2">{
                        if d.verbose </span><span class="cov0" title="0">{
                                log.Printf("Setattr: chown permission denied for %s (caller uid=%d)", d.path, caller.Uid)
                        }</span>
                        <span class="cov1" title="2">return errno</span>
                }
        }

        // Permission checks for chmod
        <span class="cov2" title="9">if newMode != nil </span><span class="cov2" title="5">{
                if errno := CheckChmod(caller, dirUID); errno != 0 </span><span class="cov1" title="2">{
                        if d.verbose </span><span class="cov0" title="0">{
                                log.Printf("Setattr: chmod permission denied for %s (caller uid=%d)", d.path, caller.Uid)
                        }</span>
                        <span class="cov1" title="2">return errno</span>
                }
        }

        // Update permission store
        <span class="cov2" title="7">if err := d.permStore.SetDirPerms(d.path, newUID, newGID, newMode); err != nil </span><span class="cov0" title="0">{
                if d.verbose </span><span class="cov0" title="0">{
                        log.Printf("Setattr error: %s: %v", d.path, err)
                }</span>
                <span class="cov0" title="0">return syscall.EIO</span>
        }

        <span class="cov2" title="7">if d.verbose </span><span class="cov0" title="0">{
                log.Printf("Setattr: %s uid=%v gid=%v mode=%v", d.path, newUID, newGID, newMode)
        }</span>

        // Return updated attributes
        <span class="cov2" title="7">return d.Getattr(ctx, fh, out)</span>
}

// --- Read-only filesystem error handlers ---
// These return EROFS (Read-only file system) for write operations.

// Mkdir implements fs.NodeMkdirer - rejects directory creation.
func (d *MKVFSDirNode) Mkdir(ctx context.Context, name string, mode uint32, out *fuse.EntryOut) (*fs.Inode, syscall.Errno) <span class="cov1" title="2">{
        if d.verbose </span><span class="cov0" title="0">{
                log.Printf("Mkdir: rejected (read-only) %s in %s", name, d.path)
        }</span>
        <span class="cov1" title="2">return nil, syscall.EROFS</span>
}

// Rmdir implements fs.NodeRmdirer - rejects directory removal.
func (d *MKVFSDirNode) Rmdir(ctx context.Context, name string) syscall.Errno <span class="cov1" title="2">{
        if d.verbose </span><span class="cov0" title="0">{
                log.Printf("Rmdir: rejected (read-only) %s in %s", name, d.path)
        }</span>
        <span class="cov1" title="2">return syscall.EROFS</span>
}

// Unlink implements fs.NodeUnlinker - rejects file deletion.
func (d *MKVFSDirNode) Unlink(ctx context.Context, name string) syscall.Errno <span class="cov1" title="2">{
        if d.verbose </span><span class="cov0" title="0">{
                log.Printf("Unlink: rejected (read-only) %s in %s", name, d.path)
        }</span>
        <span class="cov1" title="2">return syscall.EROFS</span>
}

// Create implements fs.NodeCreater - rejects file creation.
func (d *MKVFSDirNode) Create(ctx context.Context, name string, flags uint32, mode uint32, out *fuse.EntryOut) (node *fs.Inode, fh fs.FileHandle, fuseFlags uint32, errno syscall.Errno) <span class="cov1" title="2">{
        if d.verbose </span><span class="cov0" title="0">{
                log.Printf("Create: rejected (read-only) %s in %s", name, d.path)
        }</span>
        <span class="cov1" title="2">return nil, nil, 0, syscall.EROFS</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package fuse provides a FUSE filesystem for accessing deduplicated MKV files.
package fuse

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/user"
        "path/filepath"
        "strconv"
        "sync"
        "syscall"

        "github.com/hanwen/go-fuse/v2/fuse"
        "gopkg.in/yaml.v3"
)

// Perms holds uid, gid, and mode for a file or directory.
// Nil values indicate the field should inherit from defaults.
type Perms struct {
        UID  *uint32 `yaml:"uid,omitempty"`
        GID  *uint32 `yaml:"gid,omitempty"`
        Mode *uint32 `yaml:"mode,omitempty"`
}

// Defaults holds default permissions for files and directories.
type Defaults struct {
        FileUID  uint32 `yaml:"file_uid"`
        FileGID  uint32 `yaml:"file_gid"`
        FileMode uint32 `yaml:"file_mode"`
        DirUID   uint32 `yaml:"dir_uid"`
        DirGID   uint32 `yaml:"dir_gid"`
        DirMode  uint32 `yaml:"dir_mode"`
}

// DefaultPerms returns the default permission values.
func DefaultPerms() Defaults <span class="cov7" title="61">{
        return Defaults{
                FileUID:  0,
                FileGID:  0,
                FileMode: 0444,
                DirUID:   0,
                DirGID:   0,
                DirMode:  0555,
        }
}</span>

// permissionsFile is the structure of the permissions YAML file.
type permissionsFile struct {
        Defaults    Defaults          `yaml:"defaults"`
        Files       map[string]*Perms `yaml:"files,omitempty"`
        Directories map[string]*Perms `yaml:"directories,omitempty"`
}

// PermissionStore manages file/directory permissions with persistence.
type PermissionStore struct {
        path     string
        defaults Defaults
        files    map[string]*Perms
        dirs     map[string]*Perms
        mu       sync.RWMutex
        verbose  bool
}

// NewPermissionStore creates a new permission store.
// If path is empty, permissions will not be persisted.
func NewPermissionStore(path string, defaults Defaults, verbose bool) *PermissionStore <span class="cov7" title="77">{
        return &amp;PermissionStore{
                path:     path,
                defaults: defaults,
                files:    make(map[string]*Perms),
                dirs:     make(map[string]*Perms),
                verbose:  verbose,
        }
}</span>

// Load loads permissions from the file.
// If the file doesn't exist, the store remains empty (using defaults).
func (s *PermissionStore) Load() error <span class="cov4" title="11">{
        if s.path == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="11">data, err := os.ReadFile(s.path)
        if err != nil </span><span class="cov4" title="9">{
                if os.IsNotExist(err) </span><span class="cov4" title="9">{
                        if s.verbose </span><span class="cov0" title="0">{
                                log.Printf("Permissions file %s does not exist, using defaults", s.path)
                        }</span>
                        <span class="cov4" title="9">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("read permissions file: %w", err)</span>
        }

        <span class="cov2" title="2">var pf permissionsFile
        if err := yaml.Unmarshal(data, &amp;pf); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse permissions file: %w", err)
        }</span>

        <span class="cov2" title="2">s.mu.Lock()
        defer s.mu.Unlock()

        // Override defaults if specified in file
        if pf.Defaults.FileMode != 0 || pf.Defaults.FileUID != 0 || pf.Defaults.FileGID != 0 ||
                pf.Defaults.DirMode != 0 || pf.Defaults.DirUID != 0 || pf.Defaults.DirGID != 0 </span><span class="cov2" title="2">{
                // Only override non-zero values from file
                if pf.Defaults.FileMode != 0 </span><span class="cov2" title="2">{
                        s.defaults.FileMode = pf.Defaults.FileMode
                }</span>
                <span class="cov2" title="2">if pf.Defaults.FileUID != 0 </span><span class="cov0" title="0">{
                        s.defaults.FileUID = pf.Defaults.FileUID
                }</span>
                <span class="cov2" title="2">if pf.Defaults.FileGID != 0 </span><span class="cov0" title="0">{
                        s.defaults.FileGID = pf.Defaults.FileGID
                }</span>
                <span class="cov2" title="2">if pf.Defaults.DirMode != 0 </span><span class="cov2" title="2">{
                        s.defaults.DirMode = pf.Defaults.DirMode
                }</span>
                <span class="cov2" title="2">if pf.Defaults.DirUID != 0 </span><span class="cov0" title="0">{
                        s.defaults.DirUID = pf.Defaults.DirUID
                }</span>
                <span class="cov2" title="2">if pf.Defaults.DirGID != 0 </span><span class="cov0" title="0">{
                        s.defaults.DirGID = pf.Defaults.DirGID
                }</span>
        }

        <span class="cov2" title="2">if pf.Files != nil </span><span class="cov2" title="2">{
                s.files = pf.Files
        }</span>
        <span class="cov2" title="2">if pf.Directories != nil </span><span class="cov2" title="2">{
                s.dirs = pf.Directories
        }</span>

        <span class="cov2" title="2">if s.verbose </span><span class="cov0" title="0">{
                log.Printf("Loaded permissions: %d files, %d directories", len(s.files), len(s.dirs))
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// Save saves permissions to the file.
func (s *PermissionStore) Save() error <span class="cov9" title="276">{
        if s.path == "" </span><span class="cov9" title="264">{
                return nil
        }</span>

        <span class="cov4" title="12">s.mu.RLock()
        // Deep copy the maps to avoid data races during marshalling.
        // We copy both the map and the Perms values to ensure complete isolation.
        pf := permissionsFile{
                Defaults: s.defaults,
        }
        if s.files != nil </span><span class="cov4" title="12">{
                pf.Files = make(map[string]*Perms, len(s.files))
                for k, v := range s.files </span><span class="cov4" title="9">{
                        if v != nil </span><span class="cov4" title="9">{
                                permsCopy := *v // copy the Perms struct
                                pf.Files[k] = &amp;permsCopy
                        }</span>
                }
        }
        <span class="cov4" title="12">if s.dirs != nil </span><span class="cov4" title="12">{
                pf.Directories = make(map[string]*Perms, len(s.dirs))
                for k, v := range s.dirs </span><span class="cov3" title="5">{
                        if v != nil </span><span class="cov3" title="5">{
                                permsCopy := *v // copy the Perms struct
                                pf.Directories[k] = &amp;permsCopy
                        }</span>
                }
        }
        <span class="cov4" title="12">s.mu.RUnlock()

        // Create parent directory if needed
        dir := filepath.Dir(s.path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create permissions directory: %w", err)
        }</span>

        <span class="cov4" title="12">data, err := yaml.Marshal(&amp;pf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal permissions: %w", err)
        }</span>

        <span class="cov4" title="12">if err := os.WriteFile(s.path, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write permissions file: %w", err)
        }</span>

        <span class="cov4" title="12">if s.verbose </span><span class="cov0" title="0">{
                log.Printf("Saved permissions to %s", s.path)
        }</span>

        <span class="cov4" title="12">return nil</span>
}

// GetFilePerms returns the effective permissions for a file.
// Returns uid, gid, mode with defaults applied for any unset values.
func (s *PermissionStore) GetFilePerms(path string) (uid, gid, mode uint32) <span class="cov10" title="290">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        uid = s.defaults.FileUID
        gid = s.defaults.FileGID
        mode = s.defaults.FileMode

        if p, ok := s.files[path]; ok </span><span class="cov9" title="259">{
                if p.UID != nil </span><span class="cov9" title="250">{
                        uid = *p.UID
                }</span>
                <span class="cov9" title="259">if p.GID != nil </span><span class="cov5" title="18">{
                        gid = *p.GID
                }</span>
                <span class="cov9" title="259">if p.Mode != nil </span><span class="cov5" title="19">{
                        mode = *p.Mode
                }</span>
        }

        <span class="cov10" title="290">return uid, gid, mode</span>
}

// GetDirPerms returns the effective permissions for a directory.
// Returns uid, gid, mode with defaults applied for any unset values.
func (s *PermissionStore) GetDirPerms(path string) (uid, gid, mode uint32) <span class="cov7" title="72">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        uid = s.defaults.DirUID
        gid = s.defaults.DirGID
        mode = s.defaults.DirMode

        if p, ok := s.dirs[path]; ok </span><span class="cov6" title="29">{
                if p.UID != nil </span><span class="cov5" title="16">{
                        uid = *p.UID
                }</span>
                <span class="cov6" title="29">if p.GID != nil </span><span class="cov4" title="8">{
                        gid = *p.GID
                }</span>
                <span class="cov6" title="29">if p.Mode != nil </span><span class="cov5" title="13">{
                        mode = *p.Mode
                }</span>
        }

        <span class="cov7" title="72">return uid, gid, mode</span>
}

// SetFilePerms sets permissions for a file.
// Only non-nil values are updated; nil values leave existing values unchanged.
// Automatically saves to disk.
func (s *PermissionStore) SetFilePerms(path string, uid, gid *uint32, mode *uint32) error <span class="cov9" title="251">{
        s.mu.Lock()

        // If all values are nil, nothing to do
        if uid == nil &amp;&amp; gid == nil &amp;&amp; mode == nil </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return nil
        }</span>

        <span class="cov9" title="251">p, ok := s.files[path]
        if !ok </span><span class="cov6" title="43">{
                p = &amp;Perms{}
                s.files[path] = p
        }</span>

        // Only update non-nil values; copy values so the store owns their lifetime.
        <span class="cov9" title="251">if uid != nil </span><span class="cov9" title="238">{
                v := *uid
                p.UID = &amp;v
        }</span>
        <span class="cov9" title="251">if gid != nil </span><span class="cov4" title="12">{
                v := *gid
                p.GID = &amp;v
        }</span>
        <span class="cov9" title="251">if mode != nil </span><span class="cov5" title="15">{
                v := *mode
                p.Mode = &amp;v
        }</span>

        <span class="cov9" title="251">s.mu.Unlock()

        if s.verbose </span><span class="cov0" title="0">{
                log.Printf("SetFilePerms: %s uid=%v gid=%v mode=%v", path, uid, gid, mode)
        }</span>

        <span class="cov9" title="251">return s.Save()</span>
}

// RemoveFilePerms removes all permission overrides for a file.
// The file will use default permissions. Automatically saves to disk.
func (s *PermissionStore) RemoveFilePerms(path string) error <span class="cov2" title="2">{
        s.mu.Lock()
        delete(s.files, path)
        s.mu.Unlock()

        if s.verbose </span><span class="cov0" title="0">{
                log.Printf("RemoveFilePerms: %s", path)
        }</span>

        <span class="cov2" title="2">return s.Save()</span>
}

// SetDirPerms sets permissions for a directory.
// Only non-nil values are updated; nil values leave existing values unchanged.
// Automatically saves to disk.
func (s *PermissionStore) SetDirPerms(path string, uid, gid *uint32, mode *uint32) error <span class="cov5" title="23">{
        s.mu.Lock()

        // If all values are nil, nothing to do
        if uid == nil &amp;&amp; gid == nil &amp;&amp; mode == nil </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return nil
        }</span>

        <span class="cov5" title="23">p, ok := s.dirs[path]
        if !ok </span><span class="cov5" title="21">{
                p = &amp;Perms{}
                s.dirs[path] = p
        }</span>

        // Only update non-nil values; copy values so the store owns their lifetime.
        <span class="cov5" title="23">if uid != nil </span><span class="cov5" title="14">{
                v := *uid
                p.UID = &amp;v
        }</span>
        <span class="cov5" title="23">if gid != nil </span><span class="cov3" title="4">{
                v := *gid
                p.GID = &amp;v
        }</span>
        <span class="cov5" title="23">if mode != nil </span><span class="cov4" title="9">{
                v := *mode
                p.Mode = &amp;v
        }</span>

        <span class="cov5" title="23">s.mu.Unlock()

        if s.verbose </span><span class="cov0" title="0">{
                log.Printf("SetDirPerms: %s uid=%v gid=%v mode=%v", path, uid, gid, mode)
        }</span>

        <span class="cov5" title="23">return s.Save()</span>
}

// RemoveDirPerms removes all permission overrides for a directory.
// The directory will use default permissions. Automatically saves to disk.
func (s *PermissionStore) RemoveDirPerms(path string) error <span class="cov0" title="0">{
        s.mu.Lock()
        delete(s.dirs, path)
        s.mu.Unlock()

        if s.verbose </span><span class="cov0" title="0">{
                log.Printf("RemoveDirPerms: %s", path)
        }</span>

        <span class="cov0" title="0">return s.Save()</span>
}

// CleanupStale removes entries for paths that don't exist in the mounted filesystem.
// validFiles and validDirs are maps of valid paths (value is ignored, just checking keys).
// Returns the number of stale entries removed.
func (s *PermissionStore) CleanupStale(validFiles, validDirs map[string]bool) int <span class="cov4" title="11">{
        s.mu.Lock()
        defer s.mu.Unlock()

        removed := 0

        // Clean up stale file entries
        for path := range s.files </span><span class="cov3" title="4">{
                if !validFiles[path] </span><span class="cov2" title="2">{
                        delete(s.files, path)
                        removed++
                        if s.verbose </span><span class="cov0" title="0">{
                                log.Printf("Removed stale file permission entry: %s", path)
                        }</span>
                }
        }

        // Clean up stale directory entries
        <span class="cov4" title="11">for path := range s.dirs </span><span class="cov3" title="4">{
                if !validDirs[path] </span><span class="cov2" title="2">{
                        delete(s.dirs, path)
                        removed++
                        if s.verbose </span><span class="cov0" title="0">{
                                log.Printf("Removed stale directory permission entry: %s", path)
                        }</span>
                }
        }

        <span class="cov4" title="11">return removed</span>
}

// Defaults returns the current default permissions.
func (s *PermissionStore) Defaults() Defaults <span class="cov2" title="2">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.defaults
}</span>

// ResolvePermissionsPath determines which permissions file to use.
// Priority:
//  1. explicitPath (from --permissions-file flag)
//  2. ~/.config/mkvdup/permissions.yaml (if exists) - for both root and non-root
//  3. /etc/mkvdup/permissions.yaml (if exists AND running as root)
//  4. Default based on euid: root uses /etc/, non-root uses ~/.config/
//
// Non-root users always get a user-writable path (unless explicitly overridden)
// to avoid EACCES errors when saving permission changes.
func ResolvePermissionsPath(explicitPath string) string <span class="cov3" title="4">{
        if explicitPath != "" </span><span class="cov2" title="2">{
                return explicitPath
        }</span>

        <span class="cov2" title="2">home, err := os.UserHomeDir()
        userPath := ""
        if err == nil </span><span class="cov2" title="2">{
                userPath = filepath.Join(home, ".config", "mkvdup", "permissions.yaml")
        }</span>

        // Check user config - takes priority for both root and non-root
        <span class="cov2" title="2">if userPath != "" </span><span class="cov2" title="2">{
                if _, err := os.Stat(userPath); err == nil </span><span class="cov0" title="0">{
                        return userPath
                }</span>
        }

        <span class="cov2" title="2">systemPath := "/etc/mkvdup/permissions.yaml"

        // For root: check system config, then default to system path
        if os.Geteuid() == 0 </span><span class="cov0" title="0">{
                if _, err := os.Stat(systemPath); err == nil </span><span class="cov0" title="0">{
                        return systemPath
                }</span>
                <span class="cov0" title="0">return systemPath</span>
        }

        // For non-root: always use user path to ensure writability.
        // Do NOT use system path even if it exists, as non-root users
        // typically cannot write to /etc/ and chmod/chown operations
        // would fail with EACCES.
        <span class="cov2" title="2">if userPath != "" </span><span class="cov2" title="2">{
                return userPath
        }</span>

        // Fallback if no home directory (unusual for non-root)
        <span class="cov0" title="0">return systemPath</span>
}

// CallerInfo represents the calling process's credentials.
type CallerInfo struct {
        Uid uint32
        Gid uint32
}

// testCallerHook is set by test code to allow injecting caller credentials.
// This is nil in production, ensuring only real FUSE contexts are trusted.
var testCallerHook func(context.Context) (CallerInfo, bool)

// GetCaller extracts caller credentials from the FUSE context.
// Returns (caller, true) if credentials are available, (zero, false) otherwise.
// Callers should deny access when ok is false to fail closed.
func GetCaller(ctx context.Context) (CallerInfo, bool) <span class="cov7" title="44">{
        if caller, ok := fuse.FromContext(ctx); ok </span><span class="cov2" title="2">{
                return CallerInfo{Uid: caller.Uid, Gid: caller.Gid}, true
        }</span>
        // Check for test-injected caller (only available in tests)
        <span class="cov6" title="42">if testCallerHook != nil </span><span class="cov6" title="42">{
                if caller, ok := testCallerHook(ctx); ok </span><span class="cov6" title="38">{
                        return caller, true
                }</span>
        }
        // Fail closed: return zero value and false to indicate no credentials
        <span class="cov3" title="4">return CallerInfo{}, false</span>
}

// IsRoot returns true if the caller is root (uid 0).
func (c CallerInfo) IsRoot() bool <span class="cov7" title="80">{
        return c.Uid == 0
}</span>

// CheckChown verifies the caller can change file ownership.
// Returns 0 if allowed, syscall.EPERM if denied.
// Only root can change UID. Only root or file owner can change GID.
// Non-root owners can change GID to any group they are a member of
// (primary or supplementary). No-op changes (newUID == fileUID or
// newGID == fileGID) are always allowed.
func CheckChown(caller CallerInfo, fileUID, fileGID uint32, newUID, newGID *uint32) syscall.Errno <span class="cov7" title="50">{
        // Only root can change UID to a different user
        if newUID != nil &amp;&amp; *newUID != fileUID &amp;&amp; !caller.IsRoot() </span><span class="cov4" title="10">{
                return syscall.EPERM
        }</span>

        // GID changes:
        // - No-op (nil or same as current) is always allowed
        // - Root can change to any GID
        // - Non-root owner can change to any group they belong to
        <span class="cov6" title="40">if newGID != nil &amp;&amp; *newGID != fileGID </span><span class="cov6" title="28">{
                if caller.IsRoot() </span><span class="cov4" title="10">{
                        return 0
                }</span>
                // Non-root: must be owner AND must be a member of target group
                <span class="cov5" title="18">if caller.Uid != fileUID || !isGroupMember(caller.Uid, caller.Gid, *newGID) </span><span class="cov4" title="8">{
                        return syscall.EPERM
                }</span>
        }

        <span class="cov5" title="22">return 0</span>
}

// groupMembershipFunc is the function used to check group membership.
// It can be overridden in tests to avoid OS-level lookups.
var groupMembershipFunc = defaultGroupMembership

// isGroupMember checks if a user is a member of the given group.
// This checks the primary GID and supplementary groups.
func isGroupMember(uid, primaryGID, targetGID uint32) bool <span class="cov5" title="14">{
        return groupMembershipFunc(uid, primaryGID, targetGID)
}</span>

// defaultGroupMembership checks group membership by looking up the user's
// groups from the OS.
func defaultGroupMembership(uid, primaryGID, targetGID uint32) bool <span class="cov0" title="0">{
        // Primary GID is always a member
        if targetGID == primaryGID </span><span class="cov0" title="0">{
                return true
        }</span>

        // Look up supplementary groups from the OS
        <span class="cov0" title="0">u, err := user.LookupId(strconv.FormatUint(uint64(uid), 10))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">groupIDs, err := u.GroupIds()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">targetStr := strconv.FormatUint(uint64(targetGID), 10)
        for _, gid := range groupIDs </span><span class="cov0" title="0">{
                if gid == targetStr </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// CheckChmod verifies the caller can change file mode.
// Returns 0 if allowed, syscall.EPERM if denied.
// Only root or file owner can chmod.
func CheckChmod(caller CallerInfo, fileUID uint32) syscall.Errno <span class="cov5" title="22">{
        if caller.IsRoot() || caller.Uid == fileUID </span><span class="cov5" title="14">{
                return 0
        }</span>
        <span class="cov4" title="8">return syscall.EPERM</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package fuse

import (
        "log"
        "path"
        "strings"
)

// BuildDirectoryTree creates a directory tree from files with path-containing names.
// Directories are auto-created for each path component.
// Files with names like "Movies/Action/film.mkv" will create the directory hierarchy.
//
// Path handling:
//   - Leading slashes are stripped (absolute paths become relative)
//   - Paths are cleaned (e.g., "foo//bar" becomes "foo/bar")
//   - Only forward slashes (/) are treated as path separators
//   - Paths containing ".." components are rejected
//   - Empty filenames are rejected
//
// Conflicts:
//   - Duplicate paths: later file wins, warning logged
//   - File/directory collision: directory wins, file skipped with warning
func BuildDirectoryTree(files []*MKVFile, verbose bool, readerFactory ReaderFactory, permStore *PermissionStore) *MKVFSDirNode <span class="cov4" title="82">{
        root := &amp;MKVFSDirNode{
                name:          "",
                path:          "",
                files:         make(map[string]*MKVFile),
                subdirs:       make(map[string]*MKVFSDirNode),
                verbose:       verbose,
                readerFactory: readerFactory,
                permStore:     permStore,
        }

        for _, file := range files </span><span class="cov9" title="20120">{
                insertFile(root, file, verbose, readerFactory, permStore)
        }</span>

        <span class="cov4" title="82">return root</span>
}

// insertFile inserts a file into the directory tree, creating directories as needed.
func insertFile(root *MKVFSDirNode, file *MKVFile, verbose bool, readerFactory ReaderFactory, permStore *PermissionStore) <span class="cov9" title="20120">{
        // Validate: reject paths with ".." components (security)
        if strings.Contains(file.Name, "..") </span><span class="cov1" title="2">{
                log.Printf("Warning: skipping file with invalid path (contains '..'): %s", file.Name)
                return
        }</span>

        // Clean and split the path
        <span class="cov9" title="20118">cleanPath := path.Clean(file.Name)
        parts := strings.Split(cleanPath, "/")

        // Filter out empty parts (handles leading slashes and multiple slashes)
        validParts := make([]string, 0, len(parts))
        for _, p := range parts </span><span class="cov10" title="60186">{
                if p != "" &amp;&amp; p != "." </span><span class="cov9" title="60182">{
                        validParts = append(validParts, p)
                }</span>
        }

        // Validate: reject empty filenames
        <span class="cov9" title="20118">if len(validParts) == 0 </span><span class="cov1" title="2">{
                log.Printf("Warning: skipping file with empty name: %q", file.Name)
                return
        }</span>

        <span class="cov9" title="20116">fileName := validParts[len(validParts)-1]
        if fileName == "" </span><span class="cov0" title="0">{
                log.Printf("Warning: skipping file with empty filename: %q", file.Name)
                return
        }</span>

        // Navigate/create directories for each path component except the last (filename)
        <span class="cov9" title="20116">current := root
        for i := 0; i &lt; len(validParts)-1; i++ </span><span class="cov9" title="40064">{
                dirName := validParts[i]

                current.mu.Lock()
                // Check for file/directory collision: if a file exists with this name, skip
                if _, fileExists := current.files[dirName]; fileExists </span><span class="cov1" title="2">{
                        log.Printf("Warning: path component %q conflicts with existing file, skipping: %s", dirName, file.Name)
                        current.mu.Unlock()
                        return
                }</span>

                <span class="cov9" title="40062">subdir, exists := current.subdirs[dirName]
                if !exists </span><span class="cov7" title="2073">{
                        // Create new directory node
                        var newPath string
                        if current.path == "" </span><span class="cov4" title="46">{
                                newPath = dirName
                        }</span> else<span class="cov7" title="2027"> {
                                newPath = current.path + "/" + dirName
                        }</span>
                        <span class="cov7" title="2073">subdir = &amp;MKVFSDirNode{
                                name:          dirName,
                                path:          newPath,
                                files:         make(map[string]*MKVFile),
                                subdirs:       make(map[string]*MKVFSDirNode),
                                verbose:       verbose,
                                readerFactory: readerFactory,
                                permStore:     permStore,
                        }
                        current.subdirs[dirName] = subdir</span>
                }
                <span class="cov9" title="40062">current.mu.Unlock()
                current = subdir</span>
        }

        // Insert the file into the final directory
        <span class="cov9" title="20114">current.mu.Lock()
        defer current.mu.Unlock()

        // Check for file/directory collision: if a directory exists with this name, skip the file
        if _, dirExists := current.subdirs[fileName]; dirExists </span><span class="cov1" title="2">{
                log.Printf("Warning: file %q conflicts with existing directory, skipping", file.Name)
                return
        }</span>

        // Check for duplicate: warn if overwriting
        <span class="cov9" title="20112">if existing, exists := current.files[fileName]; exists </span><span class="cov1" title="2">{
                log.Printf("Warning: duplicate path %q, replacing %s with %s", file.Name, existing.DedupPath, file.DedupPath)
        }</span>

        <span class="cov9" title="20112">current.files[fileName] = file</span>
}

// mergeDirectoryTree merges newTree's contents into existing's maps in place.
// This is necessary because go-fuse caches persistent inode objects by inode
// number — swapping the root directory won't affect already-cached inodes.
// Instead, we update existing MKVFSDirNode objects' files and subdirs maps
// so cached inodes see the new data.
func mergeDirectoryTree(existing, newTree *MKVFSDirNode) <span class="cov3" title="24">{
        existing.mu.Lock()
        defer existing.mu.Unlock()

        // Remove files that are no longer present
        for name := range existing.files </span><span class="cov3" title="22">{
                if _, inNew := newTree.files[name]; !inNew </span><span class="cov2" title="6">{
                        delete(existing.files, name)
                }</span>
        }

        // Add or update files (update in place to preserve pointer identity for cached inodes)
        <span class="cov3" title="24">for name, newFile := range newTree.files </span><span class="cov3" title="22">{
                if existingFile, ok := existing.files[name]; ok </span><span class="cov3" title="16">{
                        existingFile.mu.Lock()
                        existingFile.updateFrom(newFile)
                        existingFile.mu.Unlock()
                }</span> else<span class="cov2" title="6"> {
                        existing.files[name] = newFile
                }</span>
        }

        // Remove subdirectories that are no longer present
        <span class="cov3" title="24">for name := range existing.subdirs </span><span class="cov2" title="6">{
                if _, inNew := newTree.subdirs[name]; !inNew </span><span class="cov2" title="4">{
                        delete(existing.subdirs, name)
                }</span>
        }

        // Add or recursively merge subdirectories
        <span class="cov3" title="24">for name, newSubdir := range newTree.subdirs </span><span class="cov2" title="6">{
                existingSubdir, exists := existing.subdirs[name]
                if !exists </span><span class="cov2" title="4">{
                        existing.subdirs[name] = newSubdir
                }</span> else<span class="cov1" title="2"> {
                        mergeDirectoryTree(existingSubdir, newSubdir)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package matcher provides the core deduplication logic for matching MKV packets to source files.
package matcher

import (
        "fmt"
        "os"
        "runtime"
        "sort"
        "sync"
        "sync/atomic"

        "github.com/cespare/xxhash/v2"
        "github.com/stuckj/mkvdup/internal/mkv"
        "github.com/stuckj/mkvdup/internal/mmap"
        "github.com/stuckj/mkvdup/internal/source"
)

const (
        // MaxExpansionBytes is the maximum number of bytes to expand a match in each direction.
        // Set high to allow matching entire video keyframes which can be several MB.
        MaxExpansionBytes = 16 * 1024 * 1024 // 16MB
)

// Entry represents a region in the MKV file and where its data comes from.
type Entry struct {
        MkvOffset        int64  // Start offset in the MKV file
        Length           int64  // Length of this region
        Source           uint16 // 0 = delta, 1+ = source file index + 1 (supports up to 65535 files)
        SourceOffset     int64  // Offset in source file (or ES offset for ES-based sources)
        IsVideo          bool   // For ES-based sources: whether this is video or audio data
        AudioSubStreamID byte   // For ES-based audio: sub-stream ID (0x80-0x87=AC3, etc.)
}

// Result contains the results of the matching process.
type Result struct {
        Entries        []Entry // All entries covering the entire MKV file
        DeltaData      []byte  // Concatenated unique data (delta)
        MatchedBytes   int64   // Total bytes matched to source
        UnmatchedBytes int64   // Total bytes in delta
        MatchedPackets int     // Number of packets that matched
        TotalPackets   int     // Total number of packets processed
}

// matchedRegion tracks a region that was matched to a source.
type matchedRegion struct {
        mkvStart         int64
        mkvEnd           int64
        fileIndex        uint16
        srcOffset        int64 // File offset or ES offset depending on source type
        isVideo          bool  // For ES-based sources
        audioSubStreamID byte  // For audio in MPEG-PS
}

// Matcher performs the deduplication matching.
// coverageChunkSize is the granularity for coverage tracking.
// Smaller values give more accurate coverage checks but use more memory.
const coverageChunkSize = 4096 // 4KB chunks

type Matcher struct {
        sourceIndex    *source.Index
        mkvMmap        *mmap.File
        mkvData        []byte // Zero-copy mmap'd MKV data
        mkvSize        int64
        windowSize     int
        matchedRegions []matchedRegion
        regionsMu      sync.Mutex  // Protects matchedRegions for concurrent access
        trackTypes     map[int]int // Map from track number to track type
        numWorkers     int         // Number of worker goroutines for parallel matching
        // Coverage bitmap for O(1) coverage checks. Each bit represents a chunk.
        // A chunk is marked covered when a matched region fully contains it.
        coveredChunks []uint64 // Bitmap: bit i = chunk i is covered
        coverageMu    sync.Mutex
}

// NewMatcher creates a new Matcher with the given source index.
func NewMatcher(sourceIndex *source.Index) (*Matcher, error) <span class="cov2" title="20">{
        numWorkers := runtime.NumCPU() / 2
        if numWorkers &lt; 1 </span><span class="cov0" title="0">{
                numWorkers = 1
        }</span>
        <span class="cov2" title="20">return &amp;Matcher{
                sourceIndex: sourceIndex,
                windowSize:  sourceIndex.WindowSize,
                trackTypes:  make(map[int]int),
                numWorkers:  numWorkers,
        }, nil</span>
}

// SetNumWorkers sets the number of worker goroutines for parallel matching.
func (m *Matcher) SetNumWorkers(n int) <span class="cov1" title="6">{
        if n &lt; 1 </span><span class="cov1" title="4">{
                n = 1
        }</span>
        <span class="cov1" title="6">m.numWorkers = n</span>
}

// Close releases resources.
func (m *Matcher) Close() error <span class="cov2" title="14">{
        if m.mkvMmap != nil </span><span class="cov1" title="6">{
                m.mkvMmap.Close()
        }</span>
        <span class="cov2" title="14">return nil</span>
}

// ProgressFunc is called to report matching progress.
type ProgressFunc func(processedPackets, totalPackets int)

// Match processes an MKV file and matches packets to the source.
func (m *Matcher) Match(mkvPath string, packets []mkv.Packet, tracks []mkv.Track, progress ProgressFunc) (*Result, error) <span class="cov1" title="6">{
        // Memory-map the MKV file for zero-copy access
        info, err := os.Stat(mkvPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("stat MKV: %w", err)
        }</span>
        <span class="cov1" title="6">m.mkvSize = info.Size()

        m.mkvMmap, err = mmap.Open(mkvPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mmap MKV: %w", err)
        }</span>
        <span class="cov1" title="6">m.mkvData = m.mkvMmap.Data() // Store reference for zero-copy access

        // Build track type map
        for _, t := range tracks </span><span class="cov2" title="12">{
                m.trackTypes[int(t.Number)] = t.Type
        }</span>

        // Reset matched regions with pre-allocated capacity
        // Most packets will match, so estimate capacity as number of packets
        <span class="cov1" title="6">m.matchedRegions = make([]matchedRegion, 0, len(packets))

        // Initialize coverage bitmap
        // Each uint64 holds 64 chunk bits, so we need (numChunks + 63) / 64 uint64s
        numChunks := (m.mkvSize + coverageChunkSize - 1) / coverageChunkSize
        m.coveredChunks = make([]uint64, (numChunks+63)/64)

        result := &amp;Result{
                TotalPackets: len(packets),
        }

        // Use parallel processing with worker pool
        result.MatchedPackets = m.matchParallel(packets, progress)

        if progress != nil </span><span class="cov0" title="0">{
                progress(len(packets), len(packets))
        }</span>

        // Merge overlapping regions and build final entries
        <span class="cov1" title="6">m.mergeRegions()
        result.Entries, result.DeltaData = m.buildEntries()

        // Calculate statistics
        for _, e := range result.Entries </span><span class="cov6" title="854918">{
                if e.Source == 0 </span><span class="cov6" title="427462">{
                        result.UnmatchedBytes += e.Length
                }</span> else<span class="cov6" title="427456"> {
                        result.MatchedBytes += e.Length
                }</span>
        }

        <span class="cov1" title="6">return result, nil</span>
}

// ProbeHash represents a hash computed from a sync point in packet data.
type ProbeHash struct {
        Hash    uint64
        IsVideo bool
}

// ExtractProbeHashes extracts probe hashes from packet data using sync point detection.
// This is the same algorithm used by the matcher to find matching points.
// The data should be the first few KB of a packet (typically up to 4096 bytes).
// windowSize should match the source index window size (typically 64 bytes).
// Returns nil if no valid hashes could be extracted.
func ExtractProbeHashes(data []byte, isVideo bool, windowSize int) []ProbeHash <span class="cov2" title="26">{
        if len(data) &lt; windowSize </span><span class="cov1" title="4">{
                return nil
        }</span>

        <span class="cov2" title="22">var hashes []ProbeHash

        // Find sync points within the packet data
        var syncPoints []int
        if isVideo </span><span class="cov2" title="14">{
                syncPoints = source.FindVideoStartCodes(data)
        }</span> else<span class="cov1" title="8"> {
                syncPoints = source.FindAudioSyncPoints(data)
        }</span>

        // Hash from sync points
        <span class="cov2" title="22">for _, syncOff := range syncPoints </span><span class="cov2" title="16">{
                if syncOff+windowSize &gt; len(data) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov2" title="16">hash := xxhash.Sum64(data[syncOff : syncOff+windowSize])
                hashes = append(hashes, ProbeHash{
                        Hash:    hash,
                        IsVideo: isVideo,
                })</span>
        }

        // If no sync points found, try from data start
        <span class="cov2" title="22">if len(hashes) == 0 </span><span class="cov1" title="8">{
                hash := xxhash.Sum64(data[:windowSize])
                hashes = append(hashes, ProbeHash{
                        Hash:    hash,
                        IsVideo: isVideo,
                })
        }</span>

        <span class="cov2" title="22">return hashes</span>
}

// matchParallel processes packets in parallel using a worker pool.
func (m *Matcher) matchParallel(packets []mkv.Packet, progress ProgressFunc) int <span class="cov1" title="6">{
        var processedCount atomic.Int64
        var matchedCount atomic.Int64
        totalPackets := len(packets)

        // Create work channel
        workChan := make(chan mkv.Packet, m.numWorkers*2)

        // Start workers
        var wg sync.WaitGroup
        for i := 0; i &lt; m.numWorkers; i++ </span><span class="cov2" title="12">{
                wg.Add(1)
                go func() </span><span class="cov2" title="12">{
                        defer wg.Done()
                        for pkt := range workChan </span><span class="cov6" title="440916">{
                                matched := m.matchPacketParallel(pkt)
                                if matched </span><span class="cov6" title="427456">{
                                        matchedCount.Add(1)
                                }</span>
                                <span class="cov6" title="440916">count := processedCount.Add(1)
                                if progress != nil &amp;&amp; count%1000 == 0 </span><span class="cov0" title="0">{
                                        progress(int(count), totalPackets)
                                }</span>
                        }
                }()
        }

        // Send work to workers
        <span class="cov1" title="6">for _, pkt := range packets </span><span class="cov6" title="440916">{
                workChan &lt;- pkt
        }</span>
        <span class="cov1" title="6">close(workChan)

        // Wait for all workers to finish
        wg.Wait()

        return int(matchedCount.Load())</span>
}

// matchPacketParallel is the thread-safe version of matchPacket.
func (m *Matcher) matchPacketParallel(pkt mkv.Packet) bool <span class="cov6" title="440916">{
        // Check if this region is already covered by a matched region
        // Note: This is a relaxed check - we may miss some coverage due to race conditions,
        // but that's okay since we merge overlapping regions at the end anyway
        if m.isRangeCoveredParallel(pkt.Offset, pkt.Size) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Determine if this is video or audio
        <span class="cov6" title="440916">trackType := m.trackTypes[int(pkt.TrackNum)]
        isVideo := trackType == mkv.TrackTypeVideo

        // Read packet data to find sync points (zero-copy slice access)
        readSize := pkt.Size
        if readSize &gt; 4096 </span><span class="cov5" title="167478">{
                readSize = 4096 // Only need to check beginning for sync points
        }</span>
        <span class="cov6" title="440916">if readSize &lt; int64(m.windowSize) </span><span class="cov1" title="6">{
                return false
        }</span>

        // Zero-copy: slice directly into mmap'd data
        <span class="cov6" title="440910">endOffset := pkt.Offset + readSize
        if endOffset &gt; m.mkvSize </span><span class="cov0" title="0">{
                endOffset = m.mkvSize
        }</span>
        <span class="cov6" title="440910">data := m.mkvData[pkt.Offset:endOffset]
        if len(data) &lt; m.windowSize </span><span class="cov0" title="0">{
                return false
        }</span>

        // Find sync points within the packet data
        <span class="cov6" title="440910">var syncPoints []int
        if isVideo </span><span class="cov5" title="195960">{
                syncPoints = source.FindVideoStartCodes(data)
        }</span> else<span class="cov6" title="244950"> {
                syncPoints = source.FindAudioSyncPoints(data)
        }</span>

        // Try sync points first
        <span class="cov6" title="440910">for _, syncOff := range syncPoints </span><span class="cov6" title="443440">{
                if syncOff+m.windowSize &gt; len(data) </span><span class="cov3" title="230">{
                        continue</span>
                }
                <span class="cov6" title="443210">if m.tryMatchFromOffsetParallel(pkt, int64(syncOff), data[syncOff:], isVideo) </span><span class="cov6" title="427456">{
                        return true
                }</span>
        }

        // Also try from packet start (in case it's already aligned)
        <span class="cov4" title="13454">if m.tryMatchFromOffsetParallel(pkt, 0, data, isVideo) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov4" title="13454">return false</span>
}

// isRangeCoveredParallel checks if a range is likely covered using a coverage bitmap.
// This is an O(1) check using chunk-level granularity. It may have false positives
// (multiple regions covering different chunks) but that's acceptable since we merge
// overlapping regions at the end anyway.
func (m *Matcher) isRangeCoveredParallel(offset, size int64) bool <span class="cov6" title="440952">{
        // Calculate chunk range
        startChunk := offset / coverageChunkSize
        endChunk := (offset + size - 1) / coverageChunkSize

        m.coverageMu.Lock()
        defer m.coverageMu.Unlock()

        // Check if all chunks in the range are covered
        for chunk := startChunk; chunk &lt;= endChunk; chunk++ </span><span class="cov6" title="440954">{
                wordIdx := chunk / 64
                bitIdx := uint(chunk % 64)
                if wordIdx &gt;= int64(len(m.coveredChunks)) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov6" title="440954">if m.coveredChunks[wordIdx]&amp;(1&lt;&lt;bitIdx) == 0 </span><span class="cov6" title="440926">{
                        return false
                }</span>
        }
        <span class="cov2" title="26">return true</span>
}

// markChunksCovered marks the chunks fully contained within a region as covered.
func (m *Matcher) markChunksCovered(start, end int64) <span class="cov6" title="427462">{
        // Only mark chunks that are fully contained within the region
        // First chunk that starts at or after 'start' and is fully contained
        firstFullChunk := (start + coverageChunkSize - 1) / coverageChunkSize
        // Last chunk that ends before 'end'
        lastFullChunk := (end / coverageChunkSize) - 1

        if firstFullChunk &gt; lastFullChunk </span><span class="cov6" title="298723">{
                // Region doesn't fully contain any chunks
                return
        }</span>

        <span class="cov5" title="128739">m.coverageMu.Lock()
        defer m.coverageMu.Unlock()

        for chunk := firstFullChunk; chunk &lt;= lastFullChunk; chunk++ </span><span class="cov6" title="812489">{
                wordIdx := chunk / 64
                bitIdx := uint(chunk % 64)
                if wordIdx &lt; int64(len(m.coveredChunks)) </span><span class="cov6" title="812489">{
                        m.coveredChunks[wordIdx] |= 1 &lt;&lt; bitIdx
                }</span>
        }
}

// tryMatchFromOffsetParallel is a thread-safe version of tryMatchFromOffset.
func (m *Matcher) tryMatchFromOffsetParallel(pkt mkv.Packet, offsetInPacket int64, data []byte, isVideo bool) bool <span class="cov6" title="456664">{
        if len(data) &lt; m.windowSize </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov6" title="456664">window := data[:m.windowSize]
        hash := xxhash.Sum64(window)

        // Look up in source index (read-only, thread-safe)
        locations := m.sourceIndex.Lookup(hash)
        if len(locations) == 0 </span><span class="cov5" title="29208">{
                return false
        }</span>

        // Try all locations and find the best match (longest expansion)
        <span class="cov6" title="427456">var bestMatch *matchedRegion
        bestMatchLen := int64(0)

        for _, loc := range locations </span><span class="cov8" title="62295957">{
                // Skip locations that don't match the stream type (video vs audio)
                // This is important for ES-based indexes where video and audio
                // have separate offset spaces
                if m.sourceIndex.UsesESOffsets &amp;&amp; loc.IsVideo != isVideo </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="62295957">region := m.tryVerifyAndExpand(pkt, loc, offsetInPacket, isVideo)
                if region != nil </span><span class="cov8" title="62295957">{
                        matchLen := region.mkvEnd - region.mkvStart
                        if matchLen &gt; bestMatchLen </span><span class="cov6" title="510220">{
                                bestMatch = region
                                bestMatchLen = matchLen
                        }</span>
                }
        }

        <span class="cov6" title="427456">if bestMatch != nil </span><span class="cov6" title="427456">{
                m.regionsMu.Lock()
                m.matchedRegions = append(m.matchedRegions, *bestMatch)
                m.regionsMu.Unlock()
                // Mark chunks as covered for fast coverage checks
                m.markChunksCovered(bestMatch.mkvStart, bestMatch.mkvEnd)
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// tryVerifyAndExpand attempts to verify and expand a match, returning the matched region or nil.
func (m *Matcher) tryVerifyAndExpand(pkt mkv.Packet, loc source.Location, offsetInPacket int64, isVideo bool) *matchedRegion <span class="cov8" title="62295957">{
        // The MKV offset where this sync point is
        mkvSyncOffset := pkt.Offset + offsetInPacket

        // Verify the initial match (at least windowSize bytes)
        verifyLen := int64(m.windowSize)
        remainingInPacket := pkt.Size - offsetInPacket
        if verifyLen &gt; remainingInPacket </span><span class="cov0" title="0">{
                verifyLen = remainingInPacket
        }</span>

        // Zero-copy: slice directly into mmap'd data
        <span class="cov8" title="62295957">endOffset := mkvSyncOffset + verifyLen
        if endOffset &gt; m.mkvSize </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="62295957">mkvBuf := m.mkvData[mkvSyncOffset:endOffset]

        // Read source data - use ES reader for ES-based indexes, raw slice for zero-copy
        var srcBuf []byte
        var err error
        if m.sourceIndex.UsesESOffsets </span><span class="cov8" title="54311265">{
                srcBuf, err = m.sourceIndex.ReadESDataAt(loc, int(verifyLen))
                if err != nil || len(srcBuf) &lt; int(verifyLen) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        } else<span class="cov7" title="7984692"> {
                // For raw indexes, use zero-copy slice
                srcBuf = m.sourceIndex.RawSlice(loc, int(verifyLen))
                if srcBuf == nil || len(srcBuf) &lt; int(verifyLen) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // Check if bytes match
        <span class="cov8" title="62295957">for i := range mkvBuf </span><span class="cov10" title="3986941248">{
                if mkvBuf[i] != srcBuf[i] </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // Expand the match from the sync point
        <span class="cov8" title="62295957">mkvStart, srcStart, matchLen := m.expandMatch(
                mkvSyncOffset, loc, verifyLen,
        )

        return &amp;matchedRegion{
                mkvStart:         mkvStart,
                mkvEnd:           mkvStart + matchLen,
                fileIndex:        loc.FileIndex,
                srcOffset:        srcStart,
                isVideo:          isVideo,
                audioSubStreamID: loc.AudioSubStreamID,
        }</span>
}

// expandMatch expands a verified match in both directions.
func (m *Matcher) expandMatch(mkvOffset int64, loc source.Location, initialLen int64) (mkvStart, srcStart, length int64) <span class="cov8" title="62295957">{
        mkvStart = mkvOffset
        srcStart = loc.Offset
        length = initialLen

        // Get source size for bounds checking
        var srcSize int64
        if m.sourceIndex.UsesESOffsets &amp;&amp; int(loc.FileIndex) &lt; len(m.sourceIndex.ESReaders) </span><span class="cov8" title="54311265">{
                if loc.IsVideo </span><span class="cov8" title="53233450">{
                        srcSize = m.sourceIndex.ESReaders[loc.FileIndex].TotalESSize(true)
                }</span> else<span class="cov6" title="1077815"> {
                        srcSize = m.sourceIndex.ESReaders[loc.FileIndex].AudioSubStreamESSize(loc.AudioSubStreamID)
                }</span>
        } else<span class="cov7" title="7984692"> {
                // For raw files, use file size
                if int(loc.FileIndex) &lt; len(m.sourceIndex.Files) </span><span class="cov7" title="7984692">{
                        srcSize = m.sourceIndex.Files[loc.FileIndex].Size
                }</span>
        }

        // Expand backward (zero-copy single-byte reads from mmap'd data)
        // Track range hint across reads to avoid repeated binary searches
        <span class="cov8" title="62295957">backwardHint := -1
        backwardExpanded := int64(0)
        for mkvStart &gt; 0 &amp;&amp; srcStart &gt; 0 &amp;&amp; backwardExpanded &lt; MaxExpansionBytes </span><span class="cov8" title="67742916">{
                // Zero-copy: direct byte access
                mkvByte := m.mkvData[mkvStart-1]

                var srcByteVal byte
                var ok bool
                if m.sourceIndex.UsesESOffsets </span><span class="cov8" title="59714165">{
                        readLoc := source.Location{
                                FileIndex:        loc.FileIndex,
                                Offset:           srcStart - 1,
                                IsVideo:          loc.IsVideo,
                                AudioSubStreamID: loc.AudioSubStreamID,
                        }
                        srcByteVal, backwardHint, ok = m.sourceIndex.ReadESByteWithHint(readLoc, backwardHint)
                        if !ok </span><span class="cov0" title="0">{
                                break</span>
                        }
                } else<span class="cov7" title="8028751"> {
                        // Zero-copy for raw indexes
                        srcByte := m.sourceIndex.RawSlice(source.Location{FileIndex: loc.FileIndex, Offset: srcStart - 1}, 1)
                        if len(srcByte) == 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov7" title="8028751">srcByteVal = srcByte[0]</span>
                }

                <span class="cov8" title="67742916">if mkvByte != srcByteVal </span><span class="cov8" title="62295957">{
                        break</span>
                }

                <span class="cov7" title="5446959">mkvStart--
                srcStart--
                length++
                backwardExpanded++</span>
        }

        // Expand forward (zero-copy single-byte reads from mmap'd data)
        // Track range hint across reads to avoid repeated binary searches
        <span class="cov8" title="62295957">forwardHint := -1
        mkvEnd := mkvOffset + initialLen
        srcEnd := loc.Offset + initialLen
        forwardExpanded := int64(0)
        for mkvEnd &lt; m.mkvSize &amp;&amp; srcEnd &lt; srcSize &amp;&amp; forwardExpanded &lt; MaxExpansionBytes </span><span class="cov9" title="2462146029">{
                // Zero-copy: direct byte access
                mkvByte := m.mkvData[mkvEnd]

                var srcByteVal byte
                var ok bool
                if m.sourceIndex.UsesESOffsets </span><span class="cov9" title="2137714314">{
                        readLoc := source.Location{
                                FileIndex:        loc.FileIndex,
                                Offset:           srcEnd,
                                IsVideo:          loc.IsVideo,
                                AudioSubStreamID: loc.AudioSubStreamID,
                        }
                        srcByteVal, forwardHint, ok = m.sourceIndex.ReadESByteWithHint(readLoc, forwardHint)
                        if !ok </span><span class="cov0" title="0">{
                                break</span>
                        }
                } else<span class="cov8" title="324431715"> {
                        // Zero-copy for raw indexes
                        srcByte := m.sourceIndex.RawSlice(source.Location{FileIndex: loc.FileIndex, Offset: srcEnd}, 1)
                        if len(srcByte) == 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="324431715">srcByteVal = srcByte[0]</span>
                }

                <span class="cov9" title="2462146029">if mkvByte != srcByteVal </span><span class="cov8" title="62295957">{
                        break</span>
                }

                <span class="cov9" title="2399850072">mkvEnd++
                srcEnd++
                length++
                forwardExpanded++</span>
        }

        <span class="cov8" title="62295957">return mkvStart, srcStart, length</span>
}

// mergeRegions merges overlapping matched regions.
func (m *Matcher) mergeRegions() <span class="cov2" title="26">{
        if len(m.matchedRegions) == 0 </span><span class="cov1" title="2">{
                return
        }</span>

        // Sort by start offset
        <span class="cov2" title="24">sort.Slice(m.matchedRegions, func(i, j int) bool </span><span class="cov7" title="7086807">{
                return m.matchedRegions[i].mkvStart &lt; m.matchedRegions[j].mkvStart
        }</span>)

        // Merge overlapping regions
        // Pre-allocate with capacity since merged will be at most len(matchedRegions)
        <span class="cov2" title="24">merged := make([]matchedRegion, 1, len(m.matchedRegions))
        merged[0] = m.matchedRegions[0]
        for i := 1; i &lt; len(m.matchedRegions); i++ </span><span class="cov6" title="427470">{
                curr := m.matchedRegions[i]
                last := &amp;merged[len(merged)-1]

                // Check for overlap
                if curr.mkvStart &lt;= last.mkvEnd </span><span class="cov2" title="12">{
                        // Overlapping - extend if needed (keep the longer one)
                        if curr.mkvEnd &gt; last.mkvEnd </span><span class="cov1" title="10">{
                                // Current extends beyond last - need to decide which source to use
                                // For simplicity, keep the one that covers more
                                if (curr.mkvEnd - curr.mkvStart) &gt; (last.mkvEnd - last.mkvStart) </span><span class="cov1" title="2">{
                                        *last = curr
                                }</span> else<span class="cov1" title="8"> {
                                        last.mkvEnd = curr.mkvEnd
                                }</span>
                        }
                } else<span class="cov6" title="427458"> {
                        // No overlap - add new region
                        merged = append(merged, curr)
                }</span>
        }

        <span class="cov2" title="24">m.matchedRegions = merged</span>
}

// buildEntries creates the final entry list and delta data.
func (m *Matcher) buildEntries() ([]Entry, []byte) <span class="cov2" title="24">{
        // Pre-allocate entries: we'll have at most 2x matchedRegions (matched + gap entries)
        entries := make([]Entry, 0, len(m.matchedRegions)*2+1)
        // Pre-allocate deltaData with estimated unmatched size (typically small)
        deltaData := make([]byte, 0, 16*1024*1024) // 16MB initial capacity
        deltaOffset := int64(0)

        // Start from beginning of file
        pos := int64(0)
        regionIdx := 0

        for pos &lt; m.mkvSize </span><span class="cov6" title="854958">{
                // Check if we're in a matched region
                var inRegion *matchedRegion
                if regionIdx &lt; len(m.matchedRegions) &amp;&amp; m.matchedRegions[regionIdx].mkvStart &lt;= pos </span><span class="cov6" title="427472">{
                        inRegion = &amp;m.matchedRegions[regionIdx]
                }</span>

                <span class="cov6" title="854958">if inRegion != nil &amp;&amp; pos &gt;= inRegion.mkvStart &amp;&amp; pos &lt; inRegion.mkvEnd </span><span class="cov6" title="427472">{
                        // We're in a matched region
                        // Adjust source offset for our position within the region
                        offsetInRegion := pos - inRegion.mkvStart
                        regionLen := inRegion.mkvEnd - pos

                        entries = append(entries, Entry{
                                MkvOffset:        pos,
                                Length:           regionLen,
                                Source:           uint16(inRegion.fileIndex + 1),
                                SourceOffset:     inRegion.srcOffset + offsetInRegion,
                                IsVideo:          inRegion.isVideo,
                                AudioSubStreamID: inRegion.audioSubStreamID,
                        })

                        pos = inRegion.mkvEnd
                        regionIdx++
                }</span> else<span class="cov6" title="427486"> {
                        // We're in a gap (unmatched data)
                        gapEnd := m.mkvSize
                        if regionIdx &lt; len(m.matchedRegions) </span><span class="cov6" title="427468">{
                                gapEnd = m.matchedRegions[regionIdx].mkvStart
                        }</span>
                        <span class="cov6" title="427486">gapLen := gapEnd - pos

                        // Zero-copy: slice directly into mmap'd data for reading,
                        // but we need to copy it to deltaData since that's returned to caller
                        if gapEnd &lt;= m.mkvSize </span><span class="cov6" title="427486">{
                                data := m.mkvData[pos:gapEnd]
                                entries = append(entries, Entry{
                                        MkvOffset:    pos,
                                        Length:       gapLen,
                                        Source:       0,
                                        SourceOffset: deltaOffset,
                                })
                                deltaData = append(deltaData, data...)
                                deltaOffset += gapLen
                        }</span>

                        <span class="cov6" title="427486">pos = gapEnd</span>
                }
        }

        <span class="cov2" title="24">return entries, deltaData</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package mkv provides functionality for parsing MKV (Matroska) files.
package mkv

import (
        "encoding/binary"
        "errors"
        "fmt"
        "io"
)

// EBML Element IDs (Matroska specification)
const (
        // EBML Header elements
        IDEBMLHeader        = 0x1A45DFA3
        IDEBMLVersion       = 0x4286
        IDEBMLReadVersion   = 0x42F7
        IDEBMLMaxIDLength   = 0x42F2
        IDEBMLMaxSizeLength = 0x42F3
        IDDocType           = 0x4282
        IDDocTypeVersion    = 0x4287
        IDDocTypeReadVer    = 0x4285

        // Segment and top-level elements
        IDSegment  = 0x18538067
        IDSeekHead = 0x114D9B74
        IDInfo     = 0x1549A966
        IDTracks   = 0x1654AE6B
        IDChapters = 0x1043A770
        IDCluster  = 0x1F43B675
        IDCues     = 0x1C53BB6B
        IDTags     = 0x1254C367

        // Cluster elements
        IDTimestamp   = 0xE7
        IDSimpleBlock = 0xA3
        IDBlockGroup  = 0xA0
        IDBlock       = 0xA1

        // Track elements
        IDTrackEntry = 0xAE
        IDTrackNum   = 0xD7
        IDTrackUID   = 0x73C5
        IDTrackType  = 0x83
        IDCodecID    = 0x86
)

// Track types
const (
        TrackTypeVideo    = 1
        TrackTypeAudio    = 2
        TrackTypeComplex  = 3
        TrackTypeLogo     = 0x10
        TrackTypeSubtitle = 0x11
        TrackTypeButtons  = 0x12
        TrackTypeControl  = 0x20
)

// ErrInvalidEBML is returned when EBML parsing fails.
var ErrInvalidEBML = errors.New("invalid EBML data")

// Element represents a parsed EBML element.
type Element struct {
        ID         uint64 // Element ID (variable length)
        Size       int64  // Element size (-1 for unknown size)
        DataOffset int64  // Offset of element data in file
        HeaderSize int    // Size of ID + Size encoding
}

// ReadElementHeader reads an EBML element header (ID and size) from the reader.
// Returns the element info and any error encountered.
func ReadElementHeader(r io.Reader, offset int64) (Element, error) <span class="cov9" title="491208">{
        elem := Element{DataOffset: offset}

        // Read element ID (variable length, 1-4 bytes)
        id, idLen, err := readVINT(r, true)
        if err != nil </span><span class="cov1" title="4">{
                return elem, fmt.Errorf("read element ID: %w", err)
        }</span>
        <span class="cov9" title="491204">elem.ID = id
        elem.HeaderSize = idLen

        // Read element size (variable length, 1-8 bytes)
        size, sizeLen, err := readVINT(r, false)
        if err != nil </span><span class="cov0" title="0">{
                return elem, fmt.Errorf("read element size: %w", err)
        }</span>
        <span class="cov9" title="491204">elem.HeaderSize += sizeLen

        // Handle unknown size (all 1 bits after VINT marker)
        if isUnknownSize(size, sizeLen) </span><span class="cov1" title="2">{
                elem.Size = -1
        }</span> else<span class="cov9" title="491202"> {
                elem.Size = int64(size)
        }</span>

        <span class="cov9" title="491204">elem.DataOffset = offset + int64(elem.HeaderSize)

        return elem, nil</span>
}

// readVINT reads a variable-length integer (VINT) used in EBML.
// If keepMarker is true, the VINT marker bit is preserved (used for IDs).
// Returns the value, number of bytes read, and any error.
func readVINT(r io.Reader, keepMarker bool) (uint64, int, error) <span class="cov10" title="982442">{
        // Read first byte to determine length
        var firstByte [1]byte
        if _, err := io.ReadFull(r, firstByte[:]); err != nil </span><span class="cov1" title="2">{
                return 0, 0, err
        }</span>

        <span class="cov9" title="982440">b := firstByte[0]
        if b == 0 </span><span class="cov1" title="2">{
                return 0, 0, ErrInvalidEBML
        }</span>

        // Determine length from leading zeros
        <span class="cov9" title="982438">var length int
        var mask byte
        switch </span>{
        case b&amp;0x80 != 0:<span class="cov9" title="507958">
                length = 1
                mask = 0x7F</span>
        case b&amp;0x40 != 0:<span class="cov9" title="352484">
                length = 2
                mask = 0x3F</span>
        case b&amp;0x20 != 0:<span class="cov8" title="105206">
                length = 3
                mask = 0x1F</span>
        case b&amp;0x10 != 0:<span class="cov7" title="16750">
                length = 4
                mask = 0x0F</span>
        case b&amp;0x08 != 0:<span class="cov1" title="2">
                length = 5
                mask = 0x07</span>
        case b&amp;0x04 != 0:<span class="cov1" title="2">
                length = 6
                mask = 0x03</span>
        case b&amp;0x02 != 0:<span class="cov1" title="2">
                length = 7
                mask = 0x01</span>
        case b&amp;0x01 != 0:<span class="cov3" title="34">
                length = 8
                mask = 0x00</span>
        default:<span class="cov0" title="0">
                return 0, 0, ErrInvalidEBML</span>
        }

        // Build the value
        <span class="cov9" title="982438">var value uint64
        if keepMarker </span><span class="cov9" title="491214">{
                value = uint64(b)
        }</span> else<span class="cov9" title="491224"> {
                value = uint64(b &amp; mask)
        }</span>

        // Read remaining bytes
        <span class="cov9" title="982438">if length &gt; 1 </span><span class="cov9" title="474480">{
                remaining := make([]byte, length-1)
                if _, err := io.ReadFull(r, remaining); err != nil </span><span class="cov2" title="6">{
                        return 0, 0, err
                }</span>
                <span class="cov9" title="474474">for _, rb := range remaining </span><span class="cov9" title="613400">{
                        value = (value &lt;&lt; 8) | uint64(rb)
                }</span>
        }

        <span class="cov9" title="982432">return value, length, nil</span>
}

// isUnknownSize checks if a VINT value represents "unknown size".
// Unknown size is represented by all data bits being 1.
func isUnknownSize(value uint64, length int) bool <span class="cov9" title="491216">{
        // Unknown size values: 0x7F (1 byte), 0x3FFF (2 bytes), etc.
        maxValues := []uint64{
                0x7F,
                0x3FFF,
                0x1FFFFF,
                0x0FFFFFFF,
                0x07FFFFFFFF,
                0x03FFFFFFFFFF,
                0x01FFFFFFFFFFFF,
                0x00FFFFFFFFFFFFFF,
        }
        if length &lt; 1 || length &gt; 8 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov9" title="491216">return value == maxValues[length-1]</span>
}

// ReadUint reads an unsigned integer element value.
func ReadUint(r io.Reader, size int64) (uint64, error) <span class="cov7" title="16750">{
        if size &lt; 0 || size &gt; 8 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid uint size: %d", size)
        }</span>
        <span class="cov7" title="16750">if size == 0 </span><span class="cov1" title="4">{
                return 0, nil
        }</span>

        <span class="cov7" title="16746">buf := make([]byte, size)
        if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov1" title="2">{
                return 0, err
        }</span>

        <span class="cov7" title="16744">var value uint64
        for _, b := range buf </span><span class="cov8" title="49404">{
                value = (value &lt;&lt; 8) | uint64(b)
        }</span>
        <span class="cov7" title="16744">return value, nil</span>
}

// ReadInt reads a signed integer element value.
func ReadInt(r io.Reader, size int64) (int64, error) <span class="cov2" title="10">{
        u, err := ReadUint(r, size)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Sign extend if necessary
        <span class="cov2" title="10">if size &gt; 0 &amp;&amp; u&gt;&gt;(uint(size)*8-1) != 0 </span><span class="cov1" title="4">{
                // Negative number - extend sign
                mask := ^uint64(0) &lt;&lt; (uint(size) * 8)
                return int64(u | mask), nil
        }</span>
        <span class="cov2" title="6">return int64(u), nil</span>
}

// ReadString reads a string element value.
func ReadString(r io.Reader, size int64) (string, error) <span class="cov3" title="22">{
        if size &lt; 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid string size: %d", size)
        }</span>
        <span class="cov3" title="22">if size == 0 </span><span class="cov1" title="2">{
                return "", nil
        }</span>

        <span class="cov2" title="20">buf := make([]byte, size)
        if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov1" title="2">{
                return "", err
        }</span>

        // Trim null bytes
        <span class="cov2" title="18">for i := len(buf) - 1; i &gt;= 0 &amp;&amp; buf[i] == 0; i-- </span><span class="cov2" title="6">{
                buf = buf[:i]
        }</span>

        <span class="cov2" title="18">return string(buf), nil</span>
}

// ReadBinary reads binary data of the specified size.
func ReadBinary(r io.Reader, size int64) ([]byte, error) <span class="cov2" title="8">{
        if size &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid binary size: %d", size)
        }</span>
        <span class="cov2" title="8">if size == 0 </span><span class="cov1" title="2">{
                return nil, nil
        }</span>

        <span class="cov2" title="6">buf := make([]byte, size)
        if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>
        <span class="cov1" title="4">return buf, nil</span>
}

// SimpleBlockHeader contains the decoded header of a SimpleBlock.
type SimpleBlockHeader struct {
        TrackNumber uint64
        Timestamp   int16 // Relative to cluster timestamp
        Flags       byte  // Keyframe, invisible, lacing, discardable
        HeaderSize  int   // Total header size in bytes
}

// Block flags
const (
        FlagKeyframe    = 0x80
        FlagInvisible   = 0x08
        FlagLacing      = 0x06 // Mask for lacing type
        FlagDiscardable = 0x01
)

// Lacing types
const (
        LacingNone  = 0x00
        LacingXiph  = 0x02
        LacingFixed = 0x04
        LacingEBML  = 0x06
)

// ParseSimpleBlockHeader parses the header of a SimpleBlock element.
// The data should start at the beginning of the SimpleBlock element data (after ID and size).
func ParseSimpleBlockHeader(data []byte) (SimpleBlockHeader, error) <span class="cov9" title="440928">{
        if len(data) &lt; 4 </span><span class="cov1" title="4">{
                return SimpleBlockHeader{}, fmt.Errorf("SimpleBlock too short: %d bytes", len(data))
        }</span>

        <span class="cov9" title="440924">var header SimpleBlockHeader
        offset := 0

        // Track number (VINT without marker)
        trackNum, trackLen := parseVINTFromBytes(data[offset:])
        header.TrackNumber = trackNum
        offset += trackLen

        if offset+3 &gt; len(data) </span><span class="cov0" title="0">{
                return SimpleBlockHeader{}, fmt.Errorf("SimpleBlock header truncated")
        }</span>

        // Timestamp (2 bytes, signed, big-endian)
        <span class="cov9" title="440924">header.Timestamp = int16(binary.BigEndian.Uint16(data[offset:]))
        offset += 2

        // Flags (1 byte)
        header.Flags = data[offset]
        offset++

        header.HeaderSize = offset
        return header, nil</span>
}

// parseVINTFromBytes parses a VINT from a byte slice (without marker preservation).
func parseVINTFromBytes(data []byte) (uint64, int) <span class="cov9" title="440932">{
        if len(data) == 0 </span><span class="cov1" title="2">{
                return 0, 0
        }</span>

        <span class="cov9" title="440930">b := data[0]
        if b == 0 </span><span class="cov1" title="2">{
                return 0, 0
        }</span>

        <span class="cov9" title="440928">var length int
        var mask byte
        switch </span>{
        case b&amp;0x80 != 0:<span class="cov9" title="440924">
                length = 1
                mask = 0x7F</span>
        case b&amp;0x40 != 0:<span class="cov1" title="4">
                length = 2
                mask = 0x3F</span>
        case b&amp;0x20 != 0:<span class="cov0" title="0">
                length = 3
                mask = 0x1F</span>
        case b&amp;0x10 != 0:<span class="cov0" title="0">
                length = 4
                mask = 0x0F</span>
        default:<span class="cov0" title="0">
                return 0, 0</span>
        }

        <span class="cov9" title="440928">if len(data) &lt; length </span><span class="cov0" title="0">{
                return 0, 0
        }</span>

        <span class="cov9" title="440928">var value uint64 = uint64(b &amp; mask)
        for i := 1; i &lt; length; i++ </span><span class="cov1" title="4">{
                value = (value &lt;&lt; 8) | uint64(data[i])
        }</span>

        <span class="cov9" title="440928">return value, length</span>
}

// IsKeyframe returns true if the SimpleBlock/Block is a keyframe.
func (h SimpleBlockHeader) IsKeyframe() bool <span class="cov9" title="440922">{
        return h.Flags&amp;FlagKeyframe != 0
}</span>

// LacingType returns the lacing type used in the block.
func (h SimpleBlockHeader) LacingType() byte <span class="cov9" title="440924">{
        return h.Flags &amp; FlagLacing
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package mkv

import (
        "bytes"
        "fmt"
        "io"
        "os"

        "github.com/stuckj/mkvdup/internal/mmap"
)

// Packet represents a codec data packet extracted from an MKV file.
type Packet struct {
        Offset    int64  // Offset in the MKV file where packet data starts
        Size      int64  // Size of packet data
        TrackNum  uint64 // Track number this packet belongs to
        Timestamp int64  // Absolute timestamp (cluster + block relative)
        Keyframe  bool   // Whether this is a keyframe
}

// Track represents an MKV track (video, audio, etc).
type Track struct {
        Number  uint64
        UID     uint64
        Type    int
        CodecID string
}

// Parser parses MKV files to extract codec packets.
type Parser struct {
        path     string
        mmapFile *mmap.File
        data     []byte // Zero-copy mmap'd data
        size     int64
        tracks   []Track
        packets  []Packet
}

// NewParser creates a new MKV parser for the given file.
func NewParser(path string) (*Parser, error) <span class="cov2" title="16">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("stat file: %w", err)
        }</span>

        <span class="cov2" title="14">mmapFile, err := mmap.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mmap file: %w", err)
        }</span>

        <span class="cov2" title="14">return &amp;Parser{
                path:     path,
                mmapFile: mmapFile,
                data:     mmapFile.Data(),
                size:     info.Size(),
        }, nil</span>
}

// Close releases resources used by the parser.
func (p *Parser) Close() error <span class="cov2" title="16">{
        if p.mmapFile != nil </span><span class="cov2" title="16">{
                return p.mmapFile.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Size returns the file size.
func (p *Parser) Size() int64 <span class="cov1" title="2">{
        return p.size
}</span>

// ProgressFunc is called to report parsing progress.
type ProgressFunc func(processed, total int64)

// Parse parses the MKV file and extracts all codec packets.
// If progress is non-nil, it will be called periodically.
func (p *Parser) Parse(progress ProgressFunc) error <span class="cov2" title="10">{
        offset := int64(0)

        // Parse EBML header
        elem, err := p.readElementAt(offset)
        if err != nil </span><span class="cov1" title="4">{
                return fmt.Errorf("read EBML header: %w", err)
        }</span>
        <span class="cov2" title="6">if elem.ID != IDEBMLHeader </span><span class="cov0" title="0">{
                return fmt.Errorf("expected EBML header, got 0x%X", elem.ID)
        }</span>
        <span class="cov2" title="6">offset = elem.DataOffset + elem.Size

        // Parse Segment
        elem, err = p.readElementAt(offset)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read Segment: %w", err)
        }</span>
        <span class="cov2" title="6">if elem.ID != IDSegment </span><span class="cov0" title="0">{
                return fmt.Errorf("expected Segment, got 0x%X", elem.ID)
        }</span>

        <span class="cov2" title="6">segmentDataStart := elem.DataOffset
        segmentEnd := p.size
        if elem.Size &gt; 0 </span><span class="cov2" title="6">{
                segmentEnd = elem.DataOffset + elem.Size
        }</span>

        // Parse segment contents
        <span class="cov2" title="6">offset = segmentDataStart
        var clusterTimestamp int64

        for offset &lt; segmentEnd </span><span class="cov7" title="16728">{
                if progress != nil &amp;&amp; offset%(1024*1024) == 0 </span><span class="cov0" title="0">{
                        progress(offset, p.size)
                }</span>

                <span class="cov7" title="16728">elem, err = p.readElementAt(offset)
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("read element at %d: %w", offset, err)</span>
                }

                <span class="cov7" title="16728">switch elem.ID </span>{
                case IDTracks:<span class="cov2" title="6">
                        if err := p.parseTracks(elem); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("parse tracks: %w", err)
                        }</span>

                case IDCluster:<span class="cov7" title="16692">
                        if err := p.parseCluster(elem, &amp;clusterTimestamp); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("parse cluster at %d: %w", offset, err)
                        }</span>
                }

                // Move to next element
                <span class="cov7" title="16728">if elem.Size &lt; 0 </span><span class="cov0" title="0">{
                        // Unknown size - need to scan for next element
                        // For now, we'll just move past the header
                        offset = elem.DataOffset
                }</span> else<span class="cov7" title="16728"> {
                        offset = elem.DataOffset + elem.Size
                }</span>
        }

        <span class="cov2" title="6">if progress != nil </span><span class="cov0" title="0">{
                progress(p.size, p.size)
        }</span>

        <span class="cov2" title="6">return nil</span>
}

// readElementAt reads an EBML element header at the given offset.
func (p *Parser) readElementAt(offset int64) (Element, error) <span class="cov10" title="491200">{
        if offset &gt;= p.size </span><span class="cov1" title="2">{
                return Element{}, io.EOF
        }</span>

        // Zero-copy: create a bytes.Reader over the slice (no data copied)
        <span class="cov9" title="491198">r := bytes.NewReader(p.data[offset:])
        return ReadElementHeader(r, offset)</span>
}

// parseTracks parses the Tracks element to extract track information.
func (p *Parser) parseTracks(tracksElem Element) error <span class="cov2" title="6">{
        offset := tracksElem.DataOffset
        end := tracksElem.DataOffset + tracksElem.Size

        for offset &lt; end </span><span class="cov2" title="18">{
                elem, err := p.readElementAt(offset)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov2" title="18">if elem.ID == IDTrackEntry </span><span class="cov2" title="12">{
                        track, err := p.parseTrackEntry(elem)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("parse track entry: %w", err)
                        }</span>
                        <span class="cov2" title="12">p.tracks = append(p.tracks, track)</span>
                }

                <span class="cov2" title="18">offset = elem.DataOffset + elem.Size</span>
        }

        <span class="cov2" title="6">return nil</span>
}

// parseTrackEntry parses a TrackEntry element.
func (p *Parser) parseTrackEntry(trackElem Element) (Track, error) <span class="cov2" title="12">{
        var track Track
        offset := trackElem.DataOffset
        end := trackElem.DataOffset + trackElem.Size

        for offset &lt; end </span><span class="cov4" title="138">{
                elem, err := p.readElementAt(offset)
                if err != nil </span><span class="cov0" title="0">{
                        return track, err
                }</span>

                // Zero-copy: create a bytes.Reader over the slice
                <span class="cov4" title="138">r := bytes.NewReader(p.data[elem.DataOffset : elem.DataOffset+elem.Size])

                switch elem.ID </span>{
                case IDTrackNum:<span class="cov2" title="12">
                        track.Number, _ = ReadUint(r, elem.Size)</span>
                case IDTrackUID:<span class="cov2" title="12">
                        track.UID, _ = ReadUint(r, elem.Size)</span>
                case IDTrackType:<span class="cov2" title="12">
                        t, _ := ReadUint(r, elem.Size)
                        track.Type = int(t)</span>
                case IDCodecID:<span class="cov2" title="12">
                        track.CodecID, _ = ReadString(r, elem.Size)</span>
                }

                <span class="cov4" title="138">offset = elem.DataOffset + elem.Size</span>
        }

        <span class="cov2" title="12">return track, nil</span>
}

// parseCluster parses a Cluster element and extracts packets.
func (p *Parser) parseCluster(clusterElem Element, clusterTimestamp *int64) error <span class="cov7" title="16692">{
        offset := clusterElem.DataOffset
        end := clusterElem.DataOffset + clusterElem.Size
        if clusterElem.Size &lt; 0 </span><span class="cov0" title="0">{
                // Unknown size - parse until we hit another top-level element
                end = p.size
        }</span>

        <span class="cov7" title="16692">for offset &lt; end </span><span class="cov9" title="474300">{
                elem, err := p.readElementAt(offset)
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }

                // Check if we've hit a top-level element (end of cluster with unknown size)
                <span class="cov9" title="474300">if isTopLevelElement(elem.ID) &amp;&amp; clusterElem.Size &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov9" title="474300">switch elem.ID </span>{
                case IDTimestamp:<span class="cov7" title="16692">
                        // Zero-copy: create a bytes.Reader over the slice
                        r := bytes.NewReader(p.data[elem.DataOffset : elem.DataOffset+elem.Size])
                        ts, _ := ReadUint(r, elem.Size)
                        *clusterTimestamp = int64(ts)</span>

                case IDSimpleBlock:<span class="cov9" title="440916">
                        if err := p.parseSimpleBlock(elem, *clusterTimestamp); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("parse SimpleBlock: %w", err)
                        }</span>

                case IDBlockGroup:<span class="cov0" title="0">
                        if err := p.parseBlockGroup(elem, *clusterTimestamp); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("parse BlockGroup: %w", err)
                        }</span>
                }

                <span class="cov9" title="474300">offset = elem.DataOffset + elem.Size</span>
        }

        <span class="cov7" title="16692">return nil</span>
}

// parseSimpleBlock parses a SimpleBlock element and adds packets.
func (p *Parser) parseSimpleBlock(elem Element, clusterTimestamp int64) error <span class="cov9" title="440916">{
        // Zero-copy: read header bytes directly from mmap'd data
        readSize := elem.Size
        if readSize &gt; 16 </span><span class="cov9" title="440910">{
                readSize = 16 // More than enough for header
        }</span>

        <span class="cov9" title="440916">endOffset := elem.DataOffset + readSize
        if endOffset &gt; p.size </span><span class="cov0" title="0">{
                endOffset = p.size
        }</span>
        <span class="cov9" title="440916">headerBuf := p.data[elem.DataOffset:endOffset]
        if len(headerBuf) &lt; 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("read SimpleBlock header: data too short")
        }</span>

        <span class="cov9" title="440916">header, err := ParseSimpleBlockHeader(headerBuf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // The packet data follows the header
        <span class="cov9" title="440916">packetOffset := elem.DataOffset + int64(header.HeaderSize)
        packetSize := elem.Size - int64(header.HeaderSize)

        // Handle lacing if present
        if header.LacingType() != LacingNone </span><span class="cov0" title="0">{
                // For now, treat the entire laced data as one packet
                // A more complete implementation would parse individual frames
                p.packets = append(p.packets, Packet{
                        Offset:    packetOffset,
                        Size:      packetSize,
                        TrackNum:  header.TrackNumber,
                        Timestamp: clusterTimestamp + int64(header.Timestamp),
                        Keyframe:  header.IsKeyframe(),
                })
        }</span> else<span class="cov9" title="440916"> {
                p.packets = append(p.packets, Packet{
                        Offset:    packetOffset,
                        Size:      packetSize,
                        TrackNum:  header.TrackNumber,
                        Timestamp: clusterTimestamp + int64(header.Timestamp),
                        Keyframe:  header.IsKeyframe(),
                })
        }</span>

        <span class="cov9" title="440916">return nil</span>
}

// parseBlockGroup parses a BlockGroup element and adds packets.
func (p *Parser) parseBlockGroup(groupElem Element, clusterTimestamp int64) error <span class="cov0" title="0">{
        offset := groupElem.DataOffset
        end := groupElem.DataOffset + groupElem.Size

        for offset &lt; end </span><span class="cov0" title="0">{
                elem, err := p.readElementAt(offset)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if elem.ID == IDBlock </span><span class="cov0" title="0">{
                        // Block has same format as SimpleBlock for the header
                        // Zero-copy: read header bytes directly from mmap'd data
                        readSize := elem.Size
                        if readSize &gt; 16 </span><span class="cov0" title="0">{
                                readSize = 16
                        }</span>

                        <span class="cov0" title="0">endOffset := elem.DataOffset + readSize
                        if endOffset &gt; p.size </span><span class="cov0" title="0">{
                                endOffset = p.size
                        }</span>
                        <span class="cov0" title="0">headerBuf := p.data[elem.DataOffset:endOffset]
                        if len(headerBuf) &lt; 4 </span><span class="cov0" title="0">{
                                return fmt.Errorf("read Block header: data too short")
                        }</span>

                        <span class="cov0" title="0">header, err := ParseSimpleBlockHeader(headerBuf)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">packetOffset := elem.DataOffset + int64(header.HeaderSize)
                        packetSize := elem.Size - int64(header.HeaderSize)

                        p.packets = append(p.packets, Packet{
                                Offset:    packetOffset,
                                Size:      packetSize,
                                TrackNum:  header.TrackNumber,
                                Timestamp: clusterTimestamp + int64(header.Timestamp),
                                Keyframe:  false, // Block doesn't have keyframe flag, would need ReferenceBlock
                        })</span>
                }

                <span class="cov0" title="0">offset = elem.DataOffset + elem.Size</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// isTopLevelElement returns true if the element ID is a top-level segment child.
func isTopLevelElement(id uint64) bool <span class="cov9" title="474320">{
        switch id </span>{
        case IDSeekHead, IDInfo, IDTracks, IDChapters, IDCluster, IDCues, IDTags:<span class="cov2" title="14">
                return true</span>
        }
        <span class="cov9" title="474306">return false</span>
}

// Packets returns all parsed packets.
func (p *Parser) Packets() []Packet <span class="cov2" title="8">{
        return p.packets
}</span>

// Tracks returns all parsed tracks.
func (p *Parser) Tracks() []Track <span class="cov2" title="8">{
        return p.tracks
}</span>

// PacketCount returns the number of packets parsed.
func (p *Parser) PacketCount() int <span class="cov1" title="4">{
        return len(p.packets)
}</span>

// VideoPacketCount returns the number of video packets.
func (p *Parser) VideoPacketCount() int <span class="cov0" title="0">{
        count := 0
        videoTracks := make(map[uint64]bool)
        for _, t := range p.tracks </span><span class="cov0" title="0">{
                if t.Type == TrackTypeVideo </span><span class="cov0" title="0">{
                        videoTracks[t.Number] = true
                }</span>
        }
        <span class="cov0" title="0">for _, pkt := range p.packets </span><span class="cov0" title="0">{
                if videoTracks[pkt.TrackNum] </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// AudioPacketCount returns the number of audio packets.
func (p *Parser) AudioPacketCount() int <span class="cov0" title="0">{
        count := 0
        audioTracks := make(map[uint64]bool)
        for _, t := range p.tracks </span><span class="cov0" title="0">{
                if t.Type == TrackTypeAudio </span><span class="cov0" title="0">{
                        audioTracks[t.Number] = true
                }</span>
        }
        <span class="cov0" title="0">for _, pkt := range p.packets </span><span class="cov0" title="0">{
                if audioTracks[pkt.TrackNum] </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// ReadPacketData reads the data for a packet.
// Returns a slice into the mmap'd data (zero-copy).
// The returned slice is valid until Close() is called.
func (p *Parser) ReadPacketData(pkt Packet) ([]byte, error) <span class="cov0" title="0">{
        endOffset := pkt.Offset + pkt.Size
        if endOffset &gt; p.size </span><span class="cov0" title="0">{
                endOffset = p.size
        }</span>
        <span class="cov0" title="0">if pkt.Offset &gt;= p.size </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read packet data: offset out of range")
        }</span>
        // Zero-copy: return slice directly into mmap'd data
        <span class="cov0" title="0">return p.data[pkt.Offset:endOffset], nil</span>
}

// Data returns the raw mmap'd file data for zero-copy access.
// The returned slice is valid until Close() is called.
func (p *Parser) Data() []byte <span class="cov1" title="2">{
        return p.data
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package mmap provides zero-copy memory-mapped file access.
package mmap

import (
        "fmt"
        "os"

        "golang.org/x/sys/unix"
)

// File provides zero-copy access to a memory-mapped file.
// Unlike golang.org/x/exp/mmap, this exposes the raw []byte slice
// allowing direct access without copying data.
type File struct {
        data []byte
        size int64
}

// Open opens a file and memory-maps it for reading.
// The returned File provides zero-copy access to the file contents.
func Open(path string) (*File, error) <span class="cov3" title="236">{
        f, err := os.Open(path)
        if err != nil </span><span class="cov1" title="4">{
                return nil, fmt.Errorf("open file: %w", err)
        }</span>
        <span class="cov3" title="232">defer f.Close()

        info, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("stat file: %w", err)
        }</span>

        <span class="cov3" title="232">size := info.Size()
        if size == 0 </span><span class="cov1" title="8">{
                return &amp;File{data: nil, size: 0}, nil
        }</span>

        <span class="cov3" title="224">data, err := unix.Mmap(int(f.Fd()), 0, int(size), unix.PROT_READ, unix.MAP_SHARED)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mmap: %w", err)
        }</span>

        <span class="cov3" title="224">return &amp;File{data: data, size: size}, nil</span>
}

// Data returns the raw byte slice for direct zero-copy access.
// The slice is valid until Close() is called.
func (m *File) Data() []byte <span class="cov2" title="39">{
        return m.data
}</span>

// Size returns the size of the mapped file in bytes.
func (m *File) Size() int64 <span class="cov3" title="115">{
        return m.size
}</span>

// Len returns the size of the mapped file as int (for compatibility).
func (m *File) Len() int <span class="cov1" title="4">{
        return int(m.size)
}</span>

// Slice returns a sub-slice of the mapped data without copying.
// Returns nil if the range is out of bounds.
func (m *File) Slice(offset int64, size int) []byte <span class="cov10" title="350911632">{
        if offset &lt; 0 || offset &gt;= m.size </span><span class="cov1" title="6">{
                return nil
        }</span>
        <span class="cov9" title="350911626">end := offset + int64(size)
        if end &gt; m.size </span><span class="cov1" title="2">{
                end = m.size
        }</span>
        <span class="cov9" title="350911626">return m.data[offset:end]</span>
}

// Advise provides hints to the kernel about expected access patterns.
// Use MADV_DONTNEED to release pages (they'll be re-faulted when accessed).
// Use MADV_SEQUENTIAL to hint sequential access pattern.
func (m *File) Advise(advice int) error <span class="cov1" title="8">{
        if len(m.data) == 0 </span><span class="cov1" title="2">{
                return nil
        }</span>
        <span class="cov1" title="6">return unix.Madvise(m.data, advice)</span>
}

// Close unmaps the file from memory.
func (m *File) Close() error <span class="cov3" title="226">{
        if m.data == nil </span><span class="cov2" title="14">{
                return nil
        }</span>
        <span class="cov3" title="212">err := unix.Munmap(m.data)
        m.data = nil
        return err</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package source

// FindAudioSyncPoints finds all audio sync pattern positions in the data.
// Detects AC3, DTS, TrueHD, and MPEG Audio sync patterns.
// Returns offsets where sync patterns begin.
func FindAudioSyncPoints(data []byte) []int <span class="cov6" title="690110">{
        if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="690110">var offsets []int

        for i := 0; i &lt;= len(data)-2; i++ </span><span class="cov10" title="1912423398">{
                // AC3/E-AC3: 0B 77
                if data[i] == 0x0B &amp;&amp; data[i+1] == 0x77 </span><span class="cov6" title="1294520">{
                        offsets = append(offsets, i)
                        continue</span>
                }

                // DTS/DTS-HD: 7F FE 80 01
                <span class="cov9" title="1911128878">if i &lt;= len(data)-4 &amp;&amp;
                        data[i] == 0x7F &amp;&amp; data[i+1] == 0xFE &amp;&amp;
                        data[i+2] == 0x80 &amp;&amp; data[i+3] == 0x01 </span><span class="cov1" title="6">{
                        offsets = append(offsets, i)
                        continue</span>
                }

                // TrueHD: F8 72 6F BA
                <span class="cov9" title="1911128872">if i &lt;= len(data)-4 &amp;&amp;
                        data[i] == 0xF8 &amp;&amp; data[i+1] == 0x72 &amp;&amp;
                        data[i+2] == 0x6F &amp;&amp; data[i+3] == 0xBA </span><span class="cov1" title="4">{
                        offsets = append(offsets, i)
                        continue</span>
                }

                // MPEG Audio / AAC ADTS: FF Fx (0xFF followed by 0xF0-0xFF)
                // The sync word is 11 bits of 1s, so we check for 0xFF followed by 0xFx
                <span class="cov9" title="1911128868">if data[i] == 0xFF &amp;&amp; (data[i+1]&amp;0xF0) == 0xF0 </span><span class="cov7" title="7983750">{
                        offsets = append(offsets, i)
                        continue</span>
                }
        }

        <span class="cov6" title="690110">return offsets</span>
}

// FindAudioSyncPointsInRange finds audio sync points within a specific range of data.
// This is useful for processing large files in chunks.
func FindAudioSyncPointsInRange(data []byte, startOffset int) []int <span class="cov1" title="2">{
        if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="2">var offsets []int

        for i := 0; i &lt;= len(data)-2; i++ </span><span class="cov1" title="8">{
                // AC3/E-AC3: 0B 77
                if data[i] == 0x0B &amp;&amp; data[i+1] == 0x77 </span><span class="cov1" title="4">{
                        offsets = append(offsets, startOffset+i)
                        continue</span>
                }

                // DTS/DTS-HD: 7F FE 80 01
                <span class="cov1" title="4">if i &lt;= len(data)-4 &amp;&amp;
                        data[i] == 0x7F &amp;&amp; data[i+1] == 0xFE &amp;&amp;
                        data[i+2] == 0x80 &amp;&amp; data[i+3] == 0x01 </span><span class="cov0" title="0">{
                        offsets = append(offsets, startOffset+i)
                        continue</span>
                }

                // TrueHD: F8 72 6F BA
                <span class="cov1" title="4">if i &lt;= len(data)-4 &amp;&amp;
                        data[i] == 0xF8 &amp;&amp; data[i+1] == 0x72 &amp;&amp;
                        data[i+2] == 0x6F &amp;&amp; data[i+3] == 0xBA </span><span class="cov0" title="0">{
                        offsets = append(offsets, startOffset+i)
                        continue</span>
                }

                // MPEG Audio / AAC ADTS: FF Fx
                <span class="cov1" title="4">if data[i] == 0xFF &amp;&amp; (data[i+1]&amp;0xF0) == 0xF0 </span><span class="cov0" title="0">{
                        offsets = append(offsets, startOffset+i)
                        continue</span>
                }
        }

        <span class="cov1" title="2">return offsets</span>
}

// FindAllSyncPoints finds both video start codes and audio sync patterns.
// Returns combined offsets sorted by position.
func FindAllSyncPoints(data []byte) []int <span class="cov1" title="3">{
        videoOffsets := FindVideoStartCodes(data)
        audioOffsets := FindAudioSyncPoints(data)

        // Combine and sort
        combined := make([]int, 0, len(videoOffsets)+len(audioOffsets))
        combined = append(combined, videoOffsets...)
        combined = append(combined, audioOffsets...)

        // Simple insertion sort since lists are already sorted
        // and we just need to merge them
        result := make([]int, 0, len(combined))
        vi, ai := 0, 0
        for vi &lt; len(videoOffsets) || ai &lt; len(audioOffsets) </span><span class="cov7" title="8744370">{
                if vi &gt;= len(videoOffsets) </span><span class="cov4" title="5390">{
                        result = append(result, audioOffsets[ai])
                        ai++
                }</span> else<span class="cov7" title="8738980"> if ai &gt;= len(audioOffsets) </span><span class="cov1" title="2">{
                        result = append(result, videoOffsets[vi])
                        vi++
                }</span> else<span class="cov7" title="8738978"> if videoOffsets[vi] &lt;= audioOffsets[ai] </span><span class="cov6" title="1291817">{
                        result = append(result, videoOffsets[vi])
                        vi++
                }</span> else<span class="cov7" title="7447161"> {
                        result = append(result, audioOffsets[ai])
                        ai++
                }</span>
        }

        <span class="cov1" title="3">return result</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package source

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/stuckj/mkvdup/internal/mkv"
)

// CodecType represents a broad codec family.
type CodecType int

// Codec type constants.
const (
        CodecUnknown CodecType = iota
        CodecMPEG1Video
        CodecMPEG2Video
        CodecH264Video
        CodecH265Video
        CodecVC1Video
        CodecAC3Audio
        CodecEAC3Audio
        CodecDTSAudio
        CodecDTSHDAudio
        CodecTrueHDAudio
        CodecLPCMAudio
        CodecMPEGAudio
        CodecAACaudio
        CodecFLACAudio
        CodecOpusAudio
)

// CodecTypeName returns a human-readable name for a codec type.
func CodecTypeName(ct CodecType) string <span class="cov6" title="32">{
        switch ct </span>{
        case CodecMPEG1Video:<span class="cov2" title="2">
                return "MPEG-1"</span>
        case CodecMPEG2Video:<span class="cov2" title="2">
                return "MPEG-2"</span>
        case CodecH264Video:<span class="cov2" title="2">
                return "H.264"</span>
        case CodecH265Video:<span class="cov2" title="2">
                return "H.265"</span>
        case CodecVC1Video:<span class="cov2" title="2">
                return "VC-1"</span>
        case CodecAC3Audio:<span class="cov2" title="2">
                return "AC3"</span>
        case CodecEAC3Audio:<span class="cov2" title="2">
                return "E-AC3"</span>
        case CodecDTSAudio:<span class="cov2" title="2">
                return "DTS"</span>
        case CodecDTSHDAudio:<span class="cov2" title="2">
                return "DTS-HD"</span>
        case CodecTrueHDAudio:<span class="cov2" title="2">
                return "TrueHD"</span>
        case CodecLPCMAudio:<span class="cov2" title="2">
                return "LPCM"</span>
        case CodecMPEGAudio:<span class="cov2" title="2">
                return "MPEG Audio"</span>
        case CodecAACaudio:<span class="cov2" title="2">
                return "AAC"</span>
        case CodecFLACAudio:<span class="cov2" title="2">
                return "FLAC"</span>
        case CodecOpusAudio:<span class="cov2" title="2">
                return "Opus"</span>
        default:<span class="cov2" title="2">
                return "Unknown"</span>
        }
}

// IsVideoCodec returns true if the codec type is a video codec.
func IsVideoCodec(ct CodecType) bool <span class="cov6" title="36">{
        switch ct </span>{
        case CodecMPEG1Video, CodecMPEG2Video, CodecH264Video, CodecH265Video, CodecVC1Video:<span class="cov5" title="24">
                return true</span>
        }
        <span class="cov4" title="12">return false</span>
}

// IsAudioCodec returns true if the codec type is an audio codec.
func IsAudioCodec(ct CodecType) bool <span class="cov6" title="48">{
        switch ct </span>{
        case CodecAC3Audio, CodecEAC3Audio, CodecDTSAudio, CodecDTSHDAudio,
                CodecTrueHDAudio, CodecLPCMAudio, CodecMPEGAudio, CodecAACaudio,
                CodecFLACAudio, CodecOpusAudio:<span class="cov6" title="42">
                return true</span>
        }
        <span class="cov3" title="6">return false</span>
}

// MKVCodecToType maps an MKV CodecID string to a CodecType.
func MKVCodecToType(codecID string) CodecType <span class="cov7" title="76">{
        switch </span>{
        case codecID == "V_MPEG1":<span class="cov3" title="4">
                return CodecMPEG1Video</span>
        case codecID == "V_MPEG2":<span class="cov3" title="6">
                return CodecMPEG2Video</span>
        case codecID == "V_MPEG4/ISO/AVC":<span class="cov3" title="6">
                return CodecH264Video</span>
        case codecID == "V_MPEGH/ISO/HEVC":<span class="cov2" title="2">
                return CodecH265Video</span>
        case codecID == "V_MS/VFW/FOURCC":<span class="cov3" title="4">
                // Could be VC-1 or other; can't determine without codec private data
                return CodecUnknown</span>
        case codecID == "A_AC3":<span class="cov4" title="12">
                return CodecAC3Audio</span>
        case codecID == "A_EAC3":<span class="cov2" title="2">
                return CodecEAC3Audio</span>
        case codecID == "A_DTS":<span class="cov3" title="4">
                return CodecDTSAudio</span>
        case strings.HasPrefix(codecID, "A_DTS/"):<span class="cov3" title="4">
                // A_DTS/EXPRESS, A_DTS/LOSSLESS, etc.
                return CodecDTSHDAudio</span>
        case codecID == "A_TRUEHD":<span class="cov2" title="2">
                return CodecTrueHDAudio</span>
        case strings.HasPrefix(codecID, "A_PCM/"):<span class="cov3" title="6">
                // A_PCM/INT/LIT, A_PCM/INT/BIG, A_PCM/FLOAT/IEEE
                return CodecLPCMAudio</span>
        case strings.HasPrefix(codecID, "A_MPEG/"):<span class="cov3" title="4">
                // A_MPEG/L2, A_MPEG/L3
                return CodecMPEGAudio</span>
        case strings.HasPrefix(codecID, "A_AAC"):<span class="cov3" title="4">
                // A_AAC, A_AAC/MPEG2/MAIN, etc.
                return CodecAACaudio</span>
        case codecID == "A_FLAC":<span class="cov3" title="6">
                return CodecFLACAudio</span>
        case codecID == "A_OPUS":<span class="cov2" title="2">
                return CodecOpusAudio</span>
        default:<span class="cov4" title="8">
                return CodecUnknown</span>
        }
}

// SourceCodecs describes the codecs found in a source media.
type SourceCodecs struct {
        VideoCodecs []CodecType
        AudioCodecs []CodecType
}

// CodecMismatch describes a detected codec mismatch between MKV and source.
type CodecMismatch struct {
        TrackType    string      // "video" or "audio"
        MKVCodecID   string      // e.g. "V_MPEG4/ISO/AVC"
        MKVCodecType CodecType   // resolved codec type
        SourceCodecs []CodecType // codecs found in source for this track type
}

// DetectSourceCodecs determines what codecs are present in the source media.
// For DVD sources, it extracts codec info from the already-parsed MPEG-PS data.
// For Blu-ray sources, it performs a lightweight PMT scan of the first M2TS file.
func DetectSourceCodecs(index *Index) (*SourceCodecs, error) <span class="cov0" title="0">{
        switch index.SourceType </span>{
        case TypeDVD:<span class="cov0" title="0">
                return detectDVDCodecs(index)</span>
        case TypeBluray:<span class="cov0" title="0">
                return detectBlurayCodecs(index)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown source type")</span>
        }
}

// detectDVDCodecs extracts codec information from an already-indexed DVD source.
// The MPEG-PS parser has already identified video and audio streams during indexing.
func detectDVDCodecs(index *Index) (*SourceCodecs, error) <span class="cov3" title="4">{
        codecs := &amp;SourceCodecs{}

        for _, esReader := range index.ESReaders </span><span class="cov3" title="4">{
                parser, ok := esReader.(*MPEGPSParser)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Video: DVD is MPEG-2 if video ranges exist
                <span class="cov3" title="4">if parser.TotalESSize(true) &gt; 0 </span><span class="cov3" title="4">{
                        if !containsCodec(codecs.VideoCodecs, CodecMPEG2Video) </span><span class="cov3" title="4">{
                                codecs.VideoCodecs = append(codecs.VideoCodecs, CodecMPEG2Video)
                        }</span>
                }

                // Audio from Private Stream 1 sub-streams
                <span class="cov3" title="4">for _, subStreamID := range parser.AudioSubStreams() </span><span class="cov3" title="4">{
                        var ct CodecType
                        switch </span>{
                        case subStreamID &gt;= 0x80 &amp;&amp; subStreamID &lt;= 0x87:<span class="cov2" title="2">
                                ct = CodecAC3Audio</span>
                        case subStreamID &gt;= 0x88 &amp;&amp; subStreamID &lt;= 0x8F:<span class="cov2" title="2">
                                ct = CodecDTSAudio</span>
                        case subStreamID &gt;= 0xA0 &amp;&amp; subStreamID &lt;= 0xA7:<span class="cov0" title="0">
                                ct = CodecLPCMAudio</span>
                        default:<span class="cov0" title="0">
                                continue</span>
                        }
                        <span class="cov3" title="4">if !containsCodec(codecs.AudioCodecs, ct) </span><span class="cov3" title="4">{
                                codecs.AudioCodecs = append(codecs.AudioCodecs, ct)
                        }</span>
                }

                // MPEG audio streams (stream IDs 0xC0-0xDF)
                <span class="cov3" title="4">for _, pkt := range parser.Packets() </span><span class="cov2" title="2">{
                        if pkt.StreamID &gt;= 0xC0 &amp;&amp; pkt.StreamID &lt;= 0xDF </span><span class="cov2" title="2">{
                                if !containsCodec(codecs.AudioCodecs, CodecMPEGAudio) </span><span class="cov2" title="2">{
                                        codecs.AudioCodecs = append(codecs.AudioCodecs, CodecMPEGAudio)
                                }</span>
                                <span class="cov2" title="2">break</span> // Only need to find one
                        }
                }
        }

        <span class="cov3" title="4">return codecs, nil</span>
}

// detectBlurayCodecs performs a lightweight scan of the first M2TS file
// to detect codecs via the MPEG-TS Program Map Table (PMT).
func detectBlurayCodecs(index *Index) (*SourceCodecs, error) <span class="cov0" title="0">{
        if len(index.Files) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no source files in index")
        }</span>

        // Find the largest M2TS file (most likely the main feature)
        <span class="cov0" title="0">var largestFile string
        var largestSize int64
        for _, f := range index.Files </span><span class="cov0" title="0">{
                if f.Size &gt; largestSize </span><span class="cov0" title="0">{
                        largestSize = f.Size
                        largestFile = f.RelativePath
                }</span>
        }

        <span class="cov0" title="0">if largestFile == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid M2TS files found")
        }</span>

        <span class="cov0" title="0">fullPath := filepath.Join(index.SourceDir, largestFile)
        return detectBlurayCodecsFromFile(fullPath)</span>
}

// detectBlurayCodecsFromFile parses the PMT from an M2TS file to detect codecs.
func detectBlurayCodecsFromFile(path string) (*SourceCodecs, error) <span class="cov0" title="0">{
        f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open M2TS file: %w", err)
        }</span>
        <span class="cov0" title="0">defer f.Close()

        // Read first 2MB — enough to find PAT + PMT
        const scanSize = 2 * 1024 * 1024
        buf := make([]byte, scanSize)
        n, err := f.Read(buf)
        if err != nil &amp;&amp; n == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read M2TS file: %w", err)
        }</span>
        <span class="cov0" title="0">buf = buf[:n]

        // Need at least enough data for TS packet size detection (4 sync bytes at regular intervals)
        if len(buf) &lt; 192*4 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("M2TS file too small to detect TS structure (%d bytes)", len(buf))
        }</span>

        <span class="cov0" title="0">return parseTSCodecs(buf)</span>
}

// parseTSCodecs scans MPEG-TS data to find the PAT and PMT and extract stream types.
func parseTSCodecs(data []byte) (*SourceCodecs, error) <span class="cov3" title="4">{
        // Detect TS packet size: 188 (standard) or 192 (M2TS with 4-byte timestamp)
        packetSize, offset := detectTSPacketSize(data)
        if packetSize == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot detect TS packet size")
        }</span>

        // Step 1: Find PAT (PID 0x0000) to get PMT PID
        <span class="cov3" title="4">pmtPID := uint16(0)
        for i := offset; i+packetSize &lt;= len(data); i += packetSize </span><span class="cov3" title="4">{
                tsOffset := i
                if packetSize == 192 </span><span class="cov3" title="4">{
                        tsOffset += 4 // Skip 4-byte M2TS timestamp
                }</span>
                <span class="cov3" title="4">if tsOffset+188 &gt; len(data) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov3" title="4">pkt := data[tsOffset : tsOffset+188]
                if pkt[0] != 0x47 </span><span class="cov0" title="0">{
                        continue</span> // Not a valid TS sync byte
                }

                <span class="cov3" title="4">pid := uint16(pkt[1]&amp;0x1F)&lt;&lt;8 | uint16(pkt[2])
                if pid != 0x0000 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // PAT found — parse it
                <span class="cov3" title="4">payloadStart := pkt[1]&amp;0x40 != 0
                if !payloadStart </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip adaptation field if present
                <span class="cov3" title="4">adaptationFieldControl := (pkt[3] &gt;&gt; 4) &amp; 0x03
                headerLen := 4
                switch adaptationFieldControl </span>{
                case 0x02, 0x03:<span class="cov0" title="0"> // Adaptation field present
                        adaptLen := int(pkt[4])
                        if adaptLen &gt; 183 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">headerLen = 5 + adaptLen</span>
                case 0x01:<span class="cov3" title="4"></span> // Payload only, no adaptation field
                default:<span class="cov0" title="0"> // 0x00 is reserved/invalid
                        continue</span>
                }
                <span class="cov3" title="4">if headerLen &gt;= 188 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip pointer field
                <span class="cov3" title="4">pointerField := int(pkt[headerLen])
                headerLen += 1 + pointerField
                if headerLen+8 &gt; 188 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="4">payload := pkt[headerLen:]
                // PAT: table_id(1) + flags+length(2) + tsid(2) + version(1) + section(1) + last_section(1)
                // then 4 bytes per program: program_number(2) + PMT_PID(2)
                if len(payload) &lt; 12 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="4">if payload[0] != 0x00 </span><span class="cov0" title="0">{ // table_id for PAT
                        continue</span>
                }

                <span class="cov3" title="4">sectionLength := int(payload[1]&amp;0x0F)&lt;&lt;8 | int(payload[2])
                if sectionLength &lt; 9 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Programs start at offset 8, each is 4 bytes
                <span class="cov3" title="4">programsEnd := 8 + sectionLength - 4 // -4 for CRC
                if programsEnd &gt; len(payload) </span><span class="cov0" title="0">{
                        programsEnd = len(payload) - 4
                }</span>

                <span class="cov3" title="4">for j := 8; j+4 &lt;= programsEnd; j += 4 </span><span class="cov3" title="4">{
                        progNum := uint16(payload[j])&lt;&lt;8 | uint16(payload[j+1])
                        if progNum == 0 </span><span class="cov0" title="0">{
                                continue</span> // Network PID, skip
                        }
                        <span class="cov3" title="4">pmtPID = uint16(payload[j+2]&amp;0x1F)&lt;&lt;8 | uint16(payload[j+3])
                        break</span> // Use the first program
                }
                <span class="cov3" title="4">break</span>
        }

        <span class="cov3" title="4">if pmtPID == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PMT PID not found in PAT")
        }</span>

        // Step 2: Find PMT and extract stream types
        <span class="cov3" title="4">codecs := &amp;SourceCodecs{}
        for i := offset; i+packetSize &lt;= len(data); i += packetSize </span><span class="cov4" title="8">{
                tsOffset := i
                if packetSize == 192 </span><span class="cov4" title="8">{
                        tsOffset += 4
                }</span>
                <span class="cov4" title="8">if tsOffset+188 &gt; len(data) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov4" title="8">pkt := data[tsOffset : tsOffset+188]
                if pkt[0] != 0x47 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="8">pid := uint16(pkt[1]&amp;0x1F)&lt;&lt;8 | uint16(pkt[2])
                if pid != pmtPID </span><span class="cov3" title="4">{
                        continue</span>
                }

                <span class="cov3" title="4">payloadStart := pkt[1]&amp;0x40 != 0
                if !payloadStart </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip adaptation field
                <span class="cov3" title="4">adaptationFieldControl := (pkt[3] &gt;&gt; 4) &amp; 0x03
                headerLen := 4
                switch adaptationFieldControl </span>{
                case 0x02, 0x03:<span class="cov0" title="0"> // Adaptation field present
                        adaptLen := int(pkt[4])
                        if adaptLen &gt; 183 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">headerLen = 5 + adaptLen</span>
                case 0x01:<span class="cov3" title="4"></span> // Payload only, no adaptation field
                default:<span class="cov0" title="0"> // 0x00 is reserved/invalid
                        continue</span>
                }
                <span class="cov3" title="4">if headerLen &gt;= 188 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip pointer field
                <span class="cov3" title="4">pointerField := int(pkt[headerLen])
                headerLen += 1 + pointerField
                if headerLen+12 &gt; 188 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="4">payload := pkt[headerLen:]
                if len(payload) &lt; 12 || payload[0] != 0x02 </span><span class="cov0" title="0">{ // table_id for PMT
                        continue</span>
                }

                <span class="cov3" title="4">sectionLength := int(payload[1]&amp;0x0F)&lt;&lt;8 | int(payload[2])
                if sectionLength &lt; 13 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Program info length at offset 10
                <span class="cov3" title="4">progInfoLen := int(payload[10]&amp;0x0F)&lt;&lt;8 | int(payload[11])

                // Stream descriptors start after program info
                streamsStart := 12 + progInfoLen
                streamsEnd := 3 + sectionLength - 4 // section starts at byte 3, -4 for CRC
                if streamsEnd &gt; len(payload) </span><span class="cov0" title="0">{
                        streamsEnd = len(payload) - 4
                }</span>
                <span class="cov3" title="4">if streamsStart &gt; streamsEnd </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="4">for j := streamsStart; j+5 &lt;= streamsEnd; </span><span class="cov4" title="10">{
                        streamType := payload[j]
                        esInfoLen := int(payload[j+3]&amp;0x0F)&lt;&lt;8 | int(payload[j+4])

                        ct := tsStreamTypeToCodecType(streamType)
                        if ct != CodecUnknown </span><span class="cov4" title="10">{
                                if IsVideoCodec(ct) </span><span class="cov3" title="4">{
                                        if !containsCodec(codecs.VideoCodecs, ct) </span><span class="cov3" title="4">{
                                                codecs.VideoCodecs = append(codecs.VideoCodecs, ct)
                                        }</span>
                                } else<span class="cov3" title="6"> if IsAudioCodec(ct) </span><span class="cov3" title="6">{
                                        if !containsCodec(codecs.AudioCodecs, ct) </span><span class="cov3" title="6">{
                                                codecs.AudioCodecs = append(codecs.AudioCodecs, ct)
                                        }</span>
                                }
                        }

                        <span class="cov4" title="10">next := j + 5 + esInfoLen
                        if next &lt; j || next &gt; streamsEnd </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov4" title="10">j = next</span>
                }

                <span class="cov3" title="4">break</span> // Found and parsed PMT
        }

        <span class="cov3" title="4">return codecs, nil</span>
}

// tsStreamTypeToCodecType maps MPEG-TS stream type values to CodecType.
func tsStreamTypeToCodecType(streamType byte) CodecType <span class="cov6" title="42">{
        switch streamType </span>{
        case 0x01:<span class="cov2" title="2">
                return CodecMPEG1Video</span>
        case 0x02:<span class="cov3" title="4">
                return CodecMPEG2Video</span>
        case 0x1B:<span class="cov3" title="4">
                return CodecH264Video</span>
        case 0x24:<span class="cov2" title="2">
                return CodecH265Video</span>
        case 0xEA:<span class="cov2" title="2">
                return CodecVC1Video</span>
        case 0x03, 0x04:<span class="cov3" title="4">
                return CodecMPEGAudio</span>
        case 0x0F:<span class="cov2" title="2">
                return CodecAACaudio</span>
        case 0x80:<span class="cov2" title="2">
                return CodecLPCMAudio</span>
        case 0x81:<span class="cov3" title="4">
                return CodecAC3Audio</span>
        case 0x82:<span class="cov2" title="2">
                return CodecDTSAudio</span>
        case 0x83:<span class="cov3" title="4">
                return CodecTrueHDAudio</span>
        case 0x84:<span class="cov2" title="2">
                return CodecEAC3Audio</span>
        case 0x85, 0x86:<span class="cov3" title="6">
                return CodecDTSHDAudio</span>
        default:<span class="cov2" title="2">
                return CodecUnknown</span>
        }
}

// detectTSPacketSize determines TS packet size (188 or 192) and the offset to
// the first sync byte. Returns (0, 0) if no valid TS structure is found.
func detectTSPacketSize(data []byte) (int, int) <span class="cov4" title="8">{
        // Try both M2TS (192-byte packets) and standard TS (188-byte packets)
        for _, size := range []int{192, 188} </span><span class="cov4" title="10">{
                for startOffset := 0; startOffset &lt; size &amp;&amp; startOffset+size*3 &lt; len(data); startOffset++ </span><span class="cov10" title="392">{
                        syncOffset := startOffset
                        if size == 192 </span><span class="cov9" title="390">{
                                syncOffset += 4 // M2TS timestamp prefix
                        }</span>
                        <span class="cov10" title="392">if syncOffset &gt;= len(data) || data[syncOffset] != 0x47 </span><span class="cov9" title="382">{
                                continue</span>
                        }
                        // Verify 3 consecutive sync bytes
                        <span class="cov4" title="10">valid := true
                        for k := 1; k &lt;= 3; k++ </span><span class="cov5" title="26">{
                                nextSync := startOffset + k*size
                                if size == 192 </span><span class="cov5" title="20">{
                                        nextSync += 4
                                }</span>
                                <span class="cov5" title="26">if nextSync &gt;= len(data) || data[nextSync] != 0x47 </span><span class="cov2" title="2">{
                                        valid = false
                                        break</span>
                                }
                        }
                        <span class="cov4" title="10">if valid </span><span class="cov4" title="8">{
                                return size, startOffset
                        }</span>
                }
        }
        <span class="cov0" title="0">return 0, 0</span>
}

// CheckCodecCompatibility compares MKV track codecs against source codecs.
// Returns nil if all codecs are compatible, or a list of mismatches.
func CheckCodecCompatibility(tracks []mkv.Track, sourceCodecs *SourceCodecs) []CodecMismatch <span class="cov5" title="20">{
        var mismatches []CodecMismatch

        for _, track := range tracks </span><span class="cov6" title="32">{
                ct := MKVCodecToType(track.CodecID)
                if ct == CodecUnknown </span><span class="cov3" title="6">{
                        continue</span> // Skip unknown codecs — no false alarms
                }

                <span class="cov5" title="26">if track.Type == mkv.TrackTypeVideo &amp;&amp; IsVideoCodec(ct) </span><span class="cov4" title="10">{
                        if len(sourceCodecs.VideoCodecs) == 0 </span><span class="cov2" title="2">{
                                continue</span> // No source video info available
                        }
                        <span class="cov4" title="8">if !codecFamilyMatch(ct, sourceCodecs.VideoCodecs) </span><span class="cov2" title="2">{
                                mismatches = append(mismatches, CodecMismatch{
                                        TrackType:    "video",
                                        MKVCodecID:   track.CodecID,
                                        MKVCodecType: ct,
                                        SourceCodecs: sourceCodecs.VideoCodecs,
                                })
                        }</span>
                } else<span class="cov5" title="16"> if track.Type == mkv.TrackTypeAudio &amp;&amp; IsAudioCodec(ct) </span><span class="cov5" title="16">{
                        if len(sourceCodecs.AudioCodecs) == 0 </span><span class="cov2" title="2">{
                                continue</span> // No source audio info available
                        }
                        <span class="cov4" title="14">if !codecFamilyMatch(ct, sourceCodecs.AudioCodecs) </span><span class="cov3" title="4">{
                                mismatches = append(mismatches, CodecMismatch{
                                        TrackType:    "audio",
                                        MKVCodecID:   track.CodecID,
                                        MKVCodecType: ct,
                                        SourceCodecs: sourceCodecs.AudioCodecs,
                                })
                        }</span>
                }
        }

        <span class="cov5" title="20">return mismatches</span>
}

// codecFamilyMatch checks if a codec type is compatible with any codec in the list.
// Uses family-based matching (e.g., DTS is compatible with DTS-HD).
func codecFamilyMatch(ct CodecType, sourceCodecs []CodecType) bool <span class="cov5" title="22">{
        family := codecFamily(ct)
        for _, sc := range sourceCodecs </span><span class="cov5" title="24">{
                if codecFamily(sc) == family </span><span class="cov5" title="16">{
                        return true
                }</span>
        }
        <span class="cov3" title="6">return false</span>
}

// codecFamily returns the codec family for family-based matching.
// Related codecs map to the same family value.
func codecFamily(ct CodecType) int <span class="cov6" title="46">{
        switch ct </span>{
        case CodecMPEG1Video, CodecMPEG2Video:<span class="cov4" title="14">
                return 1</span>
        case CodecH264Video:<span class="cov2" title="2">
                return 2</span>
        case CodecH265Video:<span class="cov0" title="0">
                return 3</span>
        case CodecVC1Video:<span class="cov0" title="0">
                return 4</span>
        case CodecAC3Audio, CodecEAC3Audio:<span class="cov5" title="20">
                return 10</span>
        case CodecDTSAudio, CodecDTSHDAudio:<span class="cov3" title="6">
                return 11</span>
        case CodecTrueHDAudio:<span class="cov0" title="0">
                return 12</span>
        case CodecLPCMAudio:<span class="cov0" title="0">
                return 13</span>
        case CodecMPEGAudio:<span class="cov0" title="0">
                return 14</span>
        case CodecAACaudio:<span class="cov0" title="0">
                return 15</span>
        case CodecFLACAudio:<span class="cov3" title="4">
                return 16</span>
        case CodecOpusAudio:<span class="cov0" title="0">
                return 17</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// containsCodec checks if a codec type is already in the list.
func containsCodec(codecs []CodecType, ct CodecType) bool <span class="cov5" title="20">{
        for _, c := range codecs </span><span class="cov3" title="4">{
                if c == ct </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov5" title="20">return false</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package source

import (
        "fmt"
        "path/filepath"
        "runtime"

        "github.com/cespare/xxhash/v2"
        "github.com/stuckj/mkvdup/internal/mmap"
)

const (
        // DefaultWindowSize is the default number of bytes to hash at each sync point
        DefaultWindowSize = 64

        // MinWindowSize is the minimum allowed window size
        MinWindowSize = 32

        // MaxWindowSize is the maximum allowed window size
        MaxWindowSize = 4096
)

// Indexer builds a hash index from source media files.
type Indexer struct {
        sourceDir      string
        sourceType     Type
        windowSize     int
        index          *Index
        useRawIndexing bool // Force raw file indexing even for DVDs
}

// NewIndexer creates a new Indexer for the given source directory.
func NewIndexer(sourceDir string, windowSize int) (*Indexer, error) <span class="cov2" title="14">{
        return NewIndexerWithOptions(sourceDir, windowSize, false)
}</span>

// NewIndexerWithOptions creates a new Indexer with additional options.
// useRawIndexing forces raw file indexing even for DVDs (useful for finding
// content from any title/stream in the ISO).
func NewIndexerWithOptions(sourceDir string, windowSize int, useRawIndexing bool) (*Indexer, error) <span class="cov2" title="18">{
        sourceType, err := DetectType(sourceDir)
        if err != nil </span><span class="cov1" title="4">{
                return nil, fmt.Errorf("detect source type: %w", err)
        }</span>

        <span class="cov2" title="14">if windowSize &lt; MinWindowSize </span><span class="cov1" title="2">{
                windowSize = MinWindowSize
        }</span>
        <span class="cov2" title="14">if windowSize &gt; MaxWindowSize </span><span class="cov1" title="2">{
                windowSize = MaxWindowSize
        }</span>

        <span class="cov2" title="14">return &amp;Indexer{
                sourceDir:      sourceDir,
                sourceType:     sourceType,
                windowSize:     windowSize,
                index:          NewIndex(sourceDir, sourceType, windowSize),
                useRawIndexing: useRawIndexing,
        }, nil</span>
}

// SourceType returns the detected source type.
func (idx *Indexer) SourceType() Type <span class="cov1" title="9">{
        return idx.sourceType
}</span>

// SourceDir returns the source directory path.
func (idx *Indexer) SourceDir() string <span class="cov1" title="2">{
        return idx.sourceDir
}</span>

// ProgressFunc is called during indexing to report progress.
// processed is the number of bytes processed so far, total is the total bytes to process.
type ProgressFunc func(processed, total int64)

// Build scans all media files and builds the hash index.
// If progress is non-nil, it will be called periodically to report progress.
func (idx *Indexer) Build(progress ProgressFunc) error <span class="cov1" title="6">{
        files, err := EnumerateMediaFiles(idx.sourceDir, idx.sourceType)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("enumerate media files: %w", err)
        }</span>

        <span class="cov1" title="6">if len(files) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no media files found in %s", idx.sourceDir)
        }</span>

        // Calculate total size for progress reporting
        <span class="cov1" title="6">var totalSize int64
        for _, relPath := range files </span><span class="cov1" title="6">{
                fullPath := filepath.Join(idx.sourceDir, relPath)
                size, err := GetFileInfo(fullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("get file info for %s: %w", relPath, err)
                }</span>
                <span class="cov1" title="6">totalSize += size</span>
        }

        // Pre-allocate hash map to reduce reallocation
        // Estimate: ~1 sync point per 2KB of data on average
        <span class="cov1" title="6">estimatedSyncPoints := int(totalSize / 2048)
        if estimatedSyncPoints &lt; 10000 </span><span class="cov0" title="0">{
                estimatedSyncPoints = 10000
        }</span>
        <span class="cov1" title="6">idx.index.HashToLocations = make(map[uint64][]Location, estimatedSyncPoints)

        // For DVDs (MPEG-PS), we can use ES-based indexing or raw indexing
        // Raw indexing is more reliable as it finds content from any title/stream
        if idx.sourceType == TypeDVD &amp;&amp; !idx.useRawIndexing </span><span class="cov1" title="5">{
                idx.index.UsesESOffsets = true
        }</span>

        <span class="cov1" title="6">var processedSize int64

        // Process each file
        for fileIndex, relPath := range files </span><span class="cov1" title="6">{
                fullPath := filepath.Join(idx.sourceDir, relPath)

                size, err := GetFileInfo(fullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("get file info for %s: %w", relPath, err)
                }</span>

                <span class="cov1" title="6">var checksum uint64
                if idx.sourceType == TypeDVD &amp;&amp; !idx.useRawIndexing </span><span class="cov1" title="5">{
                        checksum, err = idx.indexMPEGPSFile(uint16(fileIndex), fullPath, size, func(fileProcessed int64) </span><span class="cov4" title="6870">{
                                if progress != nil </span><span class="cov0" title="0">{
                                        progress(processedSize+fileProcessed, totalSize)
                                }</span>
                        })
                } else<span class="cov1" title="1"> {
                        checksum, err = idx.indexRawFile(uint16(fileIndex), fullPath, size, func(fileProcessed int64) </span><span class="cov3" title="876">{
                                if progress != nil </span><span class="cov0" title="0">{
                                        progress(processedSize+fileProcessed, totalSize)
                                }</span>
                        })
                }
                <span class="cov1" title="6">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("index file %s: %w", relPath, err)
                }</span>

                <span class="cov1" title="6">idx.index.Files = append(idx.index.Files, File{
                        RelativePath: relPath,
                        Size:         size,
                        Checksum:     checksum,
                })

                processedSize += size</span>
        }

        <span class="cov1" title="6">return nil</span>
}

// indexMPEGPSFile processes an MPEG-PS file (DVD ISO) using ES-aware indexing.
// It extracts the elementary stream data and indexes sync points within it.
func (idx *Indexer) indexMPEGPSFile(fileIndex uint16, path string, size int64, progress func(int64)) (uint64, error) <span class="cov1" title="5">{
        // Memory-map the file with zero-copy access
        mmapFile, err := mmap.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("mmap open: %w", err)
        }</span>
        // Note: Don't close mmapFile - it's stored in MmapFiles for later use

        // Store the mmap file for cleanup
        <span class="cov1" title="5">idx.index.MmapFiles = append(idx.index.MmapFiles, mmapFile)

        // Parse MPEG-PS structure with progress reporting using zero-copy data
        parser := NewMPEGPSParser(mmapFile.Data())

        if err := parser.ParseWithProgress(func(processed, total int64) </span><span class="cov3" title="370">{
                if progress != nil </span><span class="cov3" title="370">{
                        // Report parsing progress (first 50% of the indexing)
                        progress(processed / 2)
                }</span>
        }); err != nil <span class="cov0" title="0">{
                return 0, fmt.Errorf("parse MPEG-PS: %w", err)
        }</span>

        // Store parser for later use by matcher
        <span class="cov1" title="5">idx.index.ESReaders = append(idx.index.ESReaders, parser)

        // Calculate file checksum using zero-copy data (no allocation needed)
        checksum := xxhash.Sum64(mmapFile.Data())

        // Index video ES
        videoESSize := parser.TotalESSize(true)
        if videoESSize &gt; 0 </span><span class="cov1" title="5">{
                if err := idx.indexESData(fileIndex, parser, true, videoESSize, progress); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("index video ES: %w", err)
                }</span>
        }

        // Index each audio sub-stream separately
        <span class="cov1" title="5">audioSubStreams := parser.AudioSubStreams()
        for _, subStreamID := range audioSubStreams </span><span class="cov3" title="120">{
                subStreamSize := parser.AudioSubStreamESSize(subStreamID)
                if subStreamSize &gt; 0 </span><span class="cov3" title="120">{
                        if err := idx.indexAudioSubStream(fileIndex, parser, subStreamID, subStreamSize); err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("index audio sub-stream 0x%02X: %w", subStreamID, err)
                        }</span>
                }
        }

        <span class="cov1" title="5">if progress != nil </span><span class="cov1" title="5">{
                progress(size)
        }</span>

        <span class="cov1" title="5">return checksum, nil</span>
}

// indexESData indexes the elementary stream data from an MPEG-PS parser.
// Uses zero-copy iteration through PES payload ranges.
func (idx *Indexer) indexESData(fileIndex uint16, parser *MPEGPSParser, isVideo bool, esSize int64, progress func(int64)) error <span class="cov1" title="5">{
        ranges := parser.FilteredVideoRanges()
        if len(ranges) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="5">data := parser.Data() // Get mmap'd data for direct access
        syncPointCount := 0

        // Iterate through each PES payload range (zero-copy)
        for rangeIdx, r := range ranges </span><span class="cov7" title="6491750">{
                // Direct slice access into mmap'd data - no copy!
                endOffset := r.FileOffset + int64(r.Size)
                if endOffset &gt; int64(len(data)) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="6491750">rangeData := data[r.FileOffset:endOffset]

                // Find sync points in this range
                syncPoints := FindVideoStartCodes(rangeData)

                // Add each sync point to the index
                for _, offsetInRange := range syncPoints </span><span class="cov8" title="19345215">{
                        syncESOffset := r.ESOffset + int64(offsetInRange)

                        // Ensure we have enough data for the window
                        if syncESOffset+int64(idx.windowSize) &gt; esSize </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check if window fits within this range (zero-copy fast path)
                        <span class="cov8" title="19345215">if offsetInRange+idx.windowSize &lt;= len(rangeData) </span><span class="cov8" title="18760700">{
                                window := rangeData[offsetInRange : offsetInRange+idx.windowSize]
                                hash := xxhash.Sum64(window)

                                idx.index.HashToLocations[hash] = append(idx.index.HashToLocations[hash], Location{
                                        FileIndex: fileIndex,
                                        Offset:    syncESOffset,
                                        IsVideo:   isVideo,
                                })
                                syncPointCount++
                        }</span> else<span class="cov6" title="584515"> {
                                // Window spans range boundary - use ReadESData (may copy)
                                window, err := parser.ReadESData(syncESOffset, idx.windowSize, isVideo)
                                if err != nil || len(window) &lt; idx.windowSize </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov6" title="584515">hash := xxhash.Sum64(window)

                                idx.index.HashToLocations[hash] = append(idx.index.HashToLocations[hash], Location{
                                        FileIndex: fileIndex,
                                        Offset:    syncESOffset,
                                        IsVideo:   isVideo,
                                })
                                syncPointCount++</span>
                        }
                }

                // Report progress periodically and force GC to prevent memory buildup
                <span class="cov7" title="6491750">if rangeIdx%1000 == 0 </span><span class="cov4" title="6495">{
                        if progress != nil </span><span class="cov4" title="6495">{
                                progress(r.FileOffset)
                        }</span>
                        // Force GC periodically to clean up temporary allocations
                        <span class="cov4" title="6495">if rangeIdx%10000 == 0 </span><span class="cov3" title="650">{
                                runtime.GC()
                        }</span>
                }
        }

        <span class="cov1" title="5">return nil</span>
}

// indexAudioSubStream indexes a specific audio sub-stream.
// Uses zero-copy iteration through PES payload ranges.
func (idx *Indexer) indexAudioSubStream(fileIndex uint16, parser *MPEGPSParser, subStreamID byte, esSize int64) error <span class="cov3" title="120">{
        ranges := parser.FilteredAudioRanges(subStreamID)
        if len(ranges) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="120">data := parser.Data() // Get mmap'd data for direct access

        // Iterate through each PES payload range (zero-copy)
        for _, r := range ranges </span><span class="cov6" title="445125">{
                // Direct slice access into mmap'd data - no copy!
                endOffset := r.FileOffset + int64(r.Size)
                if endOffset &gt; int64(len(data)) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="445125">rangeData := data[r.FileOffset:endOffset]

                // Find audio sync points in this range
                syncPoints := FindAudioSyncPoints(rangeData)

                // Add each sync point to the index
                for _, offsetInRange := range syncPoints </span><span class="cov6" title="1557785">{
                        syncESOffset := r.ESOffset + int64(offsetInRange)

                        // Ensure we have enough data for the window
                        if syncESOffset+int64(idx.windowSize) &gt; esSize </span><span class="cov2" title="90">{
                                continue</span>
                        }

                        // Check if window fits within this range (zero-copy fast path)
                        <span class="cov6" title="1557695">if offsetInRange+idx.windowSize &lt;= len(rangeData) </span><span class="cov6" title="1548920">{
                                window := rangeData[offsetInRange : offsetInRange+idx.windowSize]
                                hash := xxhash.Sum64(window)

                                idx.index.HashToLocations[hash] = append(idx.index.HashToLocations[hash], Location{
                                        FileIndex:        fileIndex,
                                        Offset:           syncESOffset,
                                        IsVideo:          false,
                                        AudioSubStreamID: subStreamID,
                                })
                        }</span> else<span class="cov4" title="8775"> {
                                // Window spans range boundary - use ReadAudioSubStreamData (may copy)
                                window, err := parser.ReadAudioSubStreamData(subStreamID, syncESOffset, idx.windowSize)
                                if err != nil || len(window) &lt; idx.windowSize </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov4" title="8775">hash := xxhash.Sum64(window)

                                idx.index.HashToLocations[hash] = append(idx.index.HashToLocations[hash], Location{
                                        FileIndex:        fileIndex,
                                        Offset:           syncESOffset,
                                        IsVideo:          false,
                                        AudioSubStreamID: subStreamID,
                                })</span>
                        }
                }
        }

        <span class="cov3" title="120">return nil</span>
}

// mmapRawReader wraps mmap.File to implement RawReader interface.
type mmapRawReader struct {
        mmapFile *mmap.File
}

func (r *mmapRawReader) ReadAt(buf []byte, offset int64) (int, error) <span class="cov0" title="0">{
        data := r.mmapFile.Slice(offset, len(buf))
        if data == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("offset out of range")
        }</span>
        <span class="cov0" title="0">copy(buf, data)
        return len(data), nil</span>
}

// Slice returns a zero-copy slice of the underlying mmap'd data.
func (r *mmapRawReader) Slice(offset int64, size int) []byte <span class="cov9" title="340445158">{
        return r.mmapFile.Slice(offset, size)
}</span>

func (r *mmapRawReader) Len() int <span class="cov0" title="0">{
        return r.mmapFile.Len()
}</span>

func (r *mmapRawReader) Close() error <span class="cov1" title="1">{
        return r.mmapFile.Close()
}</span>

// indexRawFile processes a raw file (for Blu-ray M2TS or other formats).
// This is the original indexing approach.
func (idx *Indexer) indexRawFile(fileIndex uint16, path string, size int64, progress func(int64)) (uint64, error) <span class="cov1" title="1">{
        // Memory-map the file with zero-copy access
        mmapFile, err := mmap.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("mmap open: %w", err)
        }</span>
        // Don't close the mmapFile - keep it for later use by matcher
        <span class="cov1" title="1">idx.index.RawReaders = append(idx.index.RawReaders, &amp;mmapRawReader{mmapFile: mmapFile})

        // Zero-copy access to file data
        data := mmapFile.Data()

        // Calculate file checksum (zero-copy - no allocation)
        checksum := xxhash.Sum64(data)

        // Find all sync points
        syncPoints := FindAllSyncPoints(data)

        // Add each sync point to the index
        for i, offset := range syncPoints </span><span class="cov7" title="8744364">{
                // Ensure we have enough data for the window
                if int64(offset)+int64(idx.windowSize) &gt; size </span><span class="cov2" title="62">{
                        continue</span>
                }

                // Hash the window at this offset (zero-copy slice)
                <span class="cov7" title="8744302">window := data[offset : offset+idx.windowSize]
                hash := xxhash.Sum64(window)

                // Add to index
                idx.index.HashToLocations[hash] = append(idx.index.HashToLocations[hash], Location{
                        FileIndex: fileIndex,
                        Offset:    int64(offset),
                })

                // Report progress periodically (every 10000 sync points)
                if progress != nil &amp;&amp; i%10000 == 0 </span><span class="cov3" title="875">{
                        progress(int64(offset))
                }</span>
        }

        <span class="cov1" title="1">if progress != nil </span><span class="cov1" title="1">{
                progress(size)
        }</span>

        <span class="cov1" title="1">return checksum, nil</span>
}

// Index returns the built index. Must call Build first.
func (idx *Indexer) Index() *Index <span class="cov1" title="8">{
        return idx.index
}</span>

// Lookup finds locations in the source that match the given hash.
func (idx *Index) Lookup(hash uint64) []Location <span class="cov6" title="456672">{
        return idx.HashToLocations[hash]
}</span>

// ReadESDataAt reads ES data at the given location.
// For sources that use ES offsets, this handles the translation.
// For audio locations, uses the sub-stream ID from the location.
func (idx *Index) ReadESDataAt(loc Location, size int) ([]byte, error) <span class="cov8" title="54311267">{
        if int(loc.FileIndex) &gt;= len(idx.ESReaders) || idx.ESReaders[loc.FileIndex] == nil </span><span class="cov1" title="2">{
                // No ES reader - this shouldn't happen for ES-based indexes
                return nil, fmt.Errorf("no ES reader for file %d", loc.FileIndex)
        }</span>
        <span class="cov8" title="54311265">if loc.IsVideo </span><span class="cov8" title="53233450">{
                return idx.ESReaders[loc.FileIndex].ReadESData(loc.Offset, size, true)
        }</span>
        // For audio, use the sub-stream specific reader
        <span class="cov6" title="1077815">return idx.ESReaders[loc.FileIndex].ReadAudioSubStreamData(loc.AudioSubStreamID, loc.Offset, size)</span>
}

// ReadESByteWithHint reads a single byte from the ES stream, using a range hint
// to avoid binary search when reading sequentially. Returns the byte, the new range
// hint for the next call, and success status. Pass rangeHint=-1 to force binary search.
// This is optimized for the expandMatch hot path where we read bytes sequentially.
func (idx *Index) ReadESByteWithHint(loc Location, rangeHint int) (byte, int, bool) <span class="cov10" title="2197428479">{
        if int(loc.FileIndex) &gt;= len(idx.ESReaders) || idx.ESReaders[loc.FileIndex] == nil </span><span class="cov0" title="0">{
                return 0, -1, false
        }</span>

        // Type-assert to MPEGPSParser to access hint-based methods
        <span class="cov10" title="2197428479">parser, ok := idx.ESReaders[loc.FileIndex].(*MPEGPSParser)
        if !ok </span><span class="cov0" title="0">{
                // Fallback: use ReadESData (allocates, but works for any ESReader)
                var data []byte
                var err error
                if loc.IsVideo </span><span class="cov0" title="0">{
                        data, err = idx.ESReaders[loc.FileIndex].ReadESData(loc.Offset, 1, true)
                }</span> else<span class="cov0" title="0"> {
                        data, err = idx.ESReaders[loc.FileIndex].ReadAudioSubStreamData(loc.AudioSubStreamID, loc.Offset, 1)
                }</span>
                <span class="cov0" title="0">if err != nil || len(data) == 0 </span><span class="cov0" title="0">{
                        return 0, -1, false
                }</span>
                <span class="cov0" title="0">return data[0], -1, true</span>
        }

        // Use hint-based reading for MPEGPSParser
        <span class="cov10" title="2197428479">if loc.IsVideo </span><span class="cov9" title="1839843344">{
                return parser.ReadESByteWithHint(loc.Offset, true, rangeHint)
        }</span>
        <span class="cov9" title="357585135">return parser.ReadAudioByteWithHint(loc.AudioSubStreamID, loc.Offset, rangeHint)</span>
}

// ComputeHash calculates the xxhash of the given data.
func ComputeHash(data []byte) uint64 <span class="cov2" title="12">{
        return xxhash.Sum64(data)
}</span>

// Close releases resources held by the index.
func (idx *Index) Close() error <span class="cov2" title="12">{
        // Close all mmap files (these back the ESReaders and RawReaders)
        for _, mmapFile := range idx.MmapFiles </span><span class="cov1" title="5">{
                if mmapFile != nil </span><span class="cov1" title="5">{
                        mmapFile.Close()
                }</span>
        }
        // Close all raw readers (which also close their mmap files)
        <span class="cov2" title="12">for _, reader := range idx.RawReaders </span><span class="cov1" title="1">{
                if reader != nil </span><span class="cov1" title="1">{
                        reader.Close()
                }</span>
        }
        <span class="cov2" title="12">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package source

import (
        "bytes"
        "encoding/binary"
        "fmt"
)

// MPEG-PS start codes
const (
        PackStartCode      = 0x000001BA
        SystemHeaderCode   = 0x000001BB
        ProgramEndCode     = 0x000001B9
        PrivateStream1Code = 0x000001BD
        PrivateStream2Code = 0x000001BF
        PaddingStreamCode  = 0x000001BE
        VideoStreamMinCode = 0x000001E0
        VideoStreamMaxCode = 0x000001EF
        AudioStreamMinCode = 0x000001C0
        AudioStreamMaxCode = 0x000001DF
)

// PESPacket represents a parsed PES packet from an MPEG-PS stream.
type PESPacket struct {
        StreamID      byte  // Stream identifier (E0-EF = video, C0-DF = audio, BD = private)
        SubStreamID   byte  // Sub-stream ID for Private Stream 1 (0x80-0x87 = AC3, 0x88-0x8F = DTS)
        Offset        int64 // Offset of the PES packet start in the file
        HeaderSize    int   // Total header size (start code + length + PES header + private header)
        PayloadOffset int64 // Offset of the actual audio/video payload
        PayloadSize   int   // Size of the payload
        IsVideo       bool  // True if this is a video stream
        IsAudio       bool  // True if this is an audio stream
}

// PESPayloadRange represents a contiguous range of elementary stream payload data.
type PESPayloadRange struct {
        FileOffset int64 // Offset in the MPEG-PS file
        Size       int   // Size of this payload chunk
        ESOffset   int64 // Logical offset in the elementary stream
}

// MPEGPSParser parses MPEG Program Stream files to extract PES packet information.
type MPEGPSParser struct {
        data        []byte // Direct mmap'd data - zero-copy access
        size        int64
        packets     []PESPacket
        videoRanges []PESPayloadRange
        audioRanges []PESPayloadRange
        // Filtered ranges exclude user_data sections for MKV-compatible matching
        filteredVideoRanges []PESPayloadRange
        // Filtered audio ranges per sub-stream ID - separates interleaved audio tracks
        // Each sub-stream (0x80, 0x81, etc.) gets its own filtered range set
        filteredAudioBySubStream map[byte][]PESPayloadRange
        // audioSubStreams lists the sub-stream IDs in order of appearance
        audioSubStreams []byte
        filterUserData  bool
}

// NewMPEGPSParser creates a parser for the given memory-mapped data.
// The data slice should be from a zero-copy mmap (unix.Mmap).
func NewMPEGPSParser(data []byte) *MPEGPSParser <span class="cov1" title="5">{
        return &amp;MPEGPSParser{
                data: data,
                size: int64(len(data)),
        }
}</span>

// MPEGPSProgressFunc is called to report MPEG-PS parsing progress.
type MPEGPSProgressFunc func(processed, total int64)

// Parse scans the file and extracts all PES packet information.
func (p *MPEGPSParser) Parse() error <span class="cov0" title="0">{
        return p.ParseWithProgress(nil)
}</span>

// ParseWithProgress scans the file with progress reporting.
func (p *MPEGPSParser) ParseWithProgress(progress MPEGPSProgressFunc) error <span class="cov1" title="5">{
        pos := int64(0)
        var videoESOffset, audioESOffset int64
        lastProgress := int64(0)

        // Pre-allocate slices to reduce reallocation churn
        // Estimate: average PES packet ~2KB, so ~size/2048 packets
        // We split roughly 60% video, 40% audio
        estimatedPackets := int(p.size / 2048)
        if estimatedPackets &lt; 1000 </span><span class="cov0" title="0">{
                estimatedPackets = 1000
        }</span>
        <span class="cov1" title="5">p.packets = make([]PESPacket, 0, estimatedPackets)
        p.videoRanges = make([]PESPayloadRange, 0, estimatedPackets*6/10)
        p.audioRanges = make([]PESPayloadRange, 0, estimatedPackets*4/10)

        for pos &lt; p.size-4 </span><span class="cov4" title="9610">{
                // Direct slice access - zero copy
                end := pos + 4*1024*1024 // Process in ~4MB logical chunks for progress
                if end &gt; p.size </span><span class="cov1" title="5">{
                        end = p.size
                }</span>
                <span class="cov4" title="9610">chunkData := p.data[pos:end]
                if len(chunkData) &lt; 4 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Scan for start codes within this chunk
                <span class="cov4" title="9610">i := 0
                for i &lt; len(chunkData)-4 </span><span class="cov10" title="3185604265">{
                        // Fast scan for 00 00 01 prefix
                        if chunkData[i] != 0 </span><span class="cov9" title="2930651340">{
                                i++
                                continue</span>
                        }
                        <span class="cov8" title="254952925">if chunkData[i+1] != 0 </span><span class="cov8" title="126334820">{
                                i += 2
                                continue</span>
                        }
                        <span class="cov8" title="128618105">if chunkData[i+2] != 1 </span><span class="cov8" title="113878095">{
                                i++
                                continue</span>
                        }

                        // Found potential start code at pos + i
                        <span class="cov7" title="14740010">startCodePos := pos + int64(i)
                        startCode := uint32(0x00000100) | uint32(chunkData[i+3])

                        advance := int64(1)

                        switch </span>{
                        case startCode == PackStartCode:<span class="cov7" title="6964665">
                                packSize, err := p.parsePackHeader(startCodePos)
                                if err == nil </span><span class="cov7" title="6964665">{
                                        advance = int64(packSize)
                                }</span>

                        case startCode == SystemHeaderCode:<span class="cov5" title="43030">
                                headerLen, err := p.parseSystemHeader(startCodePos)
                                if err == nil </span><span class="cov5" title="43030">{
                                        advance = int64(headerLen)
                                }</span>

                        case startCode == ProgramEndCode:<span class="cov3" title="790">
                                // End of program stream - but DVDs can have multiple programs
                                // (menu, main feature, extras, etc.), so continue parsing
                                advance = 4</span>

                        case startCode == PaddingStreamCode:<span class="cov5" title="43225">
                                length, err := p.readPESLength(startCodePos + 4)
                                if err == nil </span><span class="cov5" title="43225">{
                                        advance = 6 + int64(length)
                                }</span>

                        case startCode == PrivateStream1Code:<span class="cov6" title="444495">
                                pkt, err := p.parsePESPacket(startCodePos, byte(startCode&amp;0xFF))
                                if err == nil </span><span class="cov6" title="444495">{
                                        pkt.IsAudio = true
                                        p.packets = append(p.packets, pkt)
                                        p.audioRanges = append(p.audioRanges, PESPayloadRange{
                                                FileOffset: pkt.PayloadOffset,
                                                Size:       pkt.PayloadSize,
                                                ESOffset:   audioESOffset,
                                        })
                                        audioESOffset += int64(pkt.PayloadSize)
                                        advance = int64(pkt.HeaderSize + pkt.PayloadSize)
                                }</span>

                        case startCode &gt;= VideoStreamMinCode &amp;&amp; startCode &lt;= VideoStreamMaxCode:<span class="cov7" title="6494530">
                                pkt, err := p.parsePESPacket(startCodePos, byte(startCode&amp;0xFF))
                                if err == nil </span><span class="cov7" title="6494530">{
                                        pkt.IsVideo = true
                                        p.packets = append(p.packets, pkt)
                                        p.videoRanges = append(p.videoRanges, PESPayloadRange{
                                                FileOffset: pkt.PayloadOffset,
                                                Size:       pkt.PayloadSize,
                                                ESOffset:   videoESOffset,
                                        })
                                        videoESOffset += int64(pkt.PayloadSize)
                                        advance = int64(pkt.HeaderSize + pkt.PayloadSize)
                                }</span>

                        case startCode &gt;= AudioStreamMinCode &amp;&amp; startCode &lt;= AudioStreamMaxCode:<span class="cov5" title="39080">
                                pkt, err := p.parsePESPacket(startCodePos, byte(startCode&amp;0xFF))
                                if err == nil </span><span class="cov5" title="39080">{
                                        pkt.IsAudio = true
                                        p.packets = append(p.packets, pkt)
                                        p.audioRanges = append(p.audioRanges, PESPayloadRange{
                                                FileOffset: pkt.PayloadOffset,
                                                Size:       pkt.PayloadSize,
                                                ESOffset:   audioESOffset,
                                        })
                                        audioESOffset += int64(pkt.PayloadSize)
                                        advance = int64(pkt.HeaderSize + pkt.PayloadSize)
                                }</span>
                        }

                        // Move forward by the packet size (or 1 if unknown)
                        <span class="cov7" title="14740010">newPos := startCodePos + advance
                        i = int(newPos - pos)</span>
                }

                // Move to next chunk, but back up slightly to catch start codes at boundaries
                <span class="cov4" title="9610">pos += int64(len(chunkData)) - 3
                if pos &lt; 0 </span><span class="cov0" title="0">{
                        pos = 0
                }</span>

                // Report progress
                <span class="cov4" title="9610">if progress != nil &amp;&amp; pos-lastProgress &gt; 100*1024*1024 </span><span class="cov3" title="365">{ // Every 100MB
                        progress(pos, p.size)
                        lastProgress = pos
                }</span>
        }

        <span class="cov1" title="5">if progress != nil </span><span class="cov1" title="5">{
                progress(p.size, p.size)
        }</span>

        // Build filtered video ranges that exclude user_data (B2) sections
        // This makes the ES compatible with what MKV tools produce
        <span class="cov1" title="5">if err := p.buildFilteredVideoRanges(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("build filtered video ranges: %w", err)
        }</span>

        // Build filtered audio ranges that strip Private Stream 1 headers
        // (sub-stream ID and 2-byte pointer, keeping frame count byte)
        <span class="cov1" title="5">if err := p.buildFilteredAudioRanges(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("build filtered audio ranges: %w", err)
        }</span>

        <span class="cov1" title="5">p.filterUserData = true

        return nil</span>
}

// buildFilteredVideoRanges scans the video ES and creates ranges that exclude user_data sections.
// User_data (00 00 01 B2) is used for closed captions etc. and is stripped by MKV tools.
// Optimized to use bytes.IndexByte for fast scanning (uses SIMD on x86).
func (p *MPEGPSParser) buildFilteredVideoRanges() error <span class="cov1" title="5">{
        if len(p.videoRanges) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Process each raw video range individually
        // This avoids complex chunk boundary handling
        // Pre-allocate with similar capacity to reduce reallocation
        <span class="cov1" title="5">filteredRanges := make([]PESPayloadRange, 0, len(p.videoRanges))
        var filteredESOffset int64

        for _, rawRange := range p.videoRanges </span><span class="cov7" title="6494530">{
                // Direct slice access - zero copy, no allocation
                endOffset := rawRange.FileOffset + int64(rawRange.Size)
                if endOffset &gt; p.size </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="6494530">data := p.data[rawRange.FileOffset:endOffset]

                // Scan for user_data sections within this PES payload
                // Use bytes.IndexByte to quickly find 0x01 bytes (SIMD optimized)
                i := 2 // Start at position 2 since we need at least 00 00 before 01
                rangeStart := 0
                for i &lt; len(data)-1 </span><span class="cov8" title="222556200">{
                        // Find next 0x01 byte
                        idx := bytes.IndexByte(data[i:], 0x01)
                        if idx &lt; 0 </span><span class="cov7" title="6281885">{
                                break</span>
                        }
                        <span class="cov8" title="216274315">pos := i + idx

                        // Check if this is a user_data start code (00 00 01 B2)
                        if pos &gt;= 2 &amp;&amp; pos &lt; len(data)-1 &amp;&amp;
                                data[pos-1] == 0x00 &amp;&amp; data[pos-2] == 0x00 &amp;&amp; data[pos+1] == UserDataStartCode </span><span class="cov3" title="145">{
                                // Found user_data - emit range before it
                                startCodePos := pos - 2
                                if startCodePos &gt; rangeStart </span><span class="cov3" title="145">{
                                        filteredRanges = append(filteredRanges, PESPayloadRange{
                                                FileOffset: rawRange.FileOffset + int64(rangeStart),
                                                Size:       startCodePos - rangeStart,
                                                ESOffset:   filteredESOffset,
                                        })
                                        filteredESOffset += int64(startCodePos - rangeStart)
                                }</span>

                                // Skip user_data section to next start code using fast scan
                                <span class="cov3" title="145">i = pos + 2
                                for i &lt; len(data)-1 </span><span class="cov4" title="1630">{
                                        idx := bytes.IndexByte(data[i:], 0x01)
                                        if idx &lt; 0 </span><span class="cov2" title="15">{
                                                i = len(data)
                                                break</span>
                                        }
                                        <span class="cov4" title="1615">nextPos := i + idx
                                        if nextPos &gt;= 2 &amp;&amp; data[nextPos-1] == 0x00 &amp;&amp; data[nextPos-2] == 0x00 </span><span class="cov2" title="65">{
                                                // Found next start code
                                                i = nextPos - 2
                                                break</span>
                                        }
                                        <span class="cov4" title="1550">i = nextPos + 1</span>
                                }
                                <span class="cov3" title="145">rangeStart = i</span>
                        } else<span class="cov8" title="216274170"> {
                                i = pos + 1
                        }</span>
                }

                // Emit remaining data in this PES payload
                <span class="cov7" title="6494530">if rangeStart &lt; len(data) </span><span class="cov7" title="6491605">{
                        filteredRanges = append(filteredRanges, PESPayloadRange{
                                FileOffset: rawRange.FileOffset + int64(rangeStart),
                                Size:       len(data) - rangeStart,
                                ESOffset:   filteredESOffset,
                        })
                        filteredESOffset += int64(len(data) - rangeStart)
                }</span>
        }

        <span class="cov1" title="5">p.filteredVideoRanges = filteredRanges
        return nil</span>
}

// buildFilteredAudioRanges creates ranges that strip Private Stream 1 headers
// and separates audio by sub-stream ID.
// DVD audio in Private Stream 1 has this structure:
//
//        Byte 0: sub-stream ID (0x80-0x87 = AC3, 0x88-0x8F = DTS, etc.)
//        Byte 1: number of audio frames
//        Bytes 2-3: first access unit pointer (offset to first audio frame)
//        Bytes 4+: audio data
//
// We strip the entire 4-byte header and keep only the raw audio data.
// Each sub-stream ID gets its own separate filtered ES to avoid interleaving issues.
func (p *MPEGPSParser) buildFilteredAudioRanges() error <span class="cov1" title="5">{
        if len(p.audioRanges) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Map to track ranges per sub-stream
        <span class="cov1" title="5">rangesBySubStream := make(map[byte][]PESPayloadRange)
        esOffsetBySubStream := make(map[byte]int64)
        seenSubStreams := make(map[byte]bool)

        for _, rawRange := range p.audioRanges </span><span class="cov6" title="483575">{
                if rawRange.Size &lt; 4 </span><span class="cov4" title="6480">{
                        // Too small to have the header structure
                        continue</span>
                }

                // Direct slice access - zero copy
                <span class="cov6" title="477095">if rawRange.FileOffset &gt;= p.size </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="477095">subStreamID := p.data[rawRange.FileOffset]

                // Check if this is AC3, DTS, or LPCM
                isAC3 := subStreamID &gt;= 0x80 &amp;&amp; subStreamID &lt;= 0x87
                isDTS := subStreamID &gt;= 0x88 &amp;&amp; subStreamID &lt;= 0x8F
                isLPCM := subStreamID &gt;= 0xA0 &amp;&amp; subStreamID &lt;= 0xA7

                if isAC3 || isDTS || isLPCM </span><span class="cov6" title="445125">{
                        // Track sub-stream order
                        if !seenSubStreams[subStreamID] </span><span class="cov2" title="120">{
                                seenSubStreams[subStreamID] = true
                                p.audioSubStreams = append(p.audioSubStreams, subStreamID)
                        }</span>

                        // Strip the entire 4-byte header, keep only raw audio data
                        <span class="cov6" title="445125">if rawRange.Size &gt; 4 </span><span class="cov6" title="445125">{
                                esOffset := esOffsetBySubStream[subStreamID]
                                rangesBySubStream[subStreamID] = append(rangesBySubStream[subStreamID], PESPayloadRange{
                                        FileOffset: rawRange.FileOffset + 4, // Skip header (1 + 1 + 2)
                                        Size:       rawRange.Size - 4,       // Rest is audio data
                                        ESOffset:   esOffset,
                                })
                                esOffsetBySubStream[subStreamID] += int64(rawRange.Size - 4)
                        }</span>
                }
                // Skip unknown sub-stream types (like subtitles 0x20-0x3F)
        }

        <span class="cov1" title="5">p.filteredAudioBySubStream = rangesBySubStream
        return nil</span>
}

// parsePackHeader parses an MPEG-2 pack header and returns its size.
func (p *MPEGPSParser) parsePackHeader(pos int64) (int, error) <span class="cov7" title="6964665">{
        // MPEG-2 pack header is 14 bytes minimum
        // Format: 00 00 01 BA + SCR (6 bytes) + mux_rate (3 bytes) + stuffing
        if pos+14 &gt; p.size </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read pack header")
        }</span>
        <span class="cov7" title="6964665">buf := p.data[pos : pos+14]

        // Check if this is MPEG-2 (starts with 01) or MPEG-1 (starts with 0010)
        if buf[4]&amp;0xC0 == 0x40 </span><span class="cov7" title="6964110">{
                // MPEG-2 pack header
                stuffingLen := int(buf[13] &amp; 0x07)
                return 14 + stuffingLen, nil
        }</span>

        // MPEG-1 pack header is 12 bytes
        <span class="cov3" title="555">return 12, nil</span>
}

// parseSystemHeader parses a system header and returns its total size.
func (p *MPEGPSParser) parseSystemHeader(pos int64) (int, error) <span class="cov5" title="43030">{
        length, err := p.readPESLength(pos + 4)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov5" title="43030">return 6 + int(length), nil</span>
}

// readPESLength reads the 2-byte PES packet length field.
func (p *MPEGPSParser) readPESLength(pos int64) (uint16, error) <span class="cov7" title="7064360">{
        if pos+2 &gt; p.size </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read PES length")
        }</span>
        <span class="cov7" title="7064360">return binary.BigEndian.Uint16(p.data[pos : pos+2]), nil</span>
}

// parsePESPacket parses a PES packet header and returns packet info.
func (p *MPEGPSParser) parsePESPacket(pos int64, streamID byte) (PESPacket, error) <span class="cov7" title="6978105">{
        pkt := PESPacket{
                StreamID: streamID,
                Offset:   pos,
        }

        // Read length field
        length, err := p.readPESLength(pos + 4)
        if err != nil </span><span class="cov0" title="0">{
                return pkt, err
        }</span>

        // PES packet structure after start code + stream ID + length:
        // - 2 bits: '10'
        // - 2 bits: PES_scrambling_control
        // - 1 bit: PES_priority
        // - 1 bit: data_alignment_indicator
        // - 1 bit: copyright
        // - 1 bit: original_or_copy
        // - 2 bits: PTS_DTS_flags
        // - 1 bit: ESCR_flag
        // - 1 bit: ES_rate_flag
        // - 1 bit: DSM_trick_mode_flag
        // - 1 bit: additional_copy_info_flag
        // - 1 bit: PES_CRC_flag
        // - 1 bit: PES_extension_flag
        // - 8 bits: PES_header_data_length
        // Then optional fields based on flags

        // Direct slice access for PES header fields
        <span class="cov7" title="6978105">if pos+9 &gt; p.size </span><span class="cov0" title="0">{
                return pkt, fmt.Errorf("failed to read PES header")
        }</span>
        <span class="cov7" title="6978105">buf := p.data[pos+6 : pos+9]

        // Check for MPEG-2 PES (starts with 10)
        if buf[0]&amp;0xC0 == 0x80 </span><span class="cov7" title="6931100">{
                // MPEG-2 PES header
                headerDataLen := int(buf[2])
                pkt.HeaderSize = 6 + 3 + headerDataLen // start code(4) + length(2) + flags(2) + header_len(1) + header_data
                pkt.PayloadOffset = pos + int64(pkt.HeaderSize)
                pkt.PayloadSize = int(length) - 3 - headerDataLen
        }</span> else<span class="cov5" title="47005"> {
                // MPEG-1 PES header - simpler structure
                // Skip stuffing bytes (0xFF) and find actual header
                headerLen := 0
                offset := pos + 6
                for </span><span class="cov5" title="60145">{
                        if offset+int64(headerLen) &gt;= p.size </span><span class="cov0" title="0">{
                                return pkt, fmt.Errorf("failed to read PES header: offset out of range")
                        }</span>
                        <span class="cov5" title="60145">b := p.data[offset+int64(headerLen)]
                        if b == 0xFF </span><span class="cov3" title="375">{
                                headerLen++
                                if headerLen &gt; 16 </span><span class="cov1" title="10">{ // Safety limit
                                        break</span>
                                }
                                <span class="cov3" title="365">continue</span>
                        }
                        <span class="cov5" title="59770">if b&amp;0xC0 == 0x40 </span><span class="cov4" title="12775">{
                                // STD buffer
                                headerLen += 2
                                continue</span>
                        }
                        <span class="cov5" title="46995">if b&amp;0xF0 == 0x20 </span><span class="cov4" title="2810">{
                                // PTS only
                                headerLen += 5
                        }</span> else<span class="cov5" title="44185"> if b&amp;0xF0 == 0x30 </span><span class="cov4" title="2905">{
                                // PTS + DTS
                                headerLen += 10
                        }</span> else<span class="cov5" title="41280"> if b == 0x0F </span><span class="cov3" title="215">{
                                // No timestamps
                                headerLen++
                        }</span>
                        <span class="cov5" title="46995">break</span>
                }
                <span class="cov5" title="47005">pkt.HeaderSize = 6 + headerLen
                pkt.PayloadOffset = pos + int64(pkt.HeaderSize)
                pkt.PayloadSize = int(length) - headerLen</span>
        }

        <span class="cov7" title="6978105">if pkt.PayloadSize &lt; 0 </span><span class="cov3" title="1220">{
                pkt.PayloadSize = 0
        }</span>

        <span class="cov7" title="6978105">return pkt, nil</span>
}

// VideoRanges returns all video payload ranges found in the stream.
func (p *MPEGPSParser) VideoRanges() []PESPayloadRange <span class="cov0" title="0">{
        return p.videoRanges
}</span>

// FilteredVideoRangesCount returns the number of filtered video ranges.
func (p *MPEGPSParser) FilteredVideoRangesCount() int <span class="cov0" title="0">{
        return len(p.filteredVideoRanges)
}</span>

// RawVideoESSize returns the total size of raw (unfiltered) video ES.
func (p *MPEGPSParser) RawVideoESSize() int64 <span class="cov0" title="0">{
        if len(p.videoRanges) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">last := p.videoRanges[len(p.videoRanges)-1]
        return last.ESOffset + int64(last.Size)</span>
}

// AudioRanges returns all audio payload ranges found in the stream.
func (p *MPEGPSParser) AudioRanges() []PESPayloadRange <span class="cov0" title="0">{
        return p.audioRanges
}</span>

// Packets returns all parsed PES packets.
func (p *MPEGPSParser) Packets() []PESPacket <span class="cov1" title="4">{
        return p.packets
}</span>

// FileOffsetToESOffset converts a file offset within a payload to an ES offset.
// Returns -1 if the offset is not within a known payload range.
func (p *MPEGPSParser) FileOffsetToESOffset(fileOffset int64, isVideo bool) int64 <span class="cov0" title="0">{
        ranges := p.audioRanges
        if isVideo </span><span class="cov0" title="0">{
                ranges = p.videoRanges
        }</span>

        <span class="cov0" title="0">for _, r := range ranges </span><span class="cov0" title="0">{
                if fileOffset &gt;= r.FileOffset &amp;&amp; fileOffset &lt; r.FileOffset+int64(r.Size) </span><span class="cov0" title="0">{
                        offsetInPayload := fileOffset - r.FileOffset
                        return r.ESOffset + offsetInPayload
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// ESOffsetToFileOffset converts an ES offset to a file offset.
// Returns the file offset and payload remaining size, or -1 if not found.
func (p *MPEGPSParser) ESOffsetToFileOffset(esOffset int64, isVideo bool) (fileOffset int64, remaining int) <span class="cov0" title="0">{
        ranges := p.audioRanges
        if isVideo </span><span class="cov0" title="0">{
                ranges = p.videoRanges
        }</span>

        <span class="cov0" title="0">for _, r := range ranges </span><span class="cov0" title="0">{
                if esOffset &gt;= r.ESOffset &amp;&amp; esOffset &lt; r.ESOffset+int64(r.Size) </span><span class="cov0" title="0">{
                        offsetInPayload := esOffset - r.ESOffset
                        return r.FileOffset + offsetInPayload, r.Size - int(offsetInPayload)
                }</span>
        }
        <span class="cov0" title="0">return -1, 0</span>
}

// TotalESSize returns the total size of the elementary stream.
// For video, returns filtered ES size when filtering is enabled.
// For audio, this returns 0 - use AudioSubStreamESSize instead.
func (p *MPEGPSParser) TotalESSize(isVideo bool) int64 <span class="cov8" title="53233459">{
        if !isVideo </span><span class="cov0" title="0">{
                // Audio now uses per-sub-stream ranges - return 0 to indicate callers should use AudioSubStreamESSize
                return 0
        }</span>
        <span class="cov8" title="53233459">var ranges []PESPayloadRange
        if p.filterUserData &amp;&amp; len(p.filteredVideoRanges) &gt; 0 </span><span class="cov8" title="53233455">{
                ranges = p.filteredVideoRanges
        }</span> else<span class="cov1" title="4"> {
                ranges = p.videoRanges
        }</span>
        <span class="cov8" title="53233459">if len(ranges) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="53233459">last := ranges[len(ranges)-1]
        return last.ESOffset + int64(last.Size)</span>
}

// AudioSubStreams returns the list of audio sub-stream IDs in order of appearance.
func (p *MPEGPSParser) AudioSubStreams() []byte <span class="cov1" title="9">{
        return p.audioSubStreams
}</span>

// AudioSubStreamCount returns the number of audio sub-streams.
func (p *MPEGPSParser) AudioSubStreamCount() int <span class="cov0" title="0">{
        return len(p.audioSubStreams)
}</span>

// AudioSubStreamESSize returns the total ES size for a specific audio sub-stream.
func (p *MPEGPSParser) AudioSubStreamESSize(subStreamID byte) int64 <span class="cov6" title="1077935">{
        ranges, ok := p.filteredAudioBySubStream[subStreamID]
        if !ok || len(ranges) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov6" title="1077935">last := ranges[len(ranges)-1]
        return last.ESOffset + int64(last.Size)</span>
}

// FilteredVideoRanges returns the filtered video payload ranges for zero-copy iteration.
// Returns the raw video ranges if filtering is not enabled.
func (p *MPEGPSParser) FilteredVideoRanges() []PESPayloadRange <span class="cov1" title="5">{
        if p.filterUserData &amp;&amp; len(p.filteredVideoRanges) &gt; 0 </span><span class="cov1" title="5">{
                return p.filteredVideoRanges
        }</span>
        <span class="cov0" title="0">return p.videoRanges</span>
}

// FilteredAudioRanges returns the filtered audio payload ranges for a specific sub-stream.
// Returns nil if the sub-stream doesn't exist.
func (p *MPEGPSParser) FilteredAudioRanges(subStreamID byte) []PESPayloadRange <span class="cov2" title="120">{
        return p.filteredAudioBySubStream[subStreamID]
}</span>

// Data returns the raw mmap'd file data for zero-copy access.
func (p *MPEGPSParser) Data() []byte <span class="cov2" title="125">{
        return p.data
}</span>

// binarySearchRanges performs binary search on ranges to find the one containing esOffset.
func (p *MPEGPSParser) binarySearchRanges(ranges []PESPayloadRange, esOffset int64) int <span class="cov8" title="163893656">{
        if len(ranges) == 0 </span><span class="cov0" title="0">{
                return -1
        }</span>

        // Binary search for the range containing esOffset
        <span class="cov8" title="163893656">low, high := 0, len(ranges)-1
        for low &lt;= high </span><span class="cov9" title="3162142769">{
                mid := (low + high) / 2
                r := ranges[mid]
                if esOffset &lt; r.ESOffset </span><span class="cov9" title="1509467731">{
                        high = mid - 1
                }</span> else<span class="cov9" title="1652675038"> if esOffset &gt;= r.ESOffset+int64(r.Size) </span><span class="cov9" title="1488781386">{
                        low = mid + 1
                }</span> else<span class="cov8" title="163893652"> {
                        return mid
                }</span>
        }
        <span class="cov1" title="4">return -1</span>
}

// ReadESByteWithHint reads a single byte from the ES stream, using a range hint
// to avoid binary search when reading sequentially. Returns the byte, the range
// index where it was found (for use as hint on next call), and success status.
// Pass rangeHint=-1 to force binary search.
func (p *MPEGPSParser) ReadESByteWithHint(esOffset int64, isVideo bool, rangeHint int) (byte, int, bool) <span class="cov9" title="1839843352">{
        var ranges []PESPayloadRange
        if isVideo </span><span class="cov9" title="1839843352">{
                if p.filterUserData &amp;&amp; len(p.filteredVideoRanges) &gt; 0 </span><span class="cov9" title="1839843352">{
                        ranges = p.filteredVideoRanges
                }</span> else<span class="cov0" title="0"> {
                        ranges = p.videoRanges
                }</span>
        } else<span class="cov0" title="0"> {
                // Audio doesn't use this method - it goes through sub-stream reader
                return 0, -1, false
        }</span>

        <span class="cov9" title="1839843352">if len(ranges) == 0 </span><span class="cov0" title="0">{
                return 0, -1, false
        }</span>

        // Fast path: check if hint is still valid (O(1) check)
        <span class="cov9" title="1839843352">if rangeHint &gt;= 0 &amp;&amp; rangeHint &lt; len(ranges) </span><span class="cov9" title="1733376450">{
                r := ranges[rangeHint]
                if esOffset &gt;= r.ESOffset &amp;&amp; esOffset &lt; r.ESOffset+int64(r.Size) </span><span class="cov9" title="1731392246">{
                        // Hint was correct - read directly
                        offsetInPayload := esOffset - r.ESOffset
                        fileOffset := r.FileOffset + offsetInPayload
                        if fileOffset &gt;= 0 &amp;&amp; fileOffset &lt; p.size </span><span class="cov9" title="1731392246">{
                                return p.data[fileOffset], rangeHint, true
                        }</span>
                }
                // Check adjacent range (common case when crossing boundaries)
                <span class="cov6" title="1984204">if rangeHint+1 &lt; len(ranges) </span><span class="cov6" title="1984202">{
                        r = ranges[rangeHint+1]
                        if esOffset &gt;= r.ESOffset &amp;&amp; esOffset &lt; r.ESOffset+int64(r.Size) </span><span class="cov6" title="1984187">{
                                offsetInPayload := esOffset - r.ESOffset
                                fileOffset := r.FileOffset + offsetInPayload
                                if fileOffset &gt;= 0 &amp;&amp; fileOffset &lt; p.size </span><span class="cov6" title="1984187">{
                                        return p.data[fileOffset], rangeHint + 1, true
                                }</span>
                        }
                }
        }

        // Slow path: binary search
        <span class="cov8" title="106466919">rangeIdx := p.binarySearchRanges(ranges, esOffset)
        if rangeIdx &lt; 0 </span><span class="cov1" title="2">{
                return 0, -1, false
        }</span>

        <span class="cov8" title="106466917">r := ranges[rangeIdx]
        offsetInPayload := esOffset - r.ESOffset
        fileOffset := r.FileOffset + offsetInPayload
        if fileOffset &gt;= 0 &amp;&amp; fileOffset &lt; p.size </span><span class="cov8" title="106466917">{
                return p.data[fileOffset], rangeIdx, true
        }</span>

        <span class="cov0" title="0">return 0, -1, false</span>
}

// ReadAudioByteWithHint reads a single byte from an audio sub-stream, using a range hint.
func (p *MPEGPSParser) ReadAudioByteWithHint(subStreamID byte, esOffset int64, rangeHint int) (byte, int, bool) <span class="cov9" title="357585137">{
        ranges := p.filteredAudioBySubStream[subStreamID]
        if len(ranges) == 0 </span><span class="cov0" title="0">{
                return 0, -1, false
        }</span>

        // Fast path: check if hint is still valid
        <span class="cov9" title="357585137">if rangeHint &gt;= 0 &amp;&amp; rangeHint &lt; len(ranges) </span><span class="cov9" title="355429507">{
                r := ranges[rangeHint]
                if esOffset &gt;= r.ESOffset &amp;&amp; esOffset &lt; r.ESOffset+int64(r.Size) </span><span class="cov9" title="355289147">{
                        offsetInPayload := esOffset - r.ESOffset
                        fileOffset := r.FileOffset + offsetInPayload
                        if fileOffset &gt;= 0 &amp;&amp; fileOffset &lt; p.size </span><span class="cov9" title="355289147">{
                                return p.data[fileOffset], rangeHint, true
                        }</span>
                }
                // Check adjacent range
                <span class="cov5" title="140360">if rangeHint+1 &lt; len(ranges) </span><span class="cov5" title="140360">{
                        r = ranges[rangeHint+1]
                        if esOffset &gt;= r.ESOffset &amp;&amp; esOffset &lt; r.ESOffset+int64(r.Size) </span><span class="cov5" title="140355">{
                                offsetInPayload := esOffset - r.ESOffset
                                fileOffset := r.FileOffset + offsetInPayload
                                if fileOffset &gt;= 0 &amp;&amp; fileOffset &lt; p.size </span><span class="cov5" title="140355">{
                                        return p.data[fileOffset], rangeHint + 1, true
                                }</span>
                        }
                }
        }

        // Slow path: binary search
        <span class="cov6" title="2155635">rangeIdx := p.binarySearchRanges(ranges, esOffset)
        if rangeIdx &lt; 0 </span><span class="cov0" title="0">{
                return 0, -1, false
        }</span>

        <span class="cov6" title="2155635">r := ranges[rangeIdx]
        offsetInPayload := esOffset - r.ESOffset
        fileOffset := r.FileOffset + offsetInPayload
        if fileOffset &gt;= 0 &amp;&amp; fileOffset &lt; p.size </span><span class="cov6" title="2155635">{
                return p.data[fileOffset], rangeIdx, true
        }</span>

        <span class="cov0" title="0">return 0, -1, false</span>
}

// Video start codes that should be KEPT (not user_data)
const (
        UserDataStartCode = 0xB2 // This gets stripped by MKV tools
)

// RawRange represents a contiguous chunk of raw file data corresponding to
// part of an ES region. Used for converting ES offsets to raw file offsets.
type RawRange struct {
        FileOffset int64 // Offset in the raw file
        Size       int   // Size of this chunk
}

// RawRangesForESRegion returns the raw file ranges that contain the given ES region.
// Each returned range represents a contiguous chunk of raw file data.
// The sum of all returned range sizes equals the requested ES region size.
// For video streams only - audio should use RawRangesForAudioSubStream.
func (p *MPEGPSParser) RawRangesForESRegion(esOffset int64, size int, isVideo bool) ([]RawRange, error) <span class="cov5" title="163247">{
        if !isVideo </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("audio uses per-sub-stream methods, use RawRangesForAudioSubStream")
        }</span>

        <span class="cov5" title="163245">var ranges []PESPayloadRange
        if p.filterUserData &amp;&amp; len(p.filteredVideoRanges) &gt; 0 </span><span class="cov5" title="163243">{
                ranges = p.filteredVideoRanges
        }</span> else<span class="cov1" title="2"> {
                ranges = p.videoRanges
        }</span>

        <span class="cov5" title="163245">return p.rawRangesFromPESRanges(ranges, esOffset, size)</span>
}

// RawRangesForAudioSubStream returns the raw file ranges for audio data from a specific sub-stream.
func (p *MPEGPSParser) RawRangesForAudioSubStream(subStreamID byte, esOffset int64, size int) ([]RawRange, error) <span class="cov6" title="203306">{
        ranges, ok := p.filteredAudioBySubStream[subStreamID]
        if !ok </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("audio sub-stream 0x%02X not found", subStreamID)
        }</span>
        <span class="cov6" title="203304">return p.rawRangesFromPESRanges(ranges, esOffset, size)</span>
}

// rawRangesFromPESRanges enumerates raw file ranges for a given ES region.
func (p *MPEGPSParser) rawRangesFromPESRanges(ranges []PESPayloadRange, esOffset int64, size int) ([]RawRange, error) <span class="cov6" title="366549">{
        if len(ranges) == 0 </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("no ranges available")
        }</span>

        // Use binary search to find starting range
        <span class="cov6" title="366547">rangeIdx := p.binarySearchRanges(ranges, esOffset)
        if rangeIdx &lt; 0 </span><span class="cov1" title="2">{
                // Maybe esOffset is before the first range, try linear from start
                rangeIdx = 0
                for rangeIdx &lt; len(ranges) &amp;&amp; esOffset &gt;= ranges[rangeIdx].ESOffset+int64(ranges[rangeIdx].Size) </span><span class="cov1" title="2">{
                        rangeIdx++
                }</span>
        }

        <span class="cov6" title="366547">if rangeIdx &gt;= len(ranges) </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("ES offset %d not found in ranges", esOffset)
        }</span>

        <span class="cov6" title="366545">r := ranges[rangeIdx]
        if esOffset &lt; r.ESOffset || esOffset &gt;= r.ESOffset+int64(r.Size) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ES offset %d not in range [%d, %d)", esOffset, r.ESOffset, r.ESOffset+int64(r.Size))
        }</span>

        // Collect raw ranges
        <span class="cov6" title="366545">var result []RawRange
        remaining := size

        for remaining &gt; 0 &amp;&amp; rangeIdx &lt; len(ranges) </span><span class="cov7" title="2353488">{
                r := ranges[rangeIdx]

                if esOffset &lt; r.ESOffset </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov7" title="2353488">if esOffset &gt;= r.ESOffset+int64(r.Size) </span><span class="cov0" title="0">{
                        rangeIdx++
                        continue</span>
                }

                <span class="cov7" title="2353488">offsetInPayload := esOffset - r.ESOffset
                availableInRange := int64(r.Size) - offsetInPayload
                toTake := remaining
                if int64(toTake) &gt; availableInRange </span><span class="cov6" title="1986943">{
                        toTake = int(availableInRange)
                }</span>

                <span class="cov7" title="2353488">fileOffset := r.FileOffset + offsetInPayload
                result = append(result, RawRange{
                        FileOffset: fileOffset,
                        Size:       toTake,
                })

                esOffset += int64(toTake)
                remaining -= toTake
                rangeIdx++</span>
        }

        <span class="cov6" title="366545">if remaining &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not map entire ES region: %d bytes remaining", remaining)
        }</span>

        <span class="cov6" title="366545">return result, nil</span>
}

// ReadESData reads elementary stream data at the given ES offset.
// For video, returns FILTERED ES data (excludes user_data sections).
// For audio, returns error - use ReadAudioSubStreamData instead.
func (p *MPEGPSParser) ReadESData(esOffset int64, size int, isVideo bool) ([]byte, error) <span class="cov8" title="53817965">{
        if !isVideo </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("audio uses per-sub-stream methods, use ReadAudioSubStreamData")
        }</span>

        <span class="cov8" title="53817965">var ranges []PESPayloadRange
        if p.filterUserData &amp;&amp; len(p.filteredVideoRanges) &gt; 0 </span><span class="cov8" title="53817965">{
                ranges = p.filteredVideoRanges
        }</span> else<span class="cov0" title="0"> {
                ranges = p.videoRanges
        }</span>

        <span class="cov8" title="53817965">return p.readFromRanges(ranges, esOffset, size, isVideo)</span>
}

// ReadAudioSubStreamData reads audio data from a specific sub-stream.
func (p *MPEGPSParser) ReadAudioSubStreamData(subStreamID byte, esOffset int64, size int) ([]byte, error) <span class="cov6" title="1086590">{
        ranges, ok := p.filteredAudioBySubStream[subStreamID]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("audio sub-stream 0x%02X not found", subStreamID)
        }</span>
        <span class="cov6" title="1086590">return p.readFromRanges(ranges, esOffset, size, false)</span>
}

// readFromRanges reads data from a range list starting at the given ES offset.
// Returns a zero-copy slice when data fits in a single range (common case),
// only copies when data spans multiple ranges.
func (p *MPEGPSParser) readFromRanges(ranges []PESPayloadRange, esOffset int64, size int, _ bool) ([]byte, error) <span class="cov8" title="54904555">{
        if len(ranges) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no ranges available")
        }</span>

        // Use binary search to find starting range
        <span class="cov8" title="54904555">rangeIdx := p.binarySearchRanges(ranges, esOffset)
        if rangeIdx &lt; 0 </span><span class="cov0" title="0">{
                // Maybe esOffset is before the first range, try linear from start
                rangeIdx = 0
                for rangeIdx &lt; len(ranges) &amp;&amp; esOffset &gt;= ranges[rangeIdx].ESOffset+int64(ranges[rangeIdx].Size) </span><span class="cov0" title="0">{
                        rangeIdx++
                }</span>
        }

        <span class="cov8" title="54904555">if rangeIdx &gt;= len(ranges) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ES offset %d not found in ranges", esOffset)
        }</span>

        <span class="cov8" title="54904555">r := ranges[rangeIdx]
        if esOffset &lt; r.ESOffset || esOffset &gt;= r.ESOffset+int64(r.Size) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ES offset %d not in range [%d, %d)", esOffset, r.ESOffset, r.ESOffset+int64(r.Size))
        }</span>

        <span class="cov8" title="54904555">offsetInPayload := esOffset - r.ESOffset
        availableInRange := int64(r.Size) - offsetInPayload

        // Fast path: data fits entirely within this single range (zero-copy)
        if int64(size) &lt;= availableInRange </span><span class="cov8" title="54288045">{
                fileOffset := r.FileOffset + offsetInPayload
                endOffset := fileOffset + int64(size)
                if endOffset &gt; p.size </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("file offset out of range")
                }</span>
                // Return slice directly into mmap'd data - no copy!
                <span class="cov8" title="54288045">return p.data[fileOffset:endOffset], nil</span>
        }

        // Slow path: data spans multiple ranges - must copy
        <span class="cov6" title="616510">result := make([]byte, 0, size)
        remaining := size

        for remaining &gt; 0 &amp;&amp; rangeIdx &lt; len(ranges) </span><span class="cov6" title="1233295">{
                r := ranges[rangeIdx]

                if esOffset &lt; r.ESOffset </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov6" title="1233295">if esOffset &gt;= r.ESOffset+int64(r.Size) </span><span class="cov0" title="0">{
                        rangeIdx++
                        continue</span>
                }

                <span class="cov6" title="1233295">offsetInPayload := esOffset - r.ESOffset
                availableInRange := int64(r.Size) - offsetInPayload
                toRead := remaining
                if int64(toRead) &gt; availableInRange </span><span class="cov6" title="616785">{
                        toRead = int(availableInRange)
                }</span>

                <span class="cov6" title="1233295">fileOffset := r.FileOffset + offsetInPayload
                endOffset := fileOffset + int64(toRead)
                if endOffset &gt; p.size </span><span class="cov0" title="0">{
                        if len(result) &gt; 0 </span><span class="cov0" title="0">{
                                return result, nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to read ES data: offset out of range")</span>
                }

                <span class="cov6" title="1233295">result = append(result, p.data[fileOffset:endOffset]...)
                esOffset += int64(toRead)
                remaining -= toRead
                rangeIdx++</span>
        }

        <span class="cov6" title="616510">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package source provides functionality for indexing source media files (DVD ISOs, Blu-ray directories).
package source

import (
        "errors"
        "os"
        "path/filepath"
        "strings"

        "github.com/stuckj/mkvdup/internal/mmap"
)

// Type represents the type of source media.
type Type int

// Source type constants.
const (
        TypeDVD    Type = iota // Contains .iso file
        TypeBluray             // Contains BDMV/STREAM/*.m2ts
)

func (t Type) String() string <span class="cov2" title="14">{
        switch t </span>{
        case TypeDVD:<span class="cov1" title="4">
                return "DVD"</span>
        case TypeBluray:<span class="cov1" title="4">
                return "Blu-ray"</span>
        default:<span class="cov1" title="6">
                return "Unknown"</span>
        }
}

// ErrUnknownSourceType is returned when the source directory type cannot be determined.
var ErrUnknownSourceType = errors.New("unknown source type: directory contains neither ISO nor BDMV structure")

// DetectType determines whether a directory contains a DVD ISO or Blu-ray structure.
// ISOs are inspected to determine if they contain DVD (VIDEO_TS) or Blu-ray (BDMV) content.
func DetectType(dir string) (Type, error) <span class="cov2" title="30">{
        // Check for ISO files
        isos, err := filepath.Glob(filepath.Join(dir, "*.iso"))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Also check for ISO in subdirectory (common structure)
        <span class="cov2" title="30">subIsos, err := filepath.Glob(filepath.Join(dir, "*", "*.iso"))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov2" title="30">isos = append(isos, subIsos...)

        // If we found ISOs, inspect them to determine type
        if len(isos) &gt; 0 </span><span class="cov2" title="17">{
                // Check the first ISO to determine type
                isoType, err := detectISOType(isos[0])
                if err != nil </span><span class="cov2" title="12">{
                        // If we can't read the ISO, default to DVD (legacy behavior)
                        return TypeDVD, nil
                }</span>
                <span class="cov1" title="5">return isoType, nil</span>
        }

        // Check for Blu-ray directory structure
        <span class="cov2" title="13">m2ts, err := filepath.Glob(filepath.Join(dir, "BDMV", "STREAM", "*.m2ts"))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov2" title="13">if len(m2ts) &gt; 0 </span><span class="cov1" title="3">{
                return TypeBluray, nil
        }</span>

        <span class="cov2" title="10">return 0, ErrUnknownSourceType</span>
}

// detectISOType examines an ISO file to determine if it's a DVD or Blu-ray.
// DVDs have VIDEO_TS directory, Blu-rays have BDMV directory.
// Uses minimal reads to avoid loading the entire ISO into memory.
func detectISOType(isoPath string) (Type, error) <span class="cov2" title="17">{
        f, err := os.Open(isoPath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov2" title="17">defer f.Close()

        // ISO9660 primary volume descriptor is at sector 16 (2048 bytes per sector)
        // The root directory record is embedded in the volume descriptor at offset 156.
        const sectorSize = 2048
        const pvdOffset = 16 * sectorSize

        // Read the primary volume descriptor
        pvd := make([]byte, sectorSize)
        if _, err := f.ReadAt(pvd, pvdOffset); err != nil </span><span class="cov2" title="12">{
                return 0, err
        }</span>

        // Check volume descriptor type (byte 0) and signature "CD001" (bytes 1-5)
        <span class="cov1" title="5">if pvd[0] != 1 || string(pvd[1:6]) != "CD001" </span><span class="cov0" title="0">{
                // Not a valid ISO9660 primary volume descriptor, default to DVD
                return TypeDVD, nil
        }</span>

        // Root directory record is at offset 156, length at byte 0 of the record
        <span class="cov1" title="5">rootDirRecord := pvd[156:]
        if len(rootDirRecord) &lt; 34 </span><span class="cov0" title="0">{
                return TypeDVD, nil
        }</span>

        // Extract root directory extent location (bytes 2-5, little-endian)
        <span class="cov1" title="5">rootExtent := uint32(rootDirRecord[2]) | uint32(rootDirRecord[3])&lt;&lt;8 |
                uint32(rootDirRecord[4])&lt;&lt;16 | uint32(rootDirRecord[5])&lt;&lt;24
        // Extract root directory data length (bytes 10-13, little-endian)
        rootDataLen := uint32(rootDirRecord[10]) | uint32(rootDirRecord[11])&lt;&lt;8 |
                uint32(rootDirRecord[12])&lt;&lt;16 | uint32(rootDirRecord[13])&lt;&lt;24

        // Read the root directory
        // Limit to first 16KB to avoid reading huge directories
        if rootDataLen &gt; 16*1024 </span><span class="cov0" title="0">{
                rootDataLen = 16 * 1024
        }</span>
        <span class="cov1" title="5">rootDir := make([]byte, rootDataLen)
        if _, err := f.ReadAt(rootDir, int64(rootExtent)*sectorSize); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Parse directory entries looking for VIDEO_TS or BDMV
        <span class="cov1" title="5">hasBDMV := false
        hasVideoTS := false

        offset := 0
        for offset &lt; len(rootDir) </span><span class="cov3" title="115">{
                recLen := int(rootDir[offset])
                if recLen == 0 </span><span class="cov1" title="5">{
                        // Move to next sector boundary
                        nextSector := ((offset / sectorSize) + 1) * sectorSize
                        if nextSector &gt;= len(rootDir) </span><span class="cov1" title="5">{
                                break</span>
                        }
                        <span class="cov0" title="0">offset = nextSector
                        continue</span>
                }
                <span class="cov3" title="110">if offset+recLen &gt; len(rootDir) </span><span class="cov0" title="0">{
                        break</span>
                }

                // Name length is at offset 32
                <span class="cov3" title="110">if offset+33 &gt; len(rootDir) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov3" title="110">nameLen := int(rootDir[offset+32])
                if offset+33+nameLen &gt; len(rootDir) </span><span class="cov0" title="0">{
                        break</span>
                }

                // Extract and check the filename
                <span class="cov3" title="110">name := strings.ToUpper(string(rootDir[offset+33 : offset+33+nameLen]))
                // Strip version number (;1) if present
                if idx := strings.Index(name, ";"); idx &gt;= 0 </span><span class="cov2" title="50">{
                        name = name[:idx]
                }</span>
                // Strip trailing dot if present
                <span class="cov3" title="110">name = strings.TrimSuffix(name, ".")

                if name == "BDMV" </span><span class="cov0" title="0">{
                        hasBDMV = true
                }</span>
                <span class="cov3" title="110">if name == "VIDEO_TS" </span><span class="cov1" title="5">{
                        hasVideoTS = true
                }</span>

                <span class="cov3" title="110">offset += recLen</span>
        }

        // Blu-ray takes precedence if both are present
        <span class="cov1" title="5">if hasBDMV </span><span class="cov0" title="0">{
                return TypeBluray, nil
        }</span>
        <span class="cov1" title="5">if hasVideoTS </span><span class="cov1" title="5">{
                return TypeDVD, nil
        }</span>

        // Default to DVD for unrecognized ISOs
        <span class="cov0" title="0">return TypeDVD, nil</span>
}

// File represents a source file within the source directory.
type File struct {
        RelativePath string // Path relative to source directory
        Size         int64
        Checksum     uint64 // xxhash of file for integrity
}

// Location represents a position within a source file where a hash was found.
type Location struct {
        FileIndex        uint16 // Index into Files array
        Offset           int64  // Offset within that file (or ES offset for MPEG-PS)
        IsVideo          bool   // For ES-based indexes: true for video ES, false for audio ES
        AudioSubStreamID byte   // For audio in MPEG-PS: sub-stream ID (0x80-0x87 = AC3, etc.)
}

// ESRangeConverter provides an interface for converting ES offsets to raw file offsets.
// This is used during dedup file creation to convert ES-based entries to raw-offset entries.
type ESRangeConverter interface {
        // RawRangesForESRegion returns the raw file ranges that contain the given ES region.
        // Each returned range represents a contiguous chunk of raw file data.
        // The sum of all returned range sizes equals the requested ES region size.
        // For video streams only - audio should use RawRangesForAudioSubStream.
        RawRangesForESRegion(esOffset int64, size int, isVideo bool) ([]RawRange, error)
        // RawRangesForAudioSubStream returns the raw file ranges for audio data from a specific sub-stream.
        RawRangesForAudioSubStream(subStreamID byte, esOffset int64, size int) ([]RawRange, error)
}

// ESReader provides an interface for reading elementary stream data from container files.
type ESReader interface {
        // ReadESData reads size bytes of ES data starting at esOffset.
        // The data is continuous ES data, with container headers stripped.
        // For video, this works as expected. For audio, use ReadAudioSubStreamData instead.
        ReadESData(esOffset int64, size int, isVideo bool) ([]byte, error)
        // ESOffsetToFileOffset converts an ES offset to a file offset and remaining bytes in that segment.
        ESOffsetToFileOffset(esOffset int64, isVideo bool) (fileOffset int64, remaining int)
        // TotalESSize returns the total size of the elementary stream.
        // For video, returns filtered video ES size. For audio, returns 0 - use AudioSubStreamESSize.
        TotalESSize(isVideo bool) int64
        // AudioSubStreams returns the list of audio sub-stream IDs in order of appearance.
        AudioSubStreams() []byte
        // AudioSubStreamESSize returns the ES size for a specific audio sub-stream.
        AudioSubStreamESSize(subStreamID byte) int64
        // ReadAudioSubStreamData reads audio data from a specific sub-stream.
        ReadAudioSubStreamData(subStreamID byte, esOffset int64, size int) ([]byte, error)
}

// RawReader provides an interface for reading raw file data.
type RawReader interface {
        ReadAt(buf []byte, offset int64) (int, error)
        // Slice returns a zero-copy slice of the underlying data.
        // Returns nil if offset is out of range.
        Slice(offset int64, size int) []byte
        Len() int
        Close() error
}

// Index holds the hash-to-location mapping for fast lookup of byte sequences.
type Index struct {
        // HashToLocations maps from xxhash to list of locations where that hash was found
        HashToLocations map[uint64][]Location

        // SourceDir is the path to the source directory
        SourceDir string

        // SourceType indicates whether this is DVD or Blu-ray
        SourceType Type

        // Files lists all media files in the source
        Files []File

        // WindowSize is the number of bytes used for hashing
        WindowSize int

        // ESReaders provides ES-aware reading for each file (nil for raw files)
        // For MPEG-PS files, this allows reading continuous ES data.
        ESReaders []ESReader

        // RawReaders provides raw file reading for each file.
        // Used when raw file indexing is enabled.
        RawReaders []RawReader

        // MmapFiles holds the mmap file handles for proper cleanup.
        // These back the ESReaders for MPEG-PS files.
        MmapFiles []*mmap.File

        // UsesESOffsets indicates whether Location.Offset values are ES offsets
        // rather than raw file offsets. True for DVD (MPEG-PS) sources.
        UsesESOffsets bool
}

// NewIndex creates a new empty Index for the given source directory.
func NewIndex(sourceDir string, sourceType Type, windowSize int) *Index <span class="cov2" title="40">{
        return &amp;Index{
                HashToLocations: make(map[uint64][]Location),
                SourceDir:       sourceDir,
                SourceType:      sourceType,
                WindowSize:      windowSize,
        }
}</span>

// EnumerateMediaFiles returns the list of media files to index based on source type.
func EnumerateMediaFiles(dir string, sourceType Type) ([]string, error) <span class="cov2" title="14">{
        var files []string

        switch sourceType </span>{
        case TypeDVD:<span class="cov2" title="9">
                // Look for ISO files
                isos, err := filepath.Glob(filepath.Join(dir, "*.iso"))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov2" title="9">files = append(files, isos...)

                // Also check subdirectory
                isos, err = filepath.Glob(filepath.Join(dir, "*", "*.iso"))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov2" title="9">files = append(files, isos...)</span>

        case TypeBluray:<span class="cov1" title="5">
                // Look for m2ts files in BDMV/STREAM
                m2ts, err := filepath.Glob(filepath.Join(dir, "BDMV", "STREAM", "*.m2ts"))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="5">files = append(files, m2ts...)</span>
        }

        // Convert to relative paths
        <span class="cov2" title="14">relFiles := make([]string, 0, len(files))
        for _, f := range files </span><span class="cov2" title="14">{
                rel, err := filepath.Rel(dir, f)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov2" title="14">relFiles = append(relFiles, rel)</span>
        }

        <span class="cov2" title="14">return relFiles, nil</span>
}

// GetFileInfo returns size information for a file.
func GetFileInfo(path string) (int64, error) <span class="cov2" title="16">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov1" title="2">{
                return 0, err
        }</span>
        <span class="cov2" title="14">return info.Size(), nil</span>
}

// ReadRawDataAt reads raw data from the source file at the given location.
// This is used for raw file indexing (non-ES mode).
// Note: This copies data. Prefer RawSlice for zero-copy access.
func (idx *Index) ReadRawDataAt(loc Location, size int) ([]byte, error) <span class="cov1" title="2">{
        if int(loc.FileIndex) &gt;= len(idx.RawReaders) || idx.RawReaders[loc.FileIndex] == nil </span><span class="cov1" title="2">{
                return nil, errors.New("no raw reader for file")
        }</span>
        <span class="cov0" title="0">buf := make([]byte, size)
        n, err := idx.RawReaders[loc.FileIndex].ReadAt(buf, loc.Offset)
        if err != nil &amp;&amp; n &lt; size </span><span class="cov0" title="0">{
                return buf[:n], err
        }</span>
        <span class="cov0" title="0">return buf[:n], nil</span>
}

// RawSlice returns a zero-copy slice of raw data at the given location.
// Returns nil if the location is out of range.
func (idx *Index) RawSlice(loc Location, size int) []byte <span class="cov10" title="340445160">{
        if int(loc.FileIndex) &gt;= len(idx.RawReaders) || idx.RawReaders[loc.FileIndex] == nil </span><span class="cov1" title="2">{
                return nil
        }</span>
        <span class="cov9" title="340445158">return idx.RawReaders[loc.FileIndex].Slice(loc.Offset, size)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package source

import "bytes"

// FindVideoStartCodes finds all video start code positions (00 00 01 XX pattern) in the data.
// These are potential sync points where video frames or other structures begin.
// Optimized to use bytes.IndexByte for fast scanning (uses SIMD on x86).
func FindVideoStartCodes(data []byte) []int <span class="cov8" title="6687741">{
        if len(data) &lt; 4 </span><span class="cov3" title="169">{
                return nil
        }</span>

        // Pre-allocate with estimated capacity (roughly 1 start code per 2KB of video data)
        <span class="cov8" title="6687572">offsets := make([]int, 0, len(data)/2048+1)

        // Use bytes.IndexByte to quickly find the 0x01 byte (third byte of start code)
        // This is faster than checking every byte since IndexByte uses SIMD
        i := 2 // Start at position 2 since we need at least 00 00 before 01
        for i &lt; len(data)-1 </span><span class="cov10" title="243886778">{
                // Find next 0x01 byte
                idx := bytes.IndexByte(data[i:], 0x01)
                if idx &lt; 0 </span><span class="cov8" title="6473930">{
                        break</span>
                }
                <span class="cov9" title="237412848">pos := i + idx

                // Check if preceded by 00 00
                if pos &gt;= 2 &amp;&amp; data[pos-1] == 0x00 &amp;&amp; data[pos-2] == 0x00 </span><span class="cov8" title="24096324">{
                        offsets = append(offsets, pos-2)
                }</span>

                // Move past this position
                <span class="cov9" title="237412848">i = pos + 1</span>
        }

        <span class="cov8" title="6687572">return offsets</span>
}

// FindVideoStartCodesInRange finds video start codes within a specific range.
// Optimized version using bytes.IndexByte for fast scanning.
func FindVideoStartCodesInRange(data []byte, startOffset int) []int <span class="cov1" title="2">{
        if len(data) &lt; 4 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Pre-allocate with estimated capacity
        <span class="cov1" title="2">offsets := make([]int, 0, len(data)/2048+1)

        i := 2
        for i &lt; len(data)-1 </span><span class="cov1" title="6">{
                idx := bytes.IndexByte(data[i:], 0x01)
                if idx &lt; 0 </span><span class="cov1" title="2">{
                        break</span>
                }
                <span class="cov1" title="4">pos := i + idx

                if pos &gt;= 2 &amp;&amp; data[pos-1] == 0x00 &amp;&amp; data[pos-2] == 0x00 </span><span class="cov1" title="4">{
                        offsets = append(offsets, startOffset+pos-2)
                }</span>

                <span class="cov1" title="4">i = pos + 1</span>
        }

        <span class="cov1" title="2">return offsets</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package testdata provides helpers for locating integration test data.
//
// Test data (Big Buck Bunny DVD ISO and MKV) is not stored in the repository.
// See README.md in this directory for setup instructions.
package testdata

import (
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "testing"
)

// Paths contains the resolved paths to test data files.
type Paths struct {
        Root      string // Base test data directory
        ISODir    string // Directory containing ISO file
        ISOFile   string // Path to the ISO file
        MKVDir    string // Directory containing MKV file(s)
        MKVFile   string // Path to the main MKV file
        Available bool   // True if all required files exist
}

// DefaultISOName is the expected ISO filename.
const DefaultISOName = "bbb-pal.iso"

// DefaultMKVPattern is the glob pattern for finding MKV files.
const DefaultMKVPattern = "*.mkv"

// Find locates the test data directory and checks for required files.
// It checks these locations in order:
//  1. $MKVDUP_TESTDATA environment variable
//  2. testdata/generated/ (relative to the testdata package, created by generate-test-data.sh)
//  3. ~/.cache/mkvdup/testdata/
//  4. /tmp/mkvdup-testdata/
//
// Returns Paths with Available=false if test data is not found.
func Find() Paths <span class="cov10" title="7">{
        var p Paths

        // Check environment variable first
        if envPath := os.Getenv("MKVDUP_TESTDATA"); envPath != "" </span><span class="cov10" title="7">{
                p.Root = envPath
                if checkPaths(&amp;p) </span><span class="cov10" title="7">{
                        return p
                }</span>
        }

        // Check testdata/generated/ (local to the repo, created by generate-test-data.sh)
        // This is the preferred location for reproducible test data
        <span class="cov0" title="0">if localPath := findLocalTestdataDir(); localPath != "" </span><span class="cov0" title="0">{
                p.Root = localPath
                if checkPaths(&amp;p) </span><span class="cov0" title="0">{
                        return p
                }</span>
        }

        // Check ~/.cache/mkvdup/testdata/
        <span class="cov0" title="0">if home, err := os.UserHomeDir(); err == nil </span><span class="cov0" title="0">{
                p.Root = filepath.Join(home, ".cache", "mkvdup", "testdata")
                if checkPaths(&amp;p) </span><span class="cov0" title="0">{
                        return p
                }</span>
        }

        // Check /tmp/mkvdup-testdata/
        <span class="cov0" title="0">p.Root = "/tmp/mkvdup-testdata"
        if checkPaths(&amp;p) </span><span class="cov0" title="0">{
                return p
        }</span>

        // Not found - clear all paths
        <span class="cov0" title="0">p.Root = ""
        p.ISODir = ""
        p.ISOFile = ""
        p.MKVDir = ""
        p.MKVFile = ""
        p.Available = false
        return p</span>
}

// checkPaths fills in the paths and returns true if all required files exist.
func checkPaths(p *Paths) bool <span class="cov10" title="7">{
        p.ISODir = filepath.Join(p.Root, "bigbuckbunny")
        p.MKVDir = filepath.Join(p.Root, "bigbuckbunny-mkv")

        // Check ISO file
        p.ISOFile = filepath.Join(p.ISODir, DefaultISOName)
        if _, err := os.Stat(p.ISOFile); err != nil </span><span class="cov0" title="0">{
                // Try NTSC variant
                p.ISOFile = filepath.Join(p.ISODir, "bbb-ntsc.iso")
                if _, err := os.Stat(p.ISOFile); err != nil </span><span class="cov0" title="0">{
                        p.Available = false
                        return false
                }</span>
        }

        // Find MKV file (first match)
        <span class="cov10" title="7">matches, err := filepath.Glob(filepath.Join(p.MKVDir, DefaultMKVPattern))
        if err != nil || len(matches) == 0 </span><span class="cov0" title="0">{
                p.Available = false
                return false
        }</span>
        <span class="cov10" title="7">p.MKVFile = matches[0]

        p.Available = true
        return true</span>
}

// SkipIfNotAvailable calls t.Skip if test data is not available.
// Use this at the start of integration tests.
func SkipIfNotAvailable(t interface{ Skip(...interface{}) }) Paths <span class="cov9" title="6">{
        p := Find()
        if !p.Available </span><span class="cov0" title="0">{
                t.Skip("Test data not available. See testdata/README.md for setup instructions.")
        }</span>
        <span class="cov9" title="6">return p</span>
}

// CreateBlurayData creates a Blu-ray directory structure by remuxing the MKV
// file to M2TS format using ffmpeg (copy codec, no re-encoding). The directory
// is created under tmpDir and has the layout BDMV/STREAM/00001.m2ts that
// DetectType recognises as TypeBluray.
//
// The test is skipped if ffmpeg is not available.
func (p Paths) CreateBlurayData(t testing.TB, tmpDir string) string <span class="cov1" title="1">{
        t.Helper()

        if _, err := exec.LookPath("ffmpeg"); err != nil </span><span class="cov0" title="0">{
                t.Skip("ffmpeg not available, skipping Blu-ray test")
        }</span>

        <span class="cov1" title="1">blurayRoot := filepath.Join(tmpDir, "bluray")
        streamDir := filepath.Join(blurayRoot, "BDMV", "STREAM")
        if err := os.MkdirAll(streamDir, 0755); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("CreateBlurayData: mkdir: %v", err)
        }</span>

        <span class="cov1" title="1">m2tsPath := filepath.Join(streamDir, "00001.m2ts")
        cmd := exec.Command("ffmpeg",
                "-loglevel", "error",
                "-i", p.MKVFile,
                "-c", "copy",
                "-f", "mpegts",
                "-y", // overwrite if exists
                m2tsPath,
        )
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("CreateBlurayData: ffmpeg remux failed: %v\n%s", err, output)
        }</span>

        <span class="cov1" title="1">return blurayRoot</span>
}

// findLocalTestdataDir returns the path to testdata/generated/ directory
// relative to this source file, or empty string if it cannot be determined.
func findLocalTestdataDir() string <span class="cov0" title="0">{
        _, filename, _, ok := runtime.Caller(0)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        // filename is the path to this file (testdata.go)
        // We want the "generated" subdirectory in the same directory
        <span class="cov0" title="0">dir := filepath.Dir(filename)
        return filepath.Join(dir, "generated")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
