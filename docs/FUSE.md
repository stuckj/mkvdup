# FUSE Filesystem

*Configuration and operation of the FUSE virtual filesystem.*

[Back to Architecture Overview](../DESIGN.md)

## Configuration Format

### Per-Mapping Config Files

Each dedup operation creates TWO files:
1. `.mkvdup` - The dedup data file (index + delta)
2. `.mkvdup.yaml` - Config file for this mapping

**Individual mapping config (video1.mkvdup.yaml):**

```yaml
# Auto-generated by mkvdup create
name: "Video1.mkv"
dedup_file: "/data/dedup/video1.mkvdup"
source_dir: "/data/sources/Video1_DVD"
```

**Path resolution:** Relative paths in `dedup_file` and `source_dir` are always resolved relative to the directory of the config file that **contains** them, not the current working directory. This applies equally to included configs — if config A includes config B, relative paths in B are resolved relative to B's directory, not A's. Absolute paths (starting with `/`) are used as-is.

### Config Files with Includes

Any config file can include other configs using glob patterns. This is not
limited to a special "master" config — any `.mkvdup.yaml` can use includes,
and included configs can themselves include others (recursive).

**Config with includes (/etc/mkvdup/mount.yaml):**

```yaml
# Include individual mapping configs
includes:
  - "/data/dedup/video1.mkvdup.yaml"
  - "/data/dedup/video2.mkvdup.yaml"
  - "/data/dedup/*.mkvdup.yaml"       # Simple glob patterns
  - "/isos/**/*.mkvdup.yaml"          # Recursive glob (** matches nested dirs)

# Can also define inline (optional)
virtual_files:
  - name: "Videos/Collection1/Video3.mkv"
    dedup_file: "/data/dedup/video3.mkvdup"
    source_dir: "/data/sources/Collection1_Bluray"
```

A config file can have any combination of:
- Top-level `name`/`dedup_file`/`source_dir` (single file definition, backward compatible)
- `includes` (glob patterns referencing other config files)
- `virtual_files` (inline list of file definitions)

**Include behavior:**
- **Relative include patterns** are resolved against the including config file's directory
- **Relative paths in included configs** (`dedup_file`, `source_dir`) are resolved against the included config's own directory — not the directory of the config that included it
- **Recursive globs** (`**`) are supported via the [doublestar](https://github.com/bmatcuk/doublestar) library
- **Cycle detection** prevents infinite recursion — if config A includes B and B includes A, each is processed only once
- **No matches** for a glob pattern is not an error (silently skipped)
- **Invalid included configs** produce an error

## Directory Structure

The FUSE filesystem presents a virtual directory tree. Directories are **auto-created** from path components in the `name` field of config files.

### Path-Based File Names

When a config file specifies a path in the `name` field:

```yaml
# video1.mkvdup.yaml
name: "Movies/Action/Video1.mkv"
dedup_file: "video1.mkvdup"
source_dir: "/data/sources/Video1_Bluray"
```

The filesystem automatically creates the directory hierarchy:

```
/mnt/media/                          (mountpoint)
├── standalone.mkv                   (file at root)
└── Movies/
    ├── Action/
    │   └── Video1.mkv               (virtual file)
    └── Comedy/
        └── Video2.mkv               (virtual file)
```

### Path Handling

The `name` field in config files supports directory paths. Path handling follows these rules:

- **Separator:** Only forward slashes (`/`) are treated as path separators
- **Leading slashes:** Stripped (absolute paths become relative within the mount)
- **Trailing slashes:** Stripped (`Movies/` becomes `Movies`)
- **Path normalization:** Multiple consecutive slashes are collapsed (`foo//bar` becomes `foo/bar`)
- **Current directory:** Single dots (`.`) are filtered out (`./Movies/./test.mkv` becomes `Movies/test.mkv`)
- **Parent directory:** Paths containing `..` components are **rejected** for security
- **Empty names:** Files with empty names are rejected

**Conflict resolution:**

- **Duplicate paths:** If multiple configs specify the same path, the later one wins (warning logged)
- **File/directory collision:** If a file and directory have the same name, the directory wins (file skipped with warning)

### Directory Properties

- **Auto-creation:** Directories are created automatically from path components
- **Read-only:** All directories return `EROFS` (Read-only file system) for write operations:
  - `mkdir`, `rmdir`, `unlink`, `create`, `rename`, `symlink`, `link`, `mknod`
- **Permissions:** Directories have mode `0555` (read + execute for all)
- **Virtual:** Directories exist only in the FUSE mount, not on disk

### OverlayFS Integration

The directory structure enables OverlayFS integration with existing media libraries.

**Scenario: Gradually migrate from full MKVs to deduplicated versions**

```bash
# Existing ZFS structure with full MKV files
/zfs/media/
├── Movies/
│   └── Action/
│       └── Video1.mkv  (3.4GB full file)

# mkvdup configs with matching paths
# video1.mkvdup.yaml:
name: "Movies/Action/Video1.mkv"

# Mount mkvdup
mkvdup mount --config /etc/mkvdup/*.yaml /mnt/mkvdup

# Layer with OverlayFS (mkvdup as lower, ZFS as upper)
mount -t overlay overlay \
  -o lowerdir=/mnt/mkvdup,upperdir=/zfs/media,workdir=/tmp/overlay \
  /merged/media

# Result: /merged/media shows ZFS files where they exist,
# falls back to mkvdup virtual files otherwise
```

**Migration workflow:**
1. Create mkvdup dedup files for your MKVs
2. Configure with paths matching your existing directory structure
3. Mount overlay with mkvdup as lower layer
4. Delete original MKV from ZFS when ready
5. Overlay automatically serves mkvdup virtual version

## Hot Reload via SIGHUP

The FUSE daemon supports live config reload without restart via SIGHUP:

**Using the reload command (recommended):**
```bash
# Validates config before sending signal
mkvdup reload --pid-file /run/mkvdup.pid /etc/mkvdup.conf
mkvdup reload --pid-file /run/mkvdup.pid --config-dir /etc/mkvdup.d/
```

**Using kill directly:**
```bash
# Send SIGHUP directly (daemon validates internally)
kill -HUP $(pidof mkvdup)
```

**On reload:**
- Config files are re-read from disk (includes and globs are re-expanded)
- If `--config-dir` was used at mount, the directory is re-scanned for new YAML files
- New virtual files become immediately available
- Removed virtual files become unavailable (active readers continue until close)
- Modified mappings: existing readers use old mapping until close
- Permissions file is reloaded from disk
- Stale permissions entries are cleaned up

**Validation and warnings:**
- If config resolution fails, the old config is kept and the error is logged
- Duplicate file paths, file/directory conflicts, and invalid paths are logged as warnings
- In daemon mode, warnings are logged to syslog (visible via `journalctl -t mkvdup`)

See [CLI reload command](CLI.md#reload) for more details.

### File-watch reload *(planned — [#10](https://github.com/stuckj/mkvdup/issues/10))*

> **Not yet implemented.** The following describes planned behavior.

- Daemon watches config file and include directories via inotify
- Automatically reloads when changes detected

## Permissions and Ownership

Virtual files and directories support `chmod` and `chown` operations. Permission metadata is stored in a separate YAML file, keeping `.mkvdup` files immutable while allowing customization.

### Access Checking

The filesystem uses the kernel's `default_permissions` mount option for access control. This means:

- **Standard Unix semantics:** Permission checks match the behavior of real filesystems (ext4, XFS, btrfs, etc.)
- **Supplementary groups:** The kernel properly checks all of a user's groups, not just their primary GID
- **Root bypass:** UID 0 bypasses all permission checks (standard Unix behavior)

Access is checked by the kernel based on the `uid`, `gid`, and `mode` reported for each file/directory. The filesystem reports these values from the permissions configuration.

### Ownership Changes

`chown` and `chmod` operations follow Unix semantics:

- **chown UID:** Only root can change file ownership
- **chown GID:** Root can change to any GID; file owner can change to any group they belong to (primary or supplementary)
- **chmod:** Only root or the file owner can change permissions

### Permissions File Location

**For root users - search order (first match wins):**
1. `--permissions-file PATH` command-line option
2. `~/.config/mkvdup/permissions.yaml` (if exists)
3. `/etc/mkvdup/permissions.yaml` (if exists, or as default)

**For non-root users - search order (first match wins):**
1. `--permissions-file PATH` command-line option
2. `~/.config/mkvdup/permissions.yaml` (existing or default)

Non-root users always use a user-writable path (`~/.config/...`) unless explicitly overridden with `--permissions-file`. This ensures that `chmod`/`chown` operations can save changes without `EACCES` errors.

**Default write location (when no file exists):**
- Running as root: `/etc/mkvdup/permissions.yaml`
- Running as non-root: `~/.config/mkvdup/permissions.yaml`

### Permissions File Format

```yaml
# ~/.config/mkvdup/permissions.yaml or /etc/mkvdup/permissions.yaml
# Auto-managed by mkvdup daemon (also human-editable)

defaults:
  file_uid: 1000
  file_gid: 1000
  file_mode: 0444
  dir_uid: 1000
  dir_gid: 1000
  dir_mode: 0555

files:
  "Videos/Video1.mkv":
    uid: 1000
    gid: 1001
    mode: 0640
  "Videos/Video2.mkv":
    mode: 0444  # inherits uid/gid from defaults

directories:
  "Movies":
    uid: 1000
    gid: 1000
    mode: 0755
  "Movies/Action":
    mode: 0755  # inherits uid/gid from defaults
```

**Field semantics:**
- `uid`, `gid`, `mode`: Only specified fields are overridden; `null` or omitted fields inherit from defaults
- Paths are relative to the mount root (no leading slash)
- Mode values are stored in octal

### CLI Options for Defaults

```bash
# Mount with custom default ownership
mkvdup mount --default-uid 1000 --default-gid 1000 /mnt/videos config.yaml

# Mount with custom file and directory modes
mkvdup mount --default-file-mode 0644 --default-dir-mode 0755 /mnt/videos config.yaml

# Specify explicit permissions file location
mkvdup mount --permissions-file /var/lib/mkvdup/permissions.yaml /mnt/videos config.yaml
```

### Behavior

**Default behavior (when file/directory not in permissions.yaml):**
1. Use defaults from command-line options if specified
2. For direct mounts (`mkvdup mount`): default to the calling user's UID/GID with mode `0444` for files, `0555` for directories
3. For fstab/systemd mounts: default to `root:root` (uid=0, gid=0) since the mount helper runs as root

**Note:** The fstab mount helper (`mount.fuse.mkvdup`) automatically enables `allow_other` so that root can access the filesystem for `chown`/`chmod` operations via `sudo`.

**On chmod/chown:**
1. Permission changes are saved immediately to the permissions file
2. The permissions file's parent directory (e.g., `~/.config/mkvdup/`) is created if it doesn't exist
3. Changes persist across daemon restarts

**On mount:**
1. Permissions file is loaded (or created with defaults)
2. Stale entries (for files/directories that no longer exist) are automatically removed

**On SIGHUP reload:**
1. Permissions file is reloaded from disk
2. Stale entries are cleaned up

## Memory Management

**Goal:** Keep memory footprint low even with many virtual files.

**Strategy: Lazy loading with reference counting**

Files are NOT memory-mapped at startup. Instead:

1. **On file open (FUSE Open):**
   - Increment reference count
   - If first open: memory-map the dedup file and source files
   - Parse index entries via `sync.Once` (thread-safe)

2. **On file close (FUSE Release):**
   - Decrement reference count
   - If count reaches 0: unmap all files

**Result:**
- At startup: Only config parsed, no files mapped
- During playback: Only active files are mapped
- After playback: Files unmapped, memory returned to OS
- 100 configured videos = ~0 memory if none are playing

**Optional:** Add a configurable grace period before unmapping (e.g., 30 seconds after close) to avoid repeated map/unmap for quick seeks.

## Multi-threading

go-fuse handles concurrent request processing automatically. Planned: configurable tuning via mount config.

**Benefits of multi-threading:**

| Scenario | Single-threaded | Multi-threaded |
|----------|-----------------|----------------|
| One video playing | OK | Same |
| Multiple videos playing | Serialized reads, stuttering | Parallel reads, smooth |
| Player read-ahead | Blocks other reads | Parallel prefetch |
| Multiple users | Poor | Good |

**Tuning guidance:**

| Workload | Recommended threads | Notes |
|----------|---------------------|-------|
| Single user, local playback | 2-4 | Low overhead |
| Media server (Jellyfin/Plex) | NumCPU | Multiple streams |
| NAS with many users | NumCPU * 2 | I/O bound |
| Low-power device | 1-2 | Reduce CPU usage |

## Health Checks *(planned — [#12](https://github.com/stuckj/mkvdup/issues/12))*

> **Not yet implemented.** The following describes planned behavior.

Optional background health monitoring:

```yaml
# In mount config
health_check:
  enabled: true
  interval: 1h           # Check every hour
  check_source_sizes: true
  check_source_checksums: false  # Too slow for routine checks
  on_error: warn         # warn, disable_file, or unmount
```

## Source File Watching

Source file monitoring detects changes to the underlying source media (DVD ISOs, Blu-ray M2TS files) and takes action to prevent serving corrupted data. Enabled by default.

### CLI Options

```bash
# Disable source file watching
mkvdup mount --no-source-watch /mnt/videos config.yaml

# Set action on source change (default: checksum)
mkvdup mount --on-source-change warn /mnt/videos config.yaml
```

### fstab Options

```
# Disable source watching
/etc/mkvdup.conf  /mnt/videos  fuse.mkvdup  no_source_watch  0  0

# With checksum verification
/etc/mkvdup.conf  /mnt/videos  fuse.mkvdup  on_source_change=checksum  0  0
```

### Actions

| Action | Behavior |
|--------|----------|
| `warn` | Log a warning with the source path and affected virtual files |
| `disable` | Disable affected virtual files (subsequent reads return `EIO`). File remains visible in directory listings. Reversible via SIGHUP reload. |
| `checksum` (default) | If the source file size changed, disable immediately. If only the timestamp changed (e.g., `touch`), verify the source checksum (xxhash) in the background while the file remains accessible. Disable only on checksum mismatch. If a subsequent checksum verification passes, the file is automatically re-enabled (useful for transient network glitches). Disabled files remain visible in directory listings and return `EIO` on read. Also reversible via SIGHUP reload. |

### How It Works

At mount time, source file metadata (path, size, checksum) is read from each dedup file header. A reverse mapping is built from source files to the virtual files that depend on them.

**Local filesystems:** Monitored via inotify (reacts to write, create, rename, and remove events).

**Network filesystems (NFS, CIFS/SMB):** inotify does not work on network mounts. The watcher automatically falls back to polling (stat every 60 seconds, comparing mtime).

**On SIGHUP reload:** The watcher rebuilds its source file mappings to match the new configuration. Old watches are removed and new ones are set up.

**Disabled files:** When a file is disabled (by `disable` action, size change in `checksum` mode, or checksum mismatch), its active reader is closed and subsequent `Open`/`Read` calls return `EIO`. The file remains visible in directory listings. In `checksum` mode, a subsequent successful verification automatically re-enables the file. For all modes, sending SIGHUP to reload the config resets the disabled state.

**Checksum queue:** Checksum verifications run sequentially in a single background worker to avoid I/O storms when many source files change at once. Duplicate events for the same source file are deduplicated.

## Error Handling

| Error | Impact | Recovery |
|-------|--------|----------|
| Dedup file missing | Virtual file unavailable | Return ENOENT |
| Dedup file corrupt | Virtual file unavailable | Return EIO, log error |
| Source file missing | Virtual file unavailable | Return EIO |
| Source file wrong size | Virtual file unavailable | Return EIO |
| Config file invalid | Mount/reload fails | Log error, keep old config |

When errors occur for a specific virtual file, other files remain accessible. Files with persistent errors automatically retry after a 5-minute cooldown period.

## inotify Events on Config Reload

When config is reloaded via SIGHUP (or `mkvdup reload`), the filesystem emits FUSE kernel notifications:

**Removed files:** `NotifyDelete` sends a real `IN_DELETE` inotify event. Applications watching the mountpoint (e.g., Jellyfin/Plex) will see the deletion immediately.

**Added files:** `NotifyEntry` invalidates the kernel's dentry cache, and `NotifyContent` invalidates the parent directory's readdir cache. New files are visible on the next directory listing or file access.

### FUSE protocol limitation

The FUSE kernel module does not support pushing `IN_CREATE` inotify events. The protocol has `FUSE_NOTIFY_DELETE` (sends inotify event) but no `FUSE_NOTIFY_CREATE`. This is a [known limitation](https://github.com/libfuse/libfuse/wiki/Fsnotify-and-FUSE) of the FUSE protocol — an [RFC for `FUSE_NOTIFY_FSNOTIFY`](https://patchwork.kernel.org/project/linux-fsdevel/cover/20211025204634.2517-1-iangelak@redhat.com/) was proposed in 2021 but never merged into mainline Linux.

**Recommendation:** Configure media servers to use periodic library scanning in addition to inotify watching. This ensures newly added files are detected even without a proactive `IN_CREATE` event.

## Related Documentation

- [CLI Commands](CLI.md) - Mount and reload commands
- [File Format](FILE_FORMAT.md) - Binary format being served
