# FUSE Filesystem

*Configuration and operation of the FUSE virtual filesystem.*

[Back to Architecture Overview](../DESIGN.md)

## Configuration Format

### Per-Mapping Config Files

Each dedup operation creates TWO files:
1. `.mkvdup` - The dedup data file (index + delta)
2. `.mkvdup.yaml` - Config file for this mapping

**Individual mapping config (video1.mkvdup.yaml):**

```yaml
# Auto-generated by mkvdup create
name: "Video1.mkv"
dedup_file: "/data/dedup/video1.mkvdup"
source_dir: "/data/sources/Video1_DVD"
```

**Path resolution:** Relative paths in `dedup_file` and `source_dir` are resolved relative to the config file's directory, not the current working directory. Absolute paths (starting with `/`) are used as-is.

### Master Config with Includes

**Main config (/etc/mkvdup/mount.yaml):**

```yaml
mountpoint: /mnt/media

# Include individual mapping configs
includes:
  - "/data/dedup/video1.mkvdup.yaml"
  - "/data/dedup/video2.mkvdup.yaml"
  - "/data/dedup/*.mkvdup.yaml"  # Glob patterns supported

# Can also define inline (optional)
virtual_files:
  - name: "Videos/Collection1/Video3.mkv"
    dedup_file: "/data/dedup/video3.mkvdup"
    source_dir: "/data/sources/Collection1_Bluray"
```

## Directory Structure

The FUSE filesystem presents a virtual directory tree. Directories are **auto-created** from path components in the `name` field of config files.

### Path-Based File Names

When a config file specifies a path in the `name` field:

```yaml
# video1.mkvdup.yaml
name: "Movies/Action/The Matrix.mkv"
dedup_file: "matrix.mkvdup"
source_dir: "/data/sources/Matrix_Bluray"
```

The filesystem automatically creates the directory hierarchy:

```
/mnt/media/                          (mountpoint)
├── standalone.mkv                   (file at root)
└── Movies/
    ├── Action/
    │   └── The Matrix.mkv           (virtual file)
    └── Comedy/
        └── The Hangover.mkv         (virtual file)
```

### Path Handling

The `name` field in config files supports directory paths. Path handling follows these rules:

- **Separator:** Only forward slashes (`/`) are treated as path separators
- **Leading slashes:** Stripped (absolute paths become relative within the mount)
- **Trailing slashes:** Stripped (`Movies/` becomes `Movies`)
- **Path normalization:** Multiple consecutive slashes are collapsed (`foo//bar` becomes `foo/bar`)
- **Current directory:** Single dots (`.`) are filtered out (`./Movies/./test.mkv` becomes `Movies/test.mkv`)
- **Parent directory:** Paths containing `..` components are **rejected** for security
- **Empty names:** Files with empty names are rejected

**Conflict resolution:**

- **Duplicate paths:** If multiple configs specify the same path, the later one wins (warning logged)
- **File/directory collision:** If a file and directory have the same name, the directory wins (file skipped with warning)

### Directory Properties

- **Auto-creation:** Directories are created automatically from path components
- **Read-only:** All directories return `EROFS` (Read-only file system) for write operations:
  - `mkdir`, `rmdir`, `unlink`, `create`, `rename`, `symlink`, `link`, `mknod`
- **Permissions:** Directories have mode `0555` (read + execute for all)
- **Virtual:** Directories exist only in the FUSE mount, not on disk

### OverlayFS Integration

The directory structure enables OverlayFS integration with existing media libraries.

**Scenario: Gradually migrate from full MKVs to deduplicated versions**

```bash
# Existing ZFS structure with full MKV files
/zfs/media/
├── Movies/
│   └── Action/
│       └── The Matrix.mkv  (3.4GB full file)

# mkvdup configs with matching paths
# matrix.mkvdup.yaml:
name: "Movies/Action/The Matrix.mkv"

# Mount mkvdup
mkvdup mount --config /etc/mkvdup/*.yaml /mnt/mkvdup

# Layer with OverlayFS (mkvdup as lower, ZFS as upper)
mount -t overlay overlay \
  -o lowerdir=/mnt/mkvdup,upperdir=/zfs/media,workdir=/tmp/overlay \
  /merged/media

# Result: /merged/media shows ZFS files where they exist,
# falls back to mkvdup virtual files otherwise
```

**Migration workflow:**
1. Create mkvdup dedup files for your MKVs
2. Configure with paths matching your existing directory structure
3. Mount overlay with mkvdup as lower layer
4. Delete original MKV from ZFS when ready
5. Overlay automatically serves mkvdup virtual version

## Hot Reload Support

The FUSE daemon supports live config reload without restart:

**Signal-based reload:**
```bash
# Send SIGHUP to reload config
kill -HUP $(pidof mkvdup)
```

**File-watch reload:**
- Daemon watches config file and include directories
- Automatically reloads when changes detected
- Uses inotify for efficient monitoring

**On reload:**
- New virtual files become immediately available
- Removed virtual files become unavailable (active readers continue until close)
- Modified mappings: existing readers use old mapping until close
- Stale permissions entries are cleaned up

## Permissions and Ownership

Virtual files support `chmod` and `chown` operations. Metadata is stored in a separate permissions file.

**Permissions file location:**
- Default: `~/.config/mkvdup/permissions.yaml`
- Configurable via `--permissions-file` or in mount config

**Permissions file format:**
```yaml
# Auto-managed by mkvdup daemon (also human-editable)
# Changes are picked up on SIGHUP reload

files:
  "Videos/Video1.mkv":
    uid: 1000
    gid: 1001
    mode: 0640
  "Videos/Video2.mkv":
    mode: 0444  # read-only, inherits uid/gid from defaults
```

**Default behavior (when file not in permissions.yaml):**
1. Use daemon defaults from config/command line if specified
2. Otherwise use `root:root` (uid=0, gid=0) with mode `0644`

**CLI/config options for defaults:**
```bash
# Mount with custom default ownership
mkvdup mount --config mount.yaml --default-uid 1000 --default-gid 1000 --default-mode 0644

# Or in mount config yaml
defaults:
  uid: 1000
  gid: 1000
  mode: 0644
  permissions_file: /var/lib/mkvdup/permissions.yaml
```

## Memory Management

**Goal:** Keep memory footprint low even with many virtual files.

**Strategy: Lazy loading with reference counting**

Files are NOT memory-mapped at startup. Instead:

1. **On file open (FUSE Open):**
   - Increment reference count
   - If first open: memory-map the dedup file and source files
   - Parse index entries via `sync.Once` (thread-safe)

2. **On file close (FUSE Release):**
   - Decrement reference count
   - If count reaches 0: unmap all files

**Result:**
- At startup: Only config parsed, no files mapped
- During playback: Only active files are mapped
- After playback: Files unmapped, memory returned to OS
- 100 configured videos = ~0 memory if none are playing

**Optional:** Add a configurable grace period before unmapping (e.g., 30 seconds after close) to avoid repeated map/unmap for quick seeks.

## Multi-threading

go-fuse supports multi-threaded operation for concurrent request handling:

```yaml
# In mount config
performance:
  threads: 0              # 0 = auto (NumCPU), or specify count
  read_ahead_kb: 128      # Kernel read-ahead buffer size
  max_background: 12      # Max background FUSE requests
  congestion_threshold: 9 # When to start throttling
```

**Benefits of multi-threading:**

| Scenario | Single-threaded | Multi-threaded |
|----------|-----------------|----------------|
| One video playing | OK | Same |
| Multiple videos playing | Serialized reads, stuttering | Parallel reads, smooth |
| Player read-ahead | Blocks other reads | Parallel prefetch |
| Multiple users | Poor | Good |

**Tuning guidance:**

| Workload | Recommended threads | Notes |
|----------|---------------------|-------|
| Single user, local playback | 2-4 | Low overhead |
| Media server (Jellyfin/Plex) | NumCPU | Multiple streams |
| NAS with many users | NumCPU * 2 | I/O bound |
| Low-power device | 1-2 | Reduce CPU usage |

## Health Checks

Optional background health monitoring:

```yaml
# In mount config
health_check:
  enabled: true
  interval: 1h           # Check every hour
  check_source_sizes: true
  check_source_checksums: false  # Too slow for routine checks
  on_error: warn         # warn, disable_file, or unmount
```

## Source File Watching

Optional inotify-based monitoring of source files:

```yaml
# In mount config
source_watch:
  enabled: true
  on_change: checksum    # checksum, disable_file, or warn
  checksum_threads: 2    # Parallel checksum workers
```

**On source file change:**
- `warn`: Log warning only
- `disable_file`: Mark affected virtual files as unavailable
- `checksum`: Verify source file checksum, disable if changed

## Error Handling

| Error | Impact | Recovery |
|-------|--------|----------|
| Dedup file missing | Virtual file unavailable | Return ENOENT |
| Dedup file corrupt | Virtual file unavailable | Return EIO, log error |
| Source file missing | Virtual file unavailable | Return EIO |
| Source file wrong size | Virtual file unavailable | Return EIO |
| Config file invalid | Mount/reload fails | Log error, keep old config |

When errors occur for a specific virtual file, other files remain accessible. Files with persistent errors automatically retry after a 5-minute cooldown period.

## inotify Events

The FUSE filesystem emits standard inotify events when the config is reloaded:
- `IN_CREATE` for added files
- `IN_DELETE` for removed files

Applications watching the mountpoint (e.g., Jellyfin/Plex) will automatically detect changes.

## Related Documentation

- [CLI Commands](CLI.md) - Mount and reload commands
- [File Format](FILE_FORMAT.md) - Binary format being served
