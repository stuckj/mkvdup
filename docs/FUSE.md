# FUSE Filesystem

*Configuration and operation of the FUSE virtual filesystem.*

[Back to Architecture Overview](../DESIGN.md)

## Configuration Format

### Per-Mapping Config Files

Each dedup operation creates TWO files:
1. `.mkvdup` - The dedup data file (index + delta)
2. `.mkvdup.yaml` - Config file for this mapping

**Individual mapping config (video1.mkvdup.yaml):**

```yaml
# Auto-generated by mkvdup create
name: "Video1.mkv"
dedup_file: "/data/dedup/video1.mkvdup"
source_dir: "/data/sources/Video1_DVD"
```

**Path resolution:** Relative paths in `dedup_file` and `source_dir` are always resolved relative to the directory of the config file that **contains** them, not the current working directory. This applies equally to included configs — if config A includes config B, relative paths in B are resolved relative to B's directory, not A's. Absolute paths (starting with `/`) are used as-is.

### Config Files with Includes

Any config file can include other configs using glob patterns. This is not
limited to a special "master" config — any `.mkvdup.yaml` can use includes,
and included configs can themselves include others (recursive).

**Config with includes (/etc/mkvdup/mount.yaml):**

```yaml
# Include individual mapping configs
includes:
  - "/data/dedup/video1.mkvdup.yaml"
  - "/data/dedup/video2.mkvdup.yaml"
  - "/data/dedup/*.mkvdup.yaml"       # Simple glob patterns
  - "/isos/**/*.mkvdup.yaml"          # Recursive glob (** matches nested dirs)

# Can also define inline (optional)
virtual_files:
  - name: "Videos/Collection1/Video3.mkv"
    dedup_file: "/data/dedup/video3.mkvdup"
    source_dir: "/data/sources/Collection1_Bluray"
```

A config file can have any combination of:
- Top-level `name`/`dedup_file`/`source_dir` (single file definition, backward compatible)
- `includes` (glob patterns referencing other config files)
- `virtual_files` (inline list of file definitions)

**Include behavior:**
- **Relative include patterns** are resolved against the including config file's directory
- **Relative paths in included configs** (`dedup_file`, `source_dir`) are resolved against the included config's own directory — not the directory of the config that included it
- **Recursive globs** (`**`) are supported via the [doublestar](https://github.com/bmatcuk/doublestar) library
- **Cycle detection** prevents infinite recursion — if config A includes B and B includes A, each is processed only once
- **No matches** for a glob pattern is not an error (silently skipped)
- **Invalid included configs** produce an error

### Mount-Level Settings

Some settings apply to the entire mount rather than individual virtual files. These are configured in YAML config files and use **first-wins** semantics — if multiple config files (including via `includes`) specify the same mount-level setting, the first one encountered during depth-first resolution is used.

**Error notification (`on_error_command`):**

```yaml
# In any .mkvdup.yaml config file
on_error_command:
  command: ["curl", "-d", "Source: %source% Event: %event% Files: %files%", "https://ntfy.sh/mkvdup"]
  timeout: 30s         # default: 30s
  batch_interval: 5s   # default: 5s; collect events before firing
```

Or string form (executed via `sh -c`):
```yaml
on_error_command:
  command: "curl -d 'Source issue: %source%' https://ntfy.sh/mkvdup"
```

See [Error Notification](#error-notification) for full details on placeholders and behavior.

## Directory Structure

The FUSE filesystem presents a virtual directory tree. Directories are **auto-created** from path components in the `name` field of config files.

### Path-Based File Names

When a config file specifies a path in the `name` field:

```yaml
# video1.mkvdup.yaml
name: "Movies/Action/Video1.mkv"
dedup_file: "video1.mkvdup"
source_dir: "/data/sources/Video1_Bluray"
```

The filesystem automatically creates the directory hierarchy:

```
/mnt/media/                          (mountpoint)
├── standalone.mkv                   (file at root)
└── Movies/
    ├── Action/
    │   └── Video1.mkv               (virtual file)
    └── Comedy/
        └── Video2.mkv               (virtual file)
```

### Path Handling

The `name` field in config files supports directory paths. Path handling follows these rules:

- **Separator:** Only forward slashes (`/`) are treated as path separators
- **Leading slashes:** Stripped (absolute paths become relative within the mount)
- **Trailing slashes:** Stripped (`Movies/` becomes `Movies`)
- **Path normalization:** Multiple consecutive slashes are collapsed (`foo//bar` becomes `foo/bar`)
- **Current directory:** Single dots (`.`) are filtered out (`./Movies/./test.mkv` becomes `Movies/test.mkv`)
- **Parent directory:** Paths containing `..` components are **rejected** for security
- **Empty names:** Files with empty names are rejected

**Conflict resolution:**

- **Duplicate paths:** If multiple configs specify the same path, the later one wins (warning logged)
- **File/directory collision:** If a file and directory have the same name, the directory wins (file skipped with warning)

### Directory Properties

- **Auto-creation:** Directories are created automatically from path components
- **Read-only:** All directories return `EROFS` (Read-only file system) for write operations:
  - `mkdir`, `rmdir`, `unlink`, `create`, `rename`, `symlink`, `link`, `mknod`
- **Permissions:** Directories have mode `0555` (read + execute for all)
- **Virtual:** Directories exist only in the FUSE mount, not on disk

### OverlayFS Integration

The directory structure enables OverlayFS integration with existing media libraries.

**Scenario: Gradually migrate from full MKVs to deduplicated versions**

```bash
# Existing ZFS structure with full MKV files
/zfs/media/
├── Movies/
│   └── Action/
│       └── Video1.mkv  (3.4GB full file)

# mkvdup configs with matching paths
# video1.mkvdup.yaml:
name: "Movies/Action/Video1.mkv"

# Mount mkvdup
mkvdup mount --config /etc/mkvdup/*.yaml /mnt/mkvdup

# Layer with OverlayFS (mkvdup as lower, ZFS as upper)
mount -t overlay overlay \
  -o lowerdir=/mnt/mkvdup,upperdir=/zfs/media,workdir=/tmp/overlay \
  /merged/media

# Result: /merged/media shows ZFS files where they exist,
# falls back to mkvdup virtual files otherwise
```

**Migration workflow:**
1. Create mkvdup dedup files for your MKVs
2. Configure with paths matching your existing directory structure
3. Mount overlay with mkvdup as lower layer
4. Delete original MKV from ZFS when ready
5. Overlay automatically serves mkvdup virtual version

## Hot Reload via SIGHUP

The FUSE daemon supports live config reload without restart via SIGHUP:

**Using the reload command (recommended):**
```bash
# Validates config before sending signal
mkvdup reload --pid-file /run/mkvdup.pid /etc/mkvdup.conf
mkvdup reload --pid-file /run/mkvdup.pid --config-dir /etc/mkvdup.d/

# Use --pid directly (e.g., foreground mode without a PID file)
mkvdup reload --pid $(pidof mkvdup) /etc/mkvdup.conf
```

**Using kill directly:**
```bash
# Send SIGHUP directly (daemon validates internally)
kill -HUP $(pidof mkvdup)
```

**On reload:**
- Config files are re-read from disk (includes and globs are re-expanded)
- If `--config-dir` was used at mount, the directory is re-scanned for new YAML files
- New virtual files become immediately available
- Removed virtual files become unavailable (active readers continue until close)
- Modified mappings: existing readers use old mapping until close
- Permissions file is reloaded from disk
- Stale permissions entries are cleaned up

**Validation and warnings:**
- If config resolution fails, the old config is kept and the error is logged
- Duplicate file paths, file/directory conflicts, and invalid paths are logged as warnings
- In daemon mode, warnings are logged to syslog (visible via `journalctl -t mkvdup`)

See [CLI reload command](CLI.md#reload) for more details.

### File-watch reload *(planned — [#10](https://github.com/stuckj/mkvdup/issues/10))*

> **Not yet implemented.** The following describes planned behavior.

- Daemon watches config file and include directories via inotify
- Automatically reloads when changes detected

## Permissions and Ownership

Virtual files and directories support `chmod` and `chown` operations. Permission metadata is stored in a separate YAML file, keeping `.mkvdup` files immutable while allowing customization.

### Access Checking

The filesystem uses the kernel's `default_permissions` mount option for access control. This means:

- **Standard Unix semantics:** Permission checks match the behavior of real filesystems (ext4, XFS, btrfs, etc.)
- **Supplementary groups:** The kernel properly checks all of a user's groups, not just their primary GID
- **Root bypass:** UID 0 bypasses all permission checks (standard Unix behavior)

Access is checked by the kernel based on the `uid`, `gid`, and `mode` reported for each file/directory. The filesystem reports these values from the permissions configuration.

### Ownership Changes

`chown` and `chmod` operations follow Unix semantics:

- **chown UID:** Only root can change file ownership
- **chown GID:** Root can change to any GID; file owner can change to any group they belong to (primary or supplementary)
- **chmod:** Only root or the file owner can change permissions

### Permissions File Location

**For root users - search order (first match wins):**
1. `--permissions-file PATH` command-line option
2. `~/.config/mkvdup/permissions.yaml` (if exists)
3. `/etc/mkvdup/permissions.yaml` (if exists, or as default)

**For non-root users - search order (first match wins):**
1. `--permissions-file PATH` command-line option
2. `~/.config/mkvdup/permissions.yaml` (existing or default)

Non-root users always use a user-writable path (`~/.config/...`) unless explicitly overridden with `--permissions-file`. This ensures that `chmod`/`chown` operations can save changes without `EACCES` errors.

**Default write location (when no file exists):**
- Running as root: `/etc/mkvdup/permissions.yaml`
- Running as non-root: `~/.config/mkvdup/permissions.yaml`

### Permissions File Format

```yaml
# ~/.config/mkvdup/permissions.yaml or /etc/mkvdup/permissions.yaml
# Auto-managed by mkvdup daemon (also human-editable)

defaults:
  file_uid: 1000
  file_gid: 1000
  file_mode: 0444
  dir_uid: 1000
  dir_gid: 1000
  dir_mode: 0555

files:
  "Videos/Video1.mkv":
    uid: 1000
    gid: 1001
    mode: 0640
  "Videos/Video2.mkv":
    mode: 0444  # inherits uid/gid from defaults

directories:
  "Movies":
    uid: 1000
    gid: 1000
    mode: 0755
  "Movies/Action":
    mode: 0755  # inherits uid/gid from defaults
```

**Field semantics:**
- `uid`, `gid`, `mode`: Only specified fields are overridden; `null` or omitted fields inherit from defaults
- Paths are relative to the mount root (no leading slash)
- Mode values are stored in octal

### CLI Options for Defaults

```bash
# Mount with custom default ownership
mkvdup mount --default-uid 1000 --default-gid 1000 /mnt/videos config.yaml

# Mount with custom file and directory modes
mkvdup mount --default-file-mode 0644 --default-dir-mode 0755 /mnt/videos config.yaml

# Specify explicit permissions file location
mkvdup mount --permissions-file /var/lib/mkvdup/permissions.yaml /mnt/videos config.yaml
```

### Behavior

**Default behavior (when file/directory not in permissions.yaml):**
1. Use defaults from command-line options if specified
2. For direct mounts (`mkvdup mount`): default to the calling user's UID/GID with mode `0444` for files, `0555` for directories
3. For fstab/systemd mounts: default to `root:root` (uid=0, gid=0) since the mount helper runs as root

**Note:** The fstab mount helper (`mount.fuse.mkvdup`) automatically enables `allow_other` so that root can access the filesystem for `chown`/`chmod` operations via `sudo`.

**On chmod/chown:**
1. Permission changes are saved immediately to the permissions file
2. The permissions file's parent directory (e.g., `~/.config/mkvdup/`) is created if it doesn't exist
3. Changes persist across daemon restarts

**On mount:**
1. Permissions file is loaded (or created with defaults)
2. Stale entries (for files/directories that no longer exist) are automatically removed

**On SIGHUP reload:**
1. Permissions file is reloaded from disk
2. Stale entries are cleaned up

## Memory Management

**Goal:** Keep memory footprint low even with many virtual files.

**Strategy: Lazy loading with reference counting**

Files are NOT memory-mapped at startup. Instead:

1. **On file open (FUSE Open):**
   - Increment reference count
   - If first open: memory-map the dedup file and source files
   - Parse index entries via `sync.Once` (thread-safe)

2. **On file close (FUSE Release):**
   - Decrement reference count
   - If count reaches 0: unmap all files

**Result:**
- At startup: Only config parsed, no files mapped
- During playback: Only active files are mapped
- After playback: Files unmapped, memory returned to OS
- 100 configured videos = ~0 memory if none are playing

**Optional:** Add a configurable grace period before unmapping (e.g., 30 seconds after close) to avoid repeated map/unmap for quick seeks.

## Multi-threading

go-fuse handles concurrent request processing automatically. Planned: configurable tuning via mount config.

**Benefits of multi-threading:**

| Scenario | Single-threaded | Multi-threaded |
|----------|-----------------|----------------|
| One video playing | OK | Same |
| Multiple videos playing | Serialized reads, stuttering | Parallel reads, smooth |
| Player read-ahead | Blocks other reads | Parallel prefetch |
| Multiple users | Poor | Good |

**Tuning guidance:**

| Workload | Recommended threads | Notes |
|----------|---------------------|-------|
| Single user, local playback | 2-4 | Low overhead |
| Media server (Jellyfin/Plex) | NumCPU | Multiple streams |
| NAS with many users | NumCPU * 2 | I/O bound |
| Low-power device | 1-2 | Reduce CPU usage |

## Source File Watching

Source file monitoring detects changes to the underlying source media (DVD ISOs, Blu-ray M2TS files) and takes action to prevent serving corrupted data. Enabled by default.

### CLI Options

```bash
# Disable source file watching
mkvdup mount --no-source-watch /mnt/videos config.yaml

# Set action on source change (default: checksum)
mkvdup mount --on-source-change warn /mnt/videos config.yaml

# Reduce poll interval for faster change detection on network FS
mkvdup mount --source-watch-poll-interval 10s /mnt/videos config.yaml

# Set a read timeout for slow network links
mkvdup mount --source-read-timeout 1m /mnt/videos config.yaml
```

### fstab Options

```
# Disable source watching
/etc/mkvdup.conf  /mnt/videos  fuse.mkvdup  no_source_watch  0  0

# With checksum verification
/etc/mkvdup.conf  /mnt/videos  fuse.mkvdup  on_source_change=checksum  0  0

# Network source options
/etc/mkvdup.conf  /mnt/videos  fuse.mkvdup  source_watch_poll_interval=10s,source_read_timeout=30s  0  0

# Write PID file (for use with mkvdup reload --pid-file)
/etc/mkvdup.conf  /mnt/videos  fuse.mkvdup  pid_file=/run/mkvdup.pid  0  0
```

### Actions

| Action | Behavior |
|--------|----------|
| `warn` | Log a warning with the source path and affected virtual files |
| `disable` | Disable affected virtual files (subsequent reads return `EIO`). File remains visible in directory listings. Reversible via SIGHUP reload. |
| `checksum` (default) | If the source file size changed, disable immediately. If only the timestamp changed (e.g., `touch`), verify the source checksum (xxhash) in the background while the file remains accessible. Disable only on checksum mismatch. If a subsequent checksum verification passes, the file is automatically re-enabled (useful for transient network glitches). Disabled files remain visible in directory listings and return `EIO` on read. Also reversible via SIGHUP reload. |

### How It Works

At mount time, source file metadata (path, size, checksum) is read from each dedup file header. A reverse mapping is built from source files to the virtual files that depend on them.

**Local filesystems:** Monitored via inotify (reacts to write, create, rename, and remove events).

**Network filesystems (NFS, CIFS/SMB):** inotify does not work on network mounts. The watcher automatically falls back to polling (stat at a configurable interval, default 60 seconds, comparing mtime). Source file reads on network filesystems use `pread(2)` instead of `mmap()` to avoid SIGBUS crashes, with automatic retry on transient errors (ESTALE, ETIMEDOUT, etc.) and stale file handle recovery.

**On SIGHUP reload:** The watcher rebuilds its source file mappings to match the new configuration. Old watches are removed and new ones are set up.

**Disabled files:** When a file is disabled (by `disable` action, size change in `checksum` mode, or checksum mismatch), its active reader is closed and subsequent `Open`/`Read` calls return `EIO`. The file remains visible in directory listings. In `checksum` mode, a subsequent successful verification automatically re-enables the file. For all modes, sending SIGHUP to reload the config resets the disabled state.

**Checksum queue:** Checksum verifications run sequentially in a single background worker to avoid I/O storms when many source files change at once. Duplicate events for the same source file are deduplicated.

### Error Notification

When the source watcher detects an integrity issue, it can execute an external command to send notifications (webhooks, emails, scripts, etc.). This is configured via `on_error_command` in a YAML config file (see [Mount-Level Settings](#mount-level-settings)).

**Configuration:**

```yaml
on_error_command:
  command: ["curl", "-X", "POST", "-d", "Source: %source%\nEvent: %event%\nFiles: %files%", "https://ntfy.sh/mkvdup"]
  timeout: 30s         # max execution time (default: 30s)
  batch_interval: 5s   # event collection window (default: 5s)
```

| Field | Default | Description |
|-------|---------|-------------|
| `command` | *(required)* | Command to execute. String (runs via `sh -c`) or list of strings (exec directly). |
| `timeout` | `30s` | Maximum time the command may run before being killed. |
| `batch_interval` | `5s` | Time window to collect events before firing the command. Resets on each new event. |

**Placeholders:**

| Placeholder | Single Event | Batched Events |
|-------------|-------------|----------------|
| `%source%` | Absolute path of the changed source file | Newline-separated list of source paths (deduplicated) |
| `%files%` | Comma-separated list of affected virtual file names | Comma-separated list (deduplicated across all events) |
| `%event%` | Event type (see below) | Newline-separated list of `source_path: event_type` pairs |

**Event types:**

| Event | Trigger |
|-------|---------|
| `changed` | Source file modified (warn/disable mode) |
| `missing` | Source file no longer exists |
| `size_changed` | Source file size differs from expected |
| `checksum_mismatch` | Source file checksum differs from expected |
| `checksum_queue_full` | Too many pending checksum verifications |

**Batching behavior:** Events are collected for the configured `batch_interval`. Each new event resets the timer. When the timer expires, the command is executed once with all accumulated events. This prevents notification storms when a single change affects many virtual files.

**Error handling:** Command failures are logged but do not affect mount operation. The command runs asynchronously and does not block the watcher.

**Examples:**

```yaml
# Send a push notification via ntfy.sh
on_error_command:
  command: "curl -d '%event%: %source%' https://ntfy.sh/mkvdup-alerts"

# Run a custom notification script
on_error_command:
  command: ["/usr/local/bin/mkvdup-notify.sh", "%source%", "%event%", "%files%"]
  timeout: 10s
  batch_interval: 10s

# Send email via mailx
on_error_command:
  command: "echo 'Source integrity issue:\n%source%\n\nEvent: %event%\nAffected files: %files%' | mailx -s 'mkvdup alert' admin@example.com"
  batch_interval: 30s
```

## Network Source Support

When source media is stored on network filesystems (NFS, CIFS/SMB), mkvdup automatically uses `pread(2)` instead of `mmap()` for source file access. This provides:

- Graceful error handling instead of SIGBUS crashes
- Automatic retry on transient errors (ESTALE, ETIMEDOUT, ECONNRESET, EIO)
- Stale file handle recovery (automatic fd reopen)
- Configurable read timeout

Network filesystem detection is automatic — no configuration is needed. Local filesystems continue using `mmap()` for zero-copy performance.

### Options

| Flag | fstab Option | Default | Description |
|------|-------------|---------|-------------|
| `--source-read-timeout DUR` | `source_read_timeout=DUR` | 30s | Timeout for individual source file reads on network FS |
| `--source-watch-poll-interval DUR` | `source_watch_poll_interval=DUR` | 60s | Polling interval for detecting source file changes |

### Examples

```bash
# Mount with sources on NFS (pread auto-detected)
mkvdup mount /mnt/videos config.yaml

# Reduce poll interval for faster change detection on network FS
mkvdup mount --source-watch-poll-interval 10s /mnt/videos config.yaml

# Set a read timeout for slow network links
mkvdup mount --source-read-timeout 1m /mnt/videos config.yaml

# fstab with network source options
/etc/mkvdup.conf  /mnt/videos  fuse.mkvdup  source_watch_poll_interval=10s,source_read_timeout=30s  0  0
```

## Error Handling

| Error | Impact | Recovery |
|-------|--------|----------|
| Dedup file missing | Virtual file unavailable | Return ENOENT |
| Dedup file corrupt | Virtual file unavailable | Return EIO, log error |
| Source file missing | Virtual file unavailable | Return EIO |
| Source file wrong size | Virtual file unavailable | Return EIO |
| Config file invalid | Mount/reload fails | Log error, keep old config |

When errors occur for a specific virtual file, other files remain accessible. Files with persistent errors automatically retry after a 5-minute cooldown period.

## inotify Events on Config Reload

When config is reloaded via SIGHUP (or `mkvdup reload`), the filesystem emits FUSE kernel notifications:

**Removed files:** `NotifyDelete` sends a real `IN_DELETE` inotify event. Applications watching the mountpoint (e.g., Jellyfin/Plex) will see the deletion immediately.

**Added files:** `NotifyEntry` invalidates the kernel's dentry cache, and `NotifyContent` invalidates the parent directory's readdir cache. New files are visible on the next directory listing or file access.

### FUSE protocol limitation

The FUSE kernel module does not support pushing `IN_CREATE` inotify events. The protocol has `FUSE_NOTIFY_DELETE` (sends inotify event) but no `FUSE_NOTIFY_CREATE`. This is a [known limitation](https://github.com/libfuse/libfuse/wiki/Fsnotify-and-FUSE) of the FUSE protocol — an [RFC for `FUSE_NOTIFY_FSNOTIFY`](https://patchwork.kernel.org/project/linux-fsdevel/cover/20211025204634.2517-1-iangelak@redhat.com/) was proposed in 2021 but never merged into mainline Linux.

**Recommendation:** Configure media servers to use periodic library scanning in addition to inotify watching. This ensures newly added files are detected even without a proactive `IN_CREATE` event.

## Related Documentation

- [CLI Commands](CLI.md) - Mount and reload commands
- [File Format](FILE_FORMAT.md) - Binary format being served
