# FUSE Filesystem

*Configuration and operation of the FUSE virtual filesystem.*

[Back to Architecture Overview](../DESIGN.md)

## Configuration Format

### Per-Mapping Config Files

Each dedup operation creates TWO files:
1. `.mkvdup` - The dedup data file (index + delta)
2. `.mkvdup.yaml` - Config file for this mapping

**Individual mapping config (video1.mkvdup.yaml):**

```yaml
# Auto-generated by mkvdup create
name: "Video1.mkv"
dedup_file: "/data/dedup/video1.mkvdup"
source_dir: "/data/sources/Video1_DVD"
```

**Path resolution:** Relative paths in `dedup_file` and `source_dir` are resolved relative to the config file's directory, not the current working directory. Absolute paths (starting with `/`) are used as-is.

### Master Config with Includes

**Main config (/etc/mkvdup/mount.yaml):**

```yaml
mountpoint: /mnt/media

# Include individual mapping configs
includes:
  - "/data/dedup/video1.mkvdup.yaml"
  - "/data/dedup/video2.mkvdup.yaml"
  - "/data/dedup/*.mkvdup.yaml"  # Glob patterns supported

# Can also define inline (optional)
virtual_files:
  - name: "Videos/Collection1/Video3.mkv"
    dedup_file: "/data/dedup/video3.mkvdup"
    source_dir: "/data/sources/Collection1_Bluray"
```

## Directory Structure

The FUSE filesystem presents a virtual directory tree. Directories are **auto-created** from path components in the `name` field of config files.

### Path-Based File Names

When a config file specifies a path in the `name` field:

```yaml
# video1.mkvdup.yaml
name: "Movies/Action/Video1.mkv"
dedup_file: "video1.mkvdup"
source_dir: "/data/sources/Video1_Bluray"
```

The filesystem automatically creates the directory hierarchy:

```
/mnt/media/                          (mountpoint)
├── standalone.mkv                   (file at root)
└── Movies/
    ├── Action/
    │   └── Video1.mkv               (virtual file)
    └── Comedy/
        └── Video2.mkv               (virtual file)
```

### Path Handling

The `name` field in config files supports directory paths. Path handling follows these rules:

- **Separator:** Only forward slashes (`/`) are treated as path separators
- **Leading slashes:** Stripped (absolute paths become relative within the mount)
- **Trailing slashes:** Stripped (`Movies/` becomes `Movies`)
- **Path normalization:** Multiple consecutive slashes are collapsed (`foo//bar` becomes `foo/bar`)
- **Current directory:** Single dots (`.`) are filtered out (`./Movies/./test.mkv` becomes `Movies/test.mkv`)
- **Parent directory:** Paths containing `..` components are **rejected** for security
- **Empty names:** Files with empty names are rejected

**Conflict resolution:**

- **Duplicate paths:** If multiple configs specify the same path, the later one wins (warning logged)
- **File/directory collision:** If a file and directory have the same name, the directory wins (file skipped with warning)

### Directory Properties

- **Auto-creation:** Directories are created automatically from path components
- **Read-only:** All directories return `EROFS` (Read-only file system) for write operations:
  - `mkdir`, `rmdir`, `unlink`, `create`, `rename`, `symlink`, `link`, `mknod`
- **Permissions:** Directories have mode `0555` (read + execute for all)
- **Virtual:** Directories exist only in the FUSE mount, not on disk

### OverlayFS Integration

The directory structure enables OverlayFS integration with existing media libraries.

**Scenario: Gradually migrate from full MKVs to deduplicated versions**

```bash
# Existing ZFS structure with full MKV files
/zfs/media/
├── Movies/
│   └── Action/
│       └── Video1.mkv  (3.4GB full file)

# mkvdup configs with matching paths
# video1.mkvdup.yaml:
name: "Movies/Action/Video1.mkv"

# Mount mkvdup
mkvdup mount --config /etc/mkvdup/*.yaml /mnt/mkvdup

# Layer with OverlayFS (mkvdup as lower, ZFS as upper)
mount -t overlay overlay \
  -o lowerdir=/mnt/mkvdup,upperdir=/zfs/media,workdir=/tmp/overlay \
  /merged/media

# Result: /merged/media shows ZFS files where they exist,
# falls back to mkvdup virtual files otherwise
```

**Migration workflow:**
1. Create mkvdup dedup files for your MKVs
2. Configure with paths matching your existing directory structure
3. Mount overlay with mkvdup as lower layer
4. Delete original MKV from ZFS when ready
5. Overlay automatically serves mkvdup virtual version

## Hot Reload Support *(planned — [#8](https://github.com/stuckj/mkvdup/issues/8), [#10](https://github.com/stuckj/mkvdup/issues/10))*

> **Not yet implemented.** The following describes planned behavior.

The FUSE daemon will support live config reload without restart:

**Signal-based reload:**
```bash
# Send SIGHUP to reload config
kill -HUP $(pidof mkvdup)
```

**File-watch reload:**
- Daemon watches config file and include directories
- Automatically reloads when changes detected
- Uses inotify for efficient monitoring

**On reload:**
- New virtual files become immediately available
- Removed virtual files become unavailable (active readers continue until close)
- Modified mappings: existing readers use old mapping until close
- Stale permissions entries are cleaned up

## Permissions and Ownership

Virtual files and directories support `chmod` and `chown` operations. Permission metadata is stored in a separate YAML file, keeping `.mkvdup` files immutable while allowing customization.

### Access Checking

The filesystem uses the kernel's `default_permissions` mount option for access control. This means:

- **Standard Unix semantics:** Permission checks match the behavior of real filesystems (ext4, XFS, btrfs, etc.)
- **Supplementary groups:** The kernel properly checks all of a user's groups, not just their primary GID
- **Root bypass:** UID 0 bypasses all permission checks (standard Unix behavior)

Access is checked by the kernel based on the `uid`, `gid`, and `mode` reported for each file/directory. The filesystem reports these values from the permissions configuration.

### Ownership Changes

`chown` and `chmod` operations follow Unix semantics:

- **chown UID:** Only root can change file ownership
- **chown GID:** Root can change to any GID; file owner can only change to their own primary GID
- **chmod:** Only root or the file owner can change permissions

### Permissions File Location

**For root users - search order (first match wins):**
1. `--permissions-file PATH` command-line option
2. `~/.config/mkvdup/permissions.yaml` (if exists)
3. `/etc/mkvdup/permissions.yaml` (if exists, or as default)

**For non-root users - search order (first match wins):**
1. `--permissions-file PATH` command-line option
2. `~/.config/mkvdup/permissions.yaml` (existing or default)

Non-root users always use a user-writable path (`~/.config/...`) unless explicitly overridden with `--permissions-file`. This ensures that `chmod`/`chown` operations can save changes without `EACCES` errors.

**Default write location (when no file exists):**
- Running as root: `/etc/mkvdup/permissions.yaml`
- Running as non-root: `~/.config/mkvdup/permissions.yaml`

### Permissions File Format

```yaml
# ~/.config/mkvdup/permissions.yaml or /etc/mkvdup/permissions.yaml
# Auto-managed by mkvdup daemon (also human-editable)

defaults:
  file_uid: 1000
  file_gid: 1000
  file_mode: 0444
  dir_uid: 1000
  dir_gid: 1000
  dir_mode: 0555

files:
  "Videos/Video1.mkv":
    uid: 1000
    gid: 1001
    mode: 0640
  "Videos/Video2.mkv":
    mode: 0444  # inherits uid/gid from defaults

directories:
  "Movies":
    uid: 1000
    gid: 1000
    mode: 0755
  "Movies/Action":
    mode: 0755  # inherits uid/gid from defaults
```

**Field semantics:**
- `uid`, `gid`, `mode`: Only specified fields are overridden; `null` or omitted fields inherit from defaults
- Paths are relative to the mount root (no leading slash)
- Mode values are stored in octal

### CLI Options for Defaults

```bash
# Mount with custom default ownership
mkvdup mount --default-uid 1000 --default-gid 1000 /mnt/videos config.yaml

# Mount with custom file and directory modes
mkvdup mount --default-file-mode 0644 --default-dir-mode 0755 /mnt/videos config.yaml

# Specify explicit permissions file location
mkvdup mount --permissions-file /var/lib/mkvdup/permissions.yaml /mnt/videos config.yaml
```

### Behavior

**Default behavior (when file/directory not in permissions.yaml):**
1. Use defaults from command-line options if specified
2. For direct mounts (`mkvdup mount`): default to the calling user's UID/GID with mode `0444` for files, `0555` for directories
3. For fstab/systemd mounts: default to `root:root` (uid=0, gid=0) since the mount helper runs as root

**Note:** The fstab mount helper (`mount.fuse.mkvdup`) automatically enables `allow_other` so that root can access the filesystem for `chown`/`chmod` operations via `sudo`.

**On chmod/chown:**
1. Permission changes are saved immediately to the permissions file
2. The permissions file's parent directory (e.g., `~/.config/mkvdup/`) is created if it doesn't exist
3. Changes persist across daemon restarts

**On mount:**
1. Permissions file is loaded (or created with defaults)
2. Stale entries (for files/directories that no longer exist) are automatically removed

**On SIGHUP reload (future work):**
1. Permissions file is reloaded from disk
2. Stale entries are cleaned up

## Memory Management

**Goal:** Keep memory footprint low even with many virtual files.

**Strategy: Lazy loading with reference counting**

Files are NOT memory-mapped at startup. Instead:

1. **On file open (FUSE Open):**
   - Increment reference count
   - If first open: memory-map the dedup file and source files
   - Parse index entries via `sync.Once` (thread-safe)

2. **On file close (FUSE Release):**
   - Decrement reference count
   - If count reaches 0: unmap all files

**Result:**
- At startup: Only config parsed, no files mapped
- During playback: Only active files are mapped
- After playback: Files unmapped, memory returned to OS
- 100 configured videos = ~0 memory if none are playing

**Optional:** Add a configurable grace period before unmapping (e.g., 30 seconds after close) to avoid repeated map/unmap for quick seeks.

## Multi-threading

go-fuse handles concurrent request processing automatically. Planned: configurable tuning via mount config.

**Benefits of multi-threading:**

| Scenario | Single-threaded | Multi-threaded |
|----------|-----------------|----------------|
| One video playing | OK | Same |
| Multiple videos playing | Serialized reads, stuttering | Parallel reads, smooth |
| Player read-ahead | Blocks other reads | Parallel prefetch |
| Multiple users | Poor | Good |

**Tuning guidance:**

| Workload | Recommended threads | Notes |
|----------|---------------------|-------|
| Single user, local playback | 2-4 | Low overhead |
| Media server (Jellyfin/Plex) | NumCPU | Multiple streams |
| NAS with many users | NumCPU * 2 | I/O bound |
| Low-power device | 1-2 | Reduce CPU usage |

## Health Checks *(planned — [#12](https://github.com/stuckj/mkvdup/issues/12))*

> **Not yet implemented.** The following describes planned behavior.

Optional background health monitoring:

```yaml
# In mount config
health_check:
  enabled: true
  interval: 1h           # Check every hour
  check_source_sizes: true
  check_source_checksums: false  # Too slow for routine checks
  on_error: warn         # warn, disable_file, or unmount
```

## Source File Watching *(planned — [#11](https://github.com/stuckj/mkvdup/issues/11))*

> **Not yet implemented.** The following describes planned behavior.

Optional inotify-based monitoring of source files:

```yaml
# In mount config
source_watch:
  enabled: true
  on_change: checksum    # checksum, disable_file, or warn
  checksum_threads: 2    # Parallel checksum workers
```

**On source file change:**
- `warn`: Log warning only
- `disable_file`: Mark affected virtual files as unavailable
- `checksum`: Verify source file checksum, disable if changed

## Error Handling

| Error | Impact | Recovery |
|-------|--------|----------|
| Dedup file missing | Virtual file unavailable | Return ENOENT |
| Dedup file corrupt | Virtual file unavailable | Return EIO, log error |
| Source file missing | Virtual file unavailable | Return EIO |
| Source file wrong size | Virtual file unavailable | Return EIO |
| Config file invalid | Mount/reload fails | Log error, keep old config |

When errors occur for a specific virtual file, other files remain accessible. Files with persistent errors automatically retry after a 5-minute cooldown period.

## inotify Events

The FUSE filesystem emits standard inotify events when the config is reloaded:
- `IN_CREATE` for added files
- `IN_DELETE` for removed files

Applications watching the mountpoint (e.g., Jellyfin/Plex) will automatically detect changes.

## Related Documentation

- [CLI Commands](CLI.md) - Mount and reload commands
- [File Format](FILE_FORMAT.md) - Binary format being served
