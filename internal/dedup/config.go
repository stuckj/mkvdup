package dedup

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/bmatcuk/doublestar/v4"
	"gopkg.in/yaml.v3"
)

// Config represents the contents of a .mkvdup.yaml file.
type Config struct {
	Name      string `yaml:"name"`
	DedupFile string `yaml:"dedup_file"`
	SourceDir string `yaml:"source_dir"`
}

// configFile is the internal YAML representation that supports includes
// and virtual_files in addition to the standard Config fields.
type configFile struct {
	Name           string              `yaml:"name"`
	DedupFile      string              `yaml:"dedup_file"`
	SourceDir      string              `yaml:"source_dir"`
	Includes       []string            `yaml:"includes"`
	VirtualFiles   []Config            `yaml:"virtual_files"`
	OnErrorCommand *ErrorCommandConfig `yaml:"on_error_command"`
}

// ErrorCommandConfig configures an external command to run when a source
// integrity issue is detected. Placeholders in command arguments (%source%,
// %files%, %event%) are substituted at runtime.
type ErrorCommandConfig struct {
	Command       CommandValue  `yaml:"command"`
	Timeout       time.Duration `yaml:"timeout"`
	BatchInterval time.Duration `yaml:"batch_interval"`
}

// applyDefaults fills in zero-value fields with sensible defaults.
func (c *ErrorCommandConfig) applyDefaults() {
	if c.Timeout <= 0 {
		c.Timeout = 30 * time.Second
	}
	if c.BatchInterval <= 0 {
		c.BatchInterval = 5 * time.Second
	}
}

// CommandValue supports both string and []string YAML formats.
// A string value is executed via "sh -c"; a list is executed directly.
type CommandValue struct {
	IsShell bool     // true if the original YAML was a string (run via sh -c)
	Args    []string // for shell: single element with the command string; for list: the arg list
}

// UnmarshalYAML implements custom unmarshaling for CommandValue.
func (c *CommandValue) UnmarshalYAML(value *yaml.Node) error {
	// Try string first
	if value.Kind == yaml.ScalarNode {
		var s string
		if err := value.Decode(&s); err != nil {
			return err
		}
		if s == "" {
			return fmt.Errorf("on_error_command: command must not be empty")
		}
		c.IsShell = true
		c.Args = []string{s}
		return nil
	}

	// Try list
	if value.Kind == yaml.SequenceNode {
		var list []string
		if err := value.Decode(&list); err != nil {
			return err
		}
		if len(list) == 0 {
			return fmt.Errorf("on_error_command: command list must not be empty")
		}
		c.IsShell = false
		c.Args = list
		return nil
	}

	return fmt.Errorf("on_error_command: command must be a string or list of strings")
}

// WriteConfig writes the .mkvdup.yaml config file.
func WriteConfig(configPath, name, dedupFile, sourceDir string) error {
	content := fmt.Sprintf(`# Auto-generated by mkvdup create
name: %q
dedup_file: %q
source_dir: %q
`, name, dedupFile, sourceDir)

	return os.WriteFile(configPath, []byte(content), 0644)
}

// ReadConfig reads a .mkvdup.yaml config file.
func ReadConfig(configPath string) (*Config, error) {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("read config file: %w", err)
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("parse config %s: %w", configPath, err)
	}

	if config.Name == "" || config.DedupFile == "" || config.SourceDir == "" {
		return nil, fmt.Errorf("invalid config: missing required fields")
	}

	return &config, nil
}

// ResolveConfigs reads config files and recursively expands includes and
// virtual_files into a flat list of Config entries. Cycle detection prevents
// infinite recursion from circular includes.
//
// If any config file contains an on_error_command block, the first one
// encountered (depth-first, in file order) is returned. Defaults are applied
// for omitted timeout and batch_interval fields.
func ResolveConfigs(configPaths []string) ([]Config, *ErrorCommandConfig, error) {
	seen := make(map[string]bool)
	var all []Config
	var errorCmd *ErrorCommandConfig
	for _, p := range configPaths {
		configs, cmd, err := resolveConfig(p, seen)
		if err != nil {
			return nil, nil, err
		}
		all = append(all, configs...)
		if errorCmd == nil && cmd != nil {
			errorCmd = cmd
		}
	}
	if errorCmd != nil {
		if len(errorCmd.Command.Args) == 0 {
			return nil, nil, fmt.Errorf("invalid on_error_command: missing command")
		}
		errorCmd.applyDefaults()
	}
	return all, errorCmd, nil
}

// resolveConfig recursively resolves a single config file.
// Returns the file configs and the first on_error_command encountered (or nil).
func resolveConfig(configPath string, seen map[string]bool) ([]Config, *ErrorCommandConfig, error) {
	absPath, err := filepath.Abs(configPath)
	if err != nil {
		return nil, nil, fmt.Errorf("resolve path %s: %w", configPath, err)
	}

	// Resolve symlinks for reliable cycle detection.
	realPath, err := filepath.EvalSymlinks(absPath)
	if err != nil {
		return nil, nil, fmt.Errorf("resolve symlinks %s: %w", absPath, err)
	}

	if seen[realPath] {
		log.Printf("warning: skipping already-seen config %s (cycle detection)", realPath)
		return nil, nil, nil
	}
	seen[realPath] = true

	data, err := os.ReadFile(realPath)
	if err != nil {
		return nil, nil, fmt.Errorf("read config file %s: %w", realPath, err)
	}

	var cf configFile
	if err := yaml.Unmarshal(data, &cf); err != nil {
		return nil, nil, fmt.Errorf("parse config %s: %w", realPath, err)
	}

	configDir := filepath.Dir(realPath)
	var configs []Config
	var errorCmd *ErrorCommandConfig

	// Capture on_error_command from this file (first-wins across resolution).
	if cf.OnErrorCommand != nil {
		errorCmd = cf.OnErrorCommand
	}

	// If top-level name/dedup_file/source_dir are set, add as a Config entry.
	hasName := cf.Name != ""
	hasDedup := cf.DedupFile != ""
	hasSource := cf.SourceDir != ""
	if hasName || hasDedup || hasSource {
		if !hasName || !hasDedup || !hasSource {
			return nil, nil, fmt.Errorf("config %s: name, dedup_file, and source_dir must all be set if any is set", realPath)
		}
		configs = append(configs, Config{
			Name:      cf.Name,
			DedupFile: resolveRelative(configDir, cf.DedupFile),
			SourceDir: resolveRelative(configDir, cf.SourceDir),
		})
	}

	// Process includes.
	for _, pattern := range cf.Includes {
		pattern = resolveRelative(configDir, pattern)
		matches, err := doublestar.FilepathGlob(pattern)
		if err != nil {
			return nil, nil, fmt.Errorf("expand include pattern %q in %s: %w", pattern, realPath, err)
		}
		sort.Strings(matches)
		for _, match := range matches {
			sub, cmd, err := resolveConfig(match, seen)
			if err != nil {
				return nil, nil, err
			}
			configs = append(configs, sub...)
			if errorCmd == nil && cmd != nil {
				errorCmd = cmd
			}
		}
	}

	// Process virtual_files.
	for _, vf := range cf.VirtualFiles {
		if vf.Name == "" || vf.DedupFile == "" || vf.SourceDir == "" {
			return nil, nil, fmt.Errorf("config %s: virtual_files entry missing required fields (name, dedup_file, source_dir)", realPath)
		}
		configs = append(configs, Config{
			Name:      vf.Name,
			DedupFile: resolveRelative(configDir, vf.DedupFile),
			SourceDir: resolveRelative(configDir, vf.SourceDir),
		})
	}

	return configs, errorCmd, nil
}

// BatchManifest represents the batch create manifest file format.
type BatchManifest struct {
	SourceDir string              `yaml:"source_dir"`
	Files     []BatchManifestFile `yaml:"files"`
}

// BatchManifestFile represents a single file entry in a batch manifest.
type BatchManifestFile struct {
	MKV       string `yaml:"mkv"`
	Output    string `yaml:"output"`
	Name      string `yaml:"name"`
	SourceDir string `yaml:"source_dir"`
}

// ReadBatchManifest reads and validates a batch manifest file.
// Relative paths are resolved against the manifest file's directory.
// Default values are applied for optional fields.
func ReadBatchManifest(manifestPath string) (*BatchManifest, error) {
	data, err := os.ReadFile(manifestPath)
	if err != nil {
		return nil, fmt.Errorf("read batch manifest: %w", err)
	}

	var manifest BatchManifest
	if err := yaml.Unmarshal(data, &manifest); err != nil {
		return nil, fmt.Errorf("parse batch manifest %s: %w", manifestPath, err)
	}

	if len(manifest.Files) == 0 {
		return nil, fmt.Errorf("batch manifest %s: files list is empty", manifestPath)
	}

	absPath, err := filepath.Abs(manifestPath)
	if err != nil {
		return nil, fmt.Errorf("resolve manifest path: %w", err)
	}
	manifestDir := filepath.Dir(absPath)

	// Resolve and normalize top-level source_dir relative to manifest (if set)
	if manifest.SourceDir != "" {
		manifest.SourceDir = filepath.Clean(resolveRelative(manifestDir, manifest.SourceDir))
	}

	// Validate and resolve each file entry
	for i := range manifest.Files {
		f := &manifest.Files[i]
		if f.MKV == "" {
			return nil, fmt.Errorf("batch manifest %s: files[%d] missing required 'mkv' field", manifestPath, i)
		}
		f.MKV = resolveRelative(manifestDir, f.MKV)

		if f.Output == "" {
			return nil, fmt.Errorf("batch manifest %s: files[%d] missing required 'output' field", manifestPath, i)
		}
		f.Output = resolveRelative(manifestDir, f.Output)

		// Default name to MKV basename
		if f.Name == "" {
			f.Name = filepath.Base(f.MKV)
		}
		// Ensure name has .mkv extension
		if !strings.HasSuffix(strings.ToLower(f.Name), ".mkv") {
			f.Name += ".mkv"
		}

		// Resolve and normalize per-file source_dir, fall back to top-level default
		if f.SourceDir != "" {
			f.SourceDir = filepath.Clean(resolveRelative(manifestDir, f.SourceDir))
		} else if manifest.SourceDir != "" {
			f.SourceDir = manifest.SourceDir
		} else {
			return nil, fmt.Errorf("batch manifest %s: files[%d] has no source_dir (set per-file or top-level default)", manifestPath, i)
		}
	}

	return &manifest, nil
}

// resolveRelative resolves a path relative to baseDir. If the path is already
// absolute, it is returned unchanged.
func resolveRelative(baseDir, path string) string {
	if filepath.IsAbs(path) {
		return path
	}
	return filepath.Join(baseDir, path)
}
