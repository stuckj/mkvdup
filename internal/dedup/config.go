package dedup

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/bmatcuk/doublestar/v4"
	"gopkg.in/yaml.v3"
)

// Config represents the contents of a .mkvdup.yaml file.
type Config struct {
	Name      string `yaml:"name"`
	DedupFile string `yaml:"dedup_file"`
	SourceDir string `yaml:"source_dir"`
}

// configFile is the internal YAML representation that supports includes
// and virtual_files in addition to the standard Config fields.
type configFile struct {
	Name         string   `yaml:"name"`
	DedupFile    string   `yaml:"dedup_file"`
	SourceDir    string   `yaml:"source_dir"`
	Includes     []string `yaml:"includes"`
	VirtualFiles []Config `yaml:"virtual_files"`
}

// WriteConfig writes the .mkvdup.yaml config file.
func WriteConfig(configPath, name, dedupFile, sourceDir string) error {
	content := fmt.Sprintf(`# Auto-generated by mkvdup create
name: %q
dedup_file: %q
source_dir: %q
`, name, dedupFile, sourceDir)

	return os.WriteFile(configPath, []byte(content), 0644)
}

// ReadConfig reads a .mkvdup.yaml config file.
func ReadConfig(configPath string) (*Config, error) {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("read config file: %w", err)
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("parse config %s: %w", configPath, err)
	}

	if config.Name == "" || config.DedupFile == "" || config.SourceDir == "" {
		return nil, fmt.Errorf("invalid config: missing required fields")
	}

	return &config, nil
}

// ResolveConfigs reads config files and recursively expands includes and
// virtual_files into a flat list of Config entries. Cycle detection prevents
// infinite recursion from circular includes.
func ResolveConfigs(configPaths []string) ([]Config, error) {
	seen := make(map[string]bool)
	var all []Config
	for _, p := range configPaths {
		configs, err := resolveConfig(p, seen)
		if err != nil {
			return nil, err
		}
		all = append(all, configs...)
	}
	return all, nil
}

// resolveConfig recursively resolves a single config file.
func resolveConfig(configPath string, seen map[string]bool) ([]Config, error) {
	absPath, err := filepath.Abs(configPath)
	if err != nil {
		return nil, fmt.Errorf("resolve path %s: %w", configPath, err)
	}

	// Resolve symlinks for reliable cycle detection.
	realPath, err := filepath.EvalSymlinks(absPath)
	if err != nil {
		return nil, fmt.Errorf("resolve symlinks %s: %w", absPath, err)
	}

	if seen[realPath] {
		log.Printf("warning: skipping already-seen config %s (cycle detection)", realPath)
		return nil, nil
	}
	seen[realPath] = true

	data, err := os.ReadFile(realPath)
	if err != nil {
		return nil, fmt.Errorf("read config file %s: %w", realPath, err)
	}

	var cf configFile
	if err := yaml.Unmarshal(data, &cf); err != nil {
		return nil, fmt.Errorf("parse config %s: %w", realPath, err)
	}

	configDir := filepath.Dir(realPath)
	var configs []Config

	// If top-level name/dedup_file/source_dir are set, add as a Config entry.
	hasName := cf.Name != ""
	hasDedup := cf.DedupFile != ""
	hasSource := cf.SourceDir != ""
	if hasName || hasDedup || hasSource {
		if !hasName || !hasDedup || !hasSource {
			return nil, fmt.Errorf("config %s: name, dedup_file, and source_dir must all be set if any is set", realPath)
		}
		configs = append(configs, Config{
			Name:      cf.Name,
			DedupFile: resolveRelative(configDir, cf.DedupFile),
			SourceDir: resolveRelative(configDir, cf.SourceDir),
		})
	}

	// Process includes.
	for _, pattern := range cf.Includes {
		pattern = resolveRelative(configDir, pattern)
		matches, err := doublestar.FilepathGlob(pattern)
		if err != nil {
			return nil, fmt.Errorf("expand include pattern %q in %s: %w", pattern, realPath, err)
		}
		sort.Strings(matches)
		for _, match := range matches {
			sub, err := resolveConfig(match, seen)
			if err != nil {
				return nil, err
			}
			configs = append(configs, sub...)
		}
	}

	// Process virtual_files.
	for _, vf := range cf.VirtualFiles {
		if vf.Name == "" || vf.DedupFile == "" || vf.SourceDir == "" {
			return nil, fmt.Errorf("config %s: virtual_files entry missing required fields (name, dedup_file, source_dir)", realPath)
		}
		configs = append(configs, Config{
			Name:      vf.Name,
			DedupFile: resolveRelative(configDir, vf.DedupFile),
			SourceDir: resolveRelative(configDir, vf.SourceDir),
		})
	}

	return configs, nil
}

// BatchManifest represents the batch create manifest file format.
type BatchManifest struct {
	SourceDir string              `yaml:"source_dir"`
	Files     []BatchManifestFile `yaml:"files"`
}

// BatchManifestFile represents a single file entry in a batch manifest.
type BatchManifestFile struct {
	MKV       string `yaml:"mkv"`
	Output    string `yaml:"output"`
	Name      string `yaml:"name"`
	SourceDir string `yaml:"source_dir"`
}

// ReadBatchManifest reads and validates a batch manifest file.
// Relative paths are resolved against the manifest file's directory.
// Default values are applied for optional fields.
func ReadBatchManifest(manifestPath string) (*BatchManifest, error) {
	data, err := os.ReadFile(manifestPath)
	if err != nil {
		return nil, fmt.Errorf("read batch manifest: %w", err)
	}

	var manifest BatchManifest
	if err := yaml.Unmarshal(data, &manifest); err != nil {
		return nil, fmt.Errorf("parse batch manifest %s: %w", manifestPath, err)
	}

	if len(manifest.Files) == 0 {
		return nil, fmt.Errorf("batch manifest %s: files list is empty", manifestPath)
	}

	absPath, err := filepath.Abs(manifestPath)
	if err != nil {
		return nil, fmt.Errorf("resolve manifest path: %w", err)
	}
	manifestDir := filepath.Dir(absPath)

	// Resolve top-level source_dir relative to manifest (if set)
	if manifest.SourceDir != "" {
		manifest.SourceDir = resolveRelative(manifestDir, manifest.SourceDir)
	}

	// Validate and resolve each file entry
	for i := range manifest.Files {
		f := &manifest.Files[i]
		if f.MKV == "" {
			return nil, fmt.Errorf("batch manifest %s: files[%d] missing required 'mkv' field", manifestPath, i)
		}
		f.MKV = resolveRelative(manifestDir, f.MKV)

		if f.Output == "" {
			return nil, fmt.Errorf("batch manifest %s: files[%d] missing required 'output' field", manifestPath, i)
		}
		f.Output = resolveRelative(manifestDir, f.Output)

		// Default name to MKV basename
		if f.Name == "" {
			f.Name = filepath.Base(f.MKV)
		}
		// Ensure name has .mkv extension
		if !strings.HasSuffix(strings.ToLower(f.Name), ".mkv") {
			f.Name += ".mkv"
		}

		// Resolve per-file source_dir, fall back to top-level default
		if f.SourceDir != "" {
			f.SourceDir = resolveRelative(manifestDir, f.SourceDir)
		} else if manifest.SourceDir != "" {
			f.SourceDir = manifest.SourceDir
		} else {
			return nil, fmt.Errorf("batch manifest %s: files[%d] has no source_dir (set per-file or top-level default)", manifestPath, i)
		}
	}

	return &manifest, nil
}

// resolveRelative resolves a path relative to baseDir. If the path is already
// absolute, it is returned unchanged.
func resolveRelative(baseDir, path string) string {
	if filepath.IsAbs(path) {
		return path
	}
	return filepath.Join(baseDir, path)
}
